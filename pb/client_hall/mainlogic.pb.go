// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mainlogic.proto

package client_hall

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	share_message "game_server/pb/share_message"
	github_com_akqp2019_protobuf_proto "github.com/akqp2019/protobuf/proto"
	proto "github.com/akqp2019/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type LoginMsg struct {
	Account              *string  `protobuf:"bytes,1,req,name=Account" json:"Account,omitempty" bson:"Account,omitempty"`
	Token                *string  `protobuf:"bytes,2,opt,name=Token" json:"Token,omitempty" bson:"Token,omitempty"`
	RegistrationId       *string  `protobuf:"bytes,3,opt,name=RegistrationId" json:"RegistrationId,omitempty" bson:"RegistrationId,omitempty"`
	Channel              *string  `protobuf:"bytes,4,opt,name=Channel" json:"Channel,omitempty" bson:"Channel,omitempty"`
	LoginType            *int32   `protobuf:"varint,5,opt,name=login_type" json:"login_type,omitempty" bson:"login_type,omitempty"`
	DeviceType           *int32   `protobuf:"varint,6,opt,name=device_type" json:"device_type,omitempty" bson:"device_type,omitempty"`
	Type                 *int32   `protobuf:"varint,7,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	PlayerId             *int64   `protobuf:"varint,8,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	VersionNumber        *string  `protobuf:"bytes,9,opt,name=VersionNumber" json:"VersionNumber,omitempty" bson:"VersionNumber,omitempty"`
	Brand                *string  `protobuf:"bytes,10,opt,name=Brand" json:"Brand,omitempty" bson:"Brand,omitempty"`
	IsAppAct             *bool    `protobuf:"varint,11,opt,name=IsAppAct" json:"IsAppAct,omitempty" bson:"IsAppAct,omitempty"`
	IsUserReg            *bool    `protobuf:"varint,12,opt,name=IsUserReg" json:"IsUserReg,omitempty" bson:"IsUserReg,omitempty"`
	IsLoginMan           *bool    `protobuf:"varint,13,opt,name=IsLoginMan" json:"IsLoginMan,omitempty" bson:"IsLoginMan,omitempty"`
	IsLoginFreq          *bool    `protobuf:"varint,14,opt,name=IsLoginFreq" json:"IsLoginFreq,omitempty" bson:"IsLoginFreq,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *LoginMsg) Reset()         { *m = LoginMsg{} }
func (m *LoginMsg) String() string { return proto.CompactTextString(m) }
func (*LoginMsg) ProtoMessage()    {}
func (*LoginMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{0}
}
func (m *LoginMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginMsg.Merge(m, src)
}
func (m *LoginMsg) XXX_Size() int {
	return m.Size()
}
func (m *LoginMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginMsg.DiscardUnknown(m)
}

var xxx_messageInfo_LoginMsg proto.InternalMessageInfo

func (m *LoginMsg) GetAccount() string {
	if m != nil && m.Account != nil {
		return *m.Account
	}
	return ""
}

func (m *LoginMsg) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

func (m *LoginMsg) GetRegistrationId() string {
	if m != nil && m.RegistrationId != nil {
		return *m.RegistrationId
	}
	return ""
}

func (m *LoginMsg) GetChannel() string {
	if m != nil && m.Channel != nil {
		return *m.Channel
	}
	return ""
}

func (m *LoginMsg) GetLoginType() int32 {
	if m != nil && m.LoginType != nil {
		return *m.LoginType
	}
	return 0
}

func (m *LoginMsg) GetDeviceType() int32 {
	if m != nil && m.DeviceType != nil {
		return *m.DeviceType
	}
	return 0
}

func (m *LoginMsg) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LoginMsg) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *LoginMsg) GetVersionNumber() string {
	if m != nil && m.VersionNumber != nil {
		return *m.VersionNumber
	}
	return ""
}

func (m *LoginMsg) GetBrand() string {
	if m != nil && m.Brand != nil {
		return *m.Brand
	}
	return ""
}

func (m *LoginMsg) GetIsAppAct() bool {
	if m != nil && m.IsAppAct != nil {
		return *m.IsAppAct
	}
	return false
}

func (m *LoginMsg) GetIsUserReg() bool {
	if m != nil && m.IsUserReg != nil {
		return *m.IsUserReg
	}
	return false
}

func (m *LoginMsg) GetIsLoginMan() bool {
	if m != nil && m.IsLoginMan != nil {
		return *m.IsLoginMan
	}
	return false
}

func (m *LoginMsg) GetIsLoginFreq() bool {
	if m != nil && m.IsLoginFreq != nil {
		return *m.IsLoginFreq
	}
	return false
}

type UpdateGold struct {
	Gold                 *int64   `protobuf:"varint,1,opt,name=Gold" json:"Gold,omitempty" bson:"Gold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *UpdateGold) Reset()         { *m = UpdateGold{} }
func (m *UpdateGold) String() string { return proto.CompactTextString(m) }
func (*UpdateGold) ProtoMessage()    {}
func (*UpdateGold) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{1}
}
func (m *UpdateGold) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGold) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGold.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGold) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGold.Merge(m, src)
}
func (m *UpdateGold) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGold) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGold.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGold proto.InternalMessageInfo

func (m *UpdateGold) GetGold() int64 {
	if m != nil && m.Gold != nil {
		return *m.Gold
	}
	return 0
}

type AddPlayerInfo struct {
	Account              *string                       `protobuf:"bytes,1,req,name=Account" json:"Account,omitempty" bson:"Account,omitempty"`
	Type                 *share_message.AddFriend_Type `protobuf:"varint,2,opt,name=Type,enum=share_message.AddFriend_Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Text                 *string                       `protobuf:"bytes,3,opt,name=Text" json:"Text,omitempty" bson:"Text,omitempty"`
	PlayerId             *int64                        `protobuf:"varint,4,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Mark                 *bool                         `protobuf:"varint,5,opt,name=Mark" json:"Mark,omitempty" bson:"Mark,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-" bson:"-"`
	XXX_unrecognized     []byte                        `json:"-" bson:"-"`
	XXX_sizecache        int32                         `json:"-" bson:"-"`
}

func (m *AddPlayerInfo) Reset()         { *m = AddPlayerInfo{} }
func (m *AddPlayerInfo) String() string { return proto.CompactTextString(m) }
func (*AddPlayerInfo) ProtoMessage()    {}
func (*AddPlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{2}
}
func (m *AddPlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddPlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddPlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddPlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddPlayerInfo.Merge(m, src)
}
func (m *AddPlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *AddPlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AddPlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AddPlayerInfo proto.InternalMessageInfo

func (m *AddPlayerInfo) GetAccount() string {
	if m != nil && m.Account != nil {
		return *m.Account
	}
	return ""
}

func (m *AddPlayerInfo) GetType() share_message.AddFriend_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return share_message.AddFriend_Type_ACCOUNT
}

func (m *AddPlayerInfo) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *AddPlayerInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *AddPlayerInfo) GetMark() bool {
	if m != nil && m.Mark != nil {
		return *m.Mark
	}
	return false
}

type AccountInfo struct {
	Account              *string                       `protobuf:"bytes,1,opt,name=Account" json:"Account,omitempty" bson:"Account,omitempty"`
	Type                 *share_message.AddFriend_Type `protobuf:"varint,2,opt,name=Type,enum=share_message.AddFriend_Type" json:"Type,omitempty" bson:"Type,omitempty"`
	PlayerId             *int64                        `protobuf:"varint,3,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-" bson:"-"`
	XXX_unrecognized     []byte                        `json:"-" bson:"-"`
	XXX_sizecache        int32                         `json:"-" bson:"-"`
}

func (m *AccountInfo) Reset()         { *m = AccountInfo{} }
func (m *AccountInfo) String() string { return proto.CompactTextString(m) }
func (*AccountInfo) ProtoMessage()    {}
func (*AccountInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{3}
}
func (m *AccountInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountInfo.Merge(m, src)
}
func (m *AccountInfo) XXX_Size() int {
	return m.Size()
}
func (m *AccountInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AccountInfo proto.InternalMessageInfo

func (m *AccountInfo) GetAccount() string {
	if m != nil && m.Account != nil {
		return *m.Account
	}
	return ""
}

func (m *AccountInfo) GetType() share_message.AddFriend_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return share_message.AddFriend_Type_ACCOUNT
}

func (m *AccountInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

type AddBookInfo struct {
	PhoneList            []string `protobuf:"bytes,1,rep,name=PhoneList" json:"PhoneList,omitempty" bson:"PhoneList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *AddBookInfo) Reset()         { *m = AddBookInfo{} }
func (m *AddBookInfo) String() string { return proto.CompactTextString(m) }
func (*AddBookInfo) ProtoMessage()    {}
func (*AddBookInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{4}
}
func (m *AddBookInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddBookInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddBookInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddBookInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddBookInfo.Merge(m, src)
}
func (m *AddBookInfo) XXX_Size() int {
	return m.Size()
}
func (m *AddBookInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AddBookInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AddBookInfo proto.InternalMessageInfo

func (m *AddBookInfo) GetPhoneList() []string {
	if m != nil {
		return m.PhoneList
	}
	return nil
}

type CreateTeam struct {
	Mark                 *int32   `protobuf:"varint,1,opt,name=Mark" json:"Mark,omitempty" bson:"Mark,omitempty"`
	PlayerList           []int64  `protobuf:"varint,2,rep,name=PlayerList" json:"PlayerList,omitempty" bson:"PlayerList,omitempty"`
	TeamName             *string  `protobuf:"bytes,3,opt,name=TeamName" json:"TeamName,omitempty" bson:"TeamName,omitempty"`
	AdminId              *int64   `protobuf:"varint,4,opt,name=AdminId" json:"AdminId,omitempty" bson:"AdminId,omitempty"`
	HeadUrl              *string  `protobuf:"bytes,5,opt,name=HeadUrl" json:"HeadUrl,omitempty" bson:"HeadUrl,omitempty"`
	Topic                *string  `protobuf:"bytes,6,opt,name=Topic" json:"Topic,omitempty" bson:"Topic,omitempty"`
	TopicDesc            *string  `protobuf:"bytes,7,opt,name=TopicDesc" json:"TopicDesc,omitempty" bson:"TopicDesc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *CreateTeam) Reset()         { *m = CreateTeam{} }
func (m *CreateTeam) String() string { return proto.CompactTextString(m) }
func (*CreateTeam) ProtoMessage()    {}
func (*CreateTeam) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{5}
}
func (m *CreateTeam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTeam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTeam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTeam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTeam.Merge(m, src)
}
func (m *CreateTeam) XXX_Size() int {
	return m.Size()
}
func (m *CreateTeam) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTeam.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTeam proto.InternalMessageInfo

func (m *CreateTeam) GetMark() int32 {
	if m != nil && m.Mark != nil {
		return *m.Mark
	}
	return 0
}

func (m *CreateTeam) GetPlayerList() []int64 {
	if m != nil {
		return m.PlayerList
	}
	return nil
}

func (m *CreateTeam) GetTeamName() string {
	if m != nil && m.TeamName != nil {
		return *m.TeamName
	}
	return ""
}

func (m *CreateTeam) GetAdminId() int64 {
	if m != nil && m.AdminId != nil {
		return *m.AdminId
	}
	return 0
}

func (m *CreateTeam) GetHeadUrl() string {
	if m != nil && m.HeadUrl != nil {
		return *m.HeadUrl
	}
	return ""
}

func (m *CreateTeam) GetTopic() string {
	if m != nil && m.Topic != nil {
		return *m.Topic
	}
	return ""
}

func (m *CreateTeam) GetTopicDesc() string {
	if m != nil && m.TopicDesc != nil {
		return *m.TopicDesc
	}
	return ""
}

type PeopleIdInfo struct {
	Name                 *string  `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	PeopleId             *string  `protobuf:"bytes,2,opt,name=PeopleId" json:"PeopleId,omitempty" bson:"PeopleId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *PeopleIdInfo) Reset()         { *m = PeopleIdInfo{} }
func (m *PeopleIdInfo) String() string { return proto.CompactTextString(m) }
func (*PeopleIdInfo) ProtoMessage()    {}
func (*PeopleIdInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{6}
}
func (m *PeopleIdInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeopleIdInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeopleIdInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeopleIdInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeopleIdInfo.Merge(m, src)
}
func (m *PeopleIdInfo) XXX_Size() int {
	return m.Size()
}
func (m *PeopleIdInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PeopleIdInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PeopleIdInfo proto.InternalMessageInfo

func (m *PeopleIdInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *PeopleIdInfo) GetPeopleId() string {
	if m != nil && m.PeopleId != nil {
		return *m.PeopleId
	}
	return ""
}

type BankMessage struct {
	UserName             *string  `protobuf:"bytes,1,opt,name=UserName" json:"UserName,omitempty" bson:"UserName,omitempty"`
	IdType               *string  `protobuf:"bytes,2,opt,name=IdType" json:"IdType,omitempty" bson:"IdType,omitempty"`
	IdNo                 *string  `protobuf:"bytes,3,opt,name=IdNo" json:"IdNo,omitempty" bson:"IdNo,omitempty"`
	BankCardNo           *string  `protobuf:"bytes,4,opt,name=BankCardNo" json:"BankCardNo,omitempty" bson:"BankCardNo,omitempty"`
	MobileNo             *string  `protobuf:"bytes,5,opt,name=MobileNo" json:"MobileNo,omitempty" bson:"MobileNo,omitempty"`
	ExpireDate           *string  `protobuf:"bytes,6,opt,name=ExpireDate" json:"ExpireDate,omitempty" bson:"ExpireDate,omitempty"`
	Cvv                  *string  `protobuf:"bytes,7,opt,name=Cvv" json:"Cvv,omitempty" bson:"Cvv,omitempty"`
	BankCode             *string  `protobuf:"bytes,8,opt,name=BankCode" json:"BankCode,omitempty" bson:"BankCode,omitempty"`
	JPOrderNo            *string  `protobuf:"bytes,9,opt,name=JPOrderNo" json:"JPOrderNo,omitempty" bson:"JPOrderNo,omitempty"`
	OrderNo              *string  `protobuf:"bytes,10,opt,name=OrderNo" json:"OrderNo,omitempty" bson:"OrderNo,omitempty"`
	MsgCode              *string  `protobuf:"bytes,11,opt,name=MsgCode" json:"MsgCode,omitempty" bson:"MsgCode,omitempty"`
	SignNo               *string  `protobuf:"bytes,12,opt,name=SignNo" json:"SignNo,omitempty" bson:"SignNo,omitempty"`
	Provice              *string  `protobuf:"bytes,13,opt,name=Provice" json:"Provice,omitempty" bson:"Provice,omitempty"`
	City                 *string  `protobuf:"bytes,14,opt,name=City" json:"City,omitempty" bson:"City,omitempty"`
	Area                 *string  `protobuf:"bytes,15,opt,name=Area" json:"Area,omitempty" bson:"Area,omitempty"`
	IsModify             *bool    `protobuf:"varint,16,opt,name=IsModify" json:"IsModify,omitempty" bson:"IsModify,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *BankMessage) Reset()         { *m = BankMessage{} }
func (m *BankMessage) String() string { return proto.CompactTextString(m) }
func (*BankMessage) ProtoMessage()    {}
func (*BankMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{7}
}
func (m *BankMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BankMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BankMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BankMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BankMessage.Merge(m, src)
}
func (m *BankMessage) XXX_Size() int {
	return m.Size()
}
func (m *BankMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_BankMessage.DiscardUnknown(m)
}

var xxx_messageInfo_BankMessage proto.InternalMessageInfo

func (m *BankMessage) GetUserName() string {
	if m != nil && m.UserName != nil {
		return *m.UserName
	}
	return ""
}

func (m *BankMessage) GetIdType() string {
	if m != nil && m.IdType != nil {
		return *m.IdType
	}
	return ""
}

func (m *BankMessage) GetIdNo() string {
	if m != nil && m.IdNo != nil {
		return *m.IdNo
	}
	return ""
}

func (m *BankMessage) GetBankCardNo() string {
	if m != nil && m.BankCardNo != nil {
		return *m.BankCardNo
	}
	return ""
}

func (m *BankMessage) GetMobileNo() string {
	if m != nil && m.MobileNo != nil {
		return *m.MobileNo
	}
	return ""
}

func (m *BankMessage) GetExpireDate() string {
	if m != nil && m.ExpireDate != nil {
		return *m.ExpireDate
	}
	return ""
}

func (m *BankMessage) GetCvv() string {
	if m != nil && m.Cvv != nil {
		return *m.Cvv
	}
	return ""
}

func (m *BankMessage) GetBankCode() string {
	if m != nil && m.BankCode != nil {
		return *m.BankCode
	}
	return ""
}

func (m *BankMessage) GetJPOrderNo() string {
	if m != nil && m.JPOrderNo != nil {
		return *m.JPOrderNo
	}
	return ""
}

func (m *BankMessage) GetOrderNo() string {
	if m != nil && m.OrderNo != nil {
		return *m.OrderNo
	}
	return ""
}

func (m *BankMessage) GetMsgCode() string {
	if m != nil && m.MsgCode != nil {
		return *m.MsgCode
	}
	return ""
}

func (m *BankMessage) GetSignNo() string {
	if m != nil && m.SignNo != nil {
		return *m.SignNo
	}
	return ""
}

func (m *BankMessage) GetProvice() string {
	if m != nil && m.Provice != nil {
		return *m.Provice
	}
	return ""
}

func (m *BankMessage) GetCity() string {
	if m != nil && m.City != nil {
		return *m.City
	}
	return ""
}

func (m *BankMessage) GetArea() string {
	if m != nil && m.Area != nil {
		return *m.Area
	}
	return ""
}

func (m *BankMessage) GetIsModify() bool {
	if m != nil && m.IsModify != nil {
		return *m.IsModify
	}
	return false
}

type VersionInfo struct {
	Version              *string  `protobuf:"bytes,1,opt,name=Version" json:"Version,omitempty" bson:"Version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *VersionInfo) Reset()         { *m = VersionInfo{} }
func (m *VersionInfo) String() string { return proto.CompactTextString(m) }
func (*VersionInfo) ProtoMessage()    {}
func (*VersionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{8}
}
func (m *VersionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionInfo.Merge(m, src)
}
func (m *VersionInfo) XXX_Size() int {
	return m.Size()
}
func (m *VersionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VersionInfo proto.InternalMessageInfo

func (m *VersionInfo) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

type DelFriendInfo struct {
	PlayerId             *int64   `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	IsBlack              *bool    `protobuf:"varint,2,opt,name=IsBlack" json:"IsBlack,omitempty" bson:"IsBlack,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *DelFriendInfo) Reset()         { *m = DelFriendInfo{} }
func (m *DelFriendInfo) String() string { return proto.CompactTextString(m) }
func (*DelFriendInfo) ProtoMessage()    {}
func (*DelFriendInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{9}
}
func (m *DelFriendInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelFriendInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelFriendInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelFriendInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelFriendInfo.Merge(m, src)
}
func (m *DelFriendInfo) XXX_Size() int {
	return m.Size()
}
func (m *DelFriendInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DelFriendInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DelFriendInfo proto.InternalMessageInfo

func (m *DelFriendInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *DelFriendInfo) GetIsBlack() bool {
	if m != nil && m.IsBlack != nil {
		return *m.IsBlack
	}
	return false
}

type BlackInfo struct {
	Type                 *int32   `protobuf:"varint,1,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	PlayerId             *int64   `protobuf:"varint,2,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *BlackInfo) Reset()         { *m = BlackInfo{} }
func (m *BlackInfo) String() string { return proto.CompactTextString(m) }
func (*BlackInfo) ProtoMessage()    {}
func (*BlackInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{10}
}
func (m *BlackInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlackInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlackInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlackInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlackInfo.Merge(m, src)
}
func (m *BlackInfo) XXX_Size() int {
	return m.Size()
}
func (m *BlackInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BlackInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BlackInfo proto.InternalMessageInfo

func (m *BlackInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *BlackInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

type MoneyAssistantInfo struct {
	LogId                *int64   `protobuf:"varint,1,req,name=LogId" json:"LogId,omitempty" bson:"LogId,omitempty"`
	PlayerId             *int64   `protobuf:"varint,2,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	ChangeGold           *int64   `protobuf:"varint,3,opt,name=ChangeGold" json:"ChangeGold,omitempty" bson:"ChangeGold,omitempty"`
	SourceType           *int32   `protobuf:"varint,4,opt,name=SourceType" json:"SourceType,omitempty" bson:"SourceType,omitempty"`
	Note                 *string  `protobuf:"bytes,5,opt,name=Note" json:"Note,omitempty" bson:"Note,omitempty"`
	CreateTime           *int64   `protobuf:"varint,6,opt,name=CreateTime" json:"CreateTime,omitempty" bson:"CreateTime,omitempty"`
	Gold                 *int64   `protobuf:"varint,7,opt,name=Gold" json:"Gold,omitempty" bson:"Gold,omitempty"`
	OrderId              *string  `protobuf:"bytes,8,opt,name=OrderId" json:"OrderId,omitempty" bson:"OrderId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *MoneyAssistantInfo) Reset()         { *m = MoneyAssistantInfo{} }
func (m *MoneyAssistantInfo) String() string { return proto.CompactTextString(m) }
func (*MoneyAssistantInfo) ProtoMessage()    {}
func (*MoneyAssistantInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{11}
}
func (m *MoneyAssistantInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoneyAssistantInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoneyAssistantInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoneyAssistantInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoneyAssistantInfo.Merge(m, src)
}
func (m *MoneyAssistantInfo) XXX_Size() int {
	return m.Size()
}
func (m *MoneyAssistantInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MoneyAssistantInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MoneyAssistantInfo proto.InternalMessageInfo

func (m *MoneyAssistantInfo) GetLogId() int64 {
	if m != nil && m.LogId != nil {
		return *m.LogId
	}
	return 0
}

func (m *MoneyAssistantInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *MoneyAssistantInfo) GetChangeGold() int64 {
	if m != nil && m.ChangeGold != nil {
		return *m.ChangeGold
	}
	return 0
}

func (m *MoneyAssistantInfo) GetSourceType() int32 {
	if m != nil && m.SourceType != nil {
		return *m.SourceType
	}
	return 0
}

func (m *MoneyAssistantInfo) GetNote() string {
	if m != nil && m.Note != nil {
		return *m.Note
	}
	return ""
}

func (m *MoneyAssistantInfo) GetCreateTime() int64 {
	if m != nil && m.CreateTime != nil {
		return *m.CreateTime
	}
	return 0
}

func (m *MoneyAssistantInfo) GetGold() int64 {
	if m != nil && m.Gold != nil {
		return *m.Gold
	}
	return 0
}

func (m *MoneyAssistantInfo) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

type AllMoneyAssistantInfo struct {
	Info                 []*MoneyAssistantInfo `protobuf:"bytes,1,rep,name=Info" json:"Info,omitempty" bson:"Info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-" bson:"-"`
	XXX_unrecognized     []byte                `json:"-" bson:"-"`
	XXX_sizecache        int32                 `json:"-" bson:"-"`
}

func (m *AllMoneyAssistantInfo) Reset()         { *m = AllMoneyAssistantInfo{} }
func (m *AllMoneyAssistantInfo) String() string { return proto.CompactTextString(m) }
func (*AllMoneyAssistantInfo) ProtoMessage()    {}
func (*AllMoneyAssistantInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{12}
}
func (m *AllMoneyAssistantInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllMoneyAssistantInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllMoneyAssistantInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllMoneyAssistantInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllMoneyAssistantInfo.Merge(m, src)
}
func (m *AllMoneyAssistantInfo) XXX_Size() int {
	return m.Size()
}
func (m *AllMoneyAssistantInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AllMoneyAssistantInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AllMoneyAssistantInfo proto.InternalMessageInfo

func (m *AllMoneyAssistantInfo) GetInfo() []*MoneyAssistantInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type LocationInfo struct {
	X                    *float64 `protobuf:"fixed64,1,opt,name=X" json:"X,omitempty" bson:"X,omitempty"`
	Y                    *float64 `protobuf:"fixed64,2,opt,name=Y" json:"Y,omitempty" bson:"Y,omitempty"`
	Province             *string  `protobuf:"bytes,3,opt,name=Province" json:"Province,omitempty" bson:"Province,omitempty"`
	City                 *string  `protobuf:"bytes,4,opt,name=City" json:"City,omitempty" bson:"City,omitempty"`
	PlayerId             *int64   `protobuf:"varint,5,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Type                 *int32   `protobuf:"varint,6,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Area                 *string  `protobuf:"bytes,7,opt,name=Area" json:"Area,omitempty" bson:"Area,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *LocationInfo) Reset()         { *m = LocationInfo{} }
func (m *LocationInfo) String() string { return proto.CompactTextString(m) }
func (*LocationInfo) ProtoMessage()    {}
func (*LocationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{13}
}
func (m *LocationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationInfo.Merge(m, src)
}
func (m *LocationInfo) XXX_Size() int {
	return m.Size()
}
func (m *LocationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LocationInfo proto.InternalMessageInfo

func (m *LocationInfo) GetX() float64 {
	if m != nil && m.X != nil {
		return *m.X
	}
	return 0
}

func (m *LocationInfo) GetY() float64 {
	if m != nil && m.Y != nil {
		return *m.Y
	}
	return 0
}

func (m *LocationInfo) GetProvince() string {
	if m != nil && m.Province != nil {
		return *m.Province
	}
	return ""
}

func (m *LocationInfo) GetCity() string {
	if m != nil && m.City != nil {
		return *m.City
	}
	return ""
}

func (m *LocationInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *LocationInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LocationInfo) GetArea() string {
	if m != nil && m.Area != nil {
		return *m.Area
	}
	return ""
}

type LocationInfoByPage struct {
	X                    *float64 `protobuf:"fixed64,1,opt,name=X" json:"X,omitempty" bson:"X,omitempty"`
	Y                    *float64 `protobuf:"fixed64,2,opt,name=Y" json:"Y,omitempty" bson:"Y,omitempty"`
	Province             *string  `protobuf:"bytes,3,opt,name=Province" json:"Province,omitempty" bson:"Province,omitempty"`
	City                 *string  `protobuf:"bytes,4,opt,name=City" json:"City,omitempty" bson:"City,omitempty"`
	PlayerId             *int64   `protobuf:"varint,5,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Type                 *int32   `protobuf:"varint,6,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Area                 *string  `protobuf:"bytes,7,opt,name=Area" json:"Area,omitempty" bson:"Area,omitempty"`
	Page                 *int32   `protobuf:"varint,8,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	PageSize             *int32   `protobuf:"varint,9,opt,name=PageSize" json:"PageSize,omitempty" bson:"PageSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *LocationInfoByPage) Reset()         { *m = LocationInfoByPage{} }
func (m *LocationInfoByPage) String() string { return proto.CompactTextString(m) }
func (*LocationInfoByPage) ProtoMessage()    {}
func (*LocationInfoByPage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{14}
}
func (m *LocationInfoByPage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationInfoByPage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationInfoByPage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationInfoByPage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationInfoByPage.Merge(m, src)
}
func (m *LocationInfoByPage) XXX_Size() int {
	return m.Size()
}
func (m *LocationInfoByPage) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationInfoByPage.DiscardUnknown(m)
}

var xxx_messageInfo_LocationInfoByPage proto.InternalMessageInfo

func (m *LocationInfoByPage) GetX() float64 {
	if m != nil && m.X != nil {
		return *m.X
	}
	return 0
}

func (m *LocationInfoByPage) GetY() float64 {
	if m != nil && m.Y != nil {
		return *m.Y
	}
	return 0
}

func (m *LocationInfoByPage) GetProvince() string {
	if m != nil && m.Province != nil {
		return *m.Province
	}
	return ""
}

func (m *LocationInfoByPage) GetCity() string {
	if m != nil && m.City != nil {
		return *m.City
	}
	return ""
}

func (m *LocationInfoByPage) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *LocationInfoByPage) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LocationInfoByPage) GetArea() string {
	if m != nil && m.Area != nil {
		return *m.Area
	}
	return ""
}

func (m *LocationInfoByPage) GetPage() int32 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *LocationInfoByPage) GetPageSize() int32 {
	if m != nil && m.PageSize != nil {
		return *m.PageSize
	}
	return 0
}

type AllLocationPlayerInfo struct {
	PlayerInfo           []*LocationPlayerInfo `protobuf:"bytes,1,rep,name=PlayerInfo" json:"PlayerInfo,omitempty" bson:"PlayerInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-" bson:"-"`
	XXX_unrecognized     []byte                `json:"-" bson:"-"`
	XXX_sizecache        int32                 `json:"-" bson:"-"`
}

func (m *AllLocationPlayerInfo) Reset()         { *m = AllLocationPlayerInfo{} }
func (m *AllLocationPlayerInfo) String() string { return proto.CompactTextString(m) }
func (*AllLocationPlayerInfo) ProtoMessage()    {}
func (*AllLocationPlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{15}
}
func (m *AllLocationPlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllLocationPlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllLocationPlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllLocationPlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllLocationPlayerInfo.Merge(m, src)
}
func (m *AllLocationPlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *AllLocationPlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AllLocationPlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AllLocationPlayerInfo proto.InternalMessageInfo

func (m *AllLocationPlayerInfo) GetPlayerInfo() []*LocationPlayerInfo {
	if m != nil {
		return m.PlayerInfo
	}
	return nil
}

type LocationPlayerInfo struct {
	PlayerId             *int64                     `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Sex                  *int32                     `protobuf:"varint,2,opt,name=Sex" json:"Sex,omitempty" bson:"Sex,omitempty"`
	Distance             *float64                   `protobuf:"fixed64,3,opt,name=Distance" json:"Distance,omitempty" bson:"Distance,omitempty"`
	Signature            *string                    `protobuf:"bytes,4,opt,name=Signature" json:"Signature,omitempty" bson:"Signature,omitempty"`
	IsFriend             *bool                      `protobuf:"varint,5,opt,name=IsFriend" json:"IsFriend,omitempty" bson:"IsFriend,omitempty"`
	HeadIcon             *string                    `protobuf:"bytes,6,opt,name=HeadIcon" json:"HeadIcon,omitempty" bson:"HeadIcon,omitempty"`
	Name                 *string                    `protobuf:"bytes,7,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	Province             *string                    `protobuf:"bytes,8,opt,name=Province" json:"Province,omitempty" bson:"Province,omitempty"`
	City                 *string                    `protobuf:"bytes,9,opt,name=City" json:"City,omitempty" bson:"City,omitempty"`
	Account              *string                    `protobuf:"bytes,10,opt,name=Account" json:"Account,omitempty" bson:"Account,omitempty"`
	Photo                *string                    `protobuf:"bytes,11,opt,name=Photo" json:"Photo,omitempty" bson:"Photo,omitempty"`
	Area                 *string                    `protobuf:"bytes,12,opt,name=Area" json:"Area,omitempty" bson:"Area,omitempty"`
	Types                *int32                     `protobuf:"varint,13,opt,name=Types" json:"Types,omitempty" bson:"Types,omitempty"`
	LabelInfo            []*share_message.LabelInfo `protobuf:"bytes,31,rep,name=LabelInfo" json:"LabelInfo,omitempty" bson:"LabelInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-" bson:"-"`
	XXX_unrecognized     []byte                     `json:"-" bson:"-"`
	XXX_sizecache        int32                      `json:"-" bson:"-"`
}

func (m *LocationPlayerInfo) Reset()         { *m = LocationPlayerInfo{} }
func (m *LocationPlayerInfo) String() string { return proto.CompactTextString(m) }
func (*LocationPlayerInfo) ProtoMessage()    {}
func (*LocationPlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{16}
}
func (m *LocationPlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationPlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationPlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationPlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationPlayerInfo.Merge(m, src)
}
func (m *LocationPlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *LocationPlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationPlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LocationPlayerInfo proto.InternalMessageInfo

func (m *LocationPlayerInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *LocationPlayerInfo) GetSex() int32 {
	if m != nil && m.Sex != nil {
		return *m.Sex
	}
	return 0
}

func (m *LocationPlayerInfo) GetDistance() float64 {
	if m != nil && m.Distance != nil {
		return *m.Distance
	}
	return 0
}

func (m *LocationPlayerInfo) GetSignature() string {
	if m != nil && m.Signature != nil {
		return *m.Signature
	}
	return ""
}

func (m *LocationPlayerInfo) GetIsFriend() bool {
	if m != nil && m.IsFriend != nil {
		return *m.IsFriend
	}
	return false
}

func (m *LocationPlayerInfo) GetHeadIcon() string {
	if m != nil && m.HeadIcon != nil {
		return *m.HeadIcon
	}
	return ""
}

func (m *LocationPlayerInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *LocationPlayerInfo) GetProvince() string {
	if m != nil && m.Province != nil {
		return *m.Province
	}
	return ""
}

func (m *LocationPlayerInfo) GetCity() string {
	if m != nil && m.City != nil {
		return *m.City
	}
	return ""
}

func (m *LocationPlayerInfo) GetAccount() string {
	if m != nil && m.Account != nil {
		return *m.Account
	}
	return ""
}

func (m *LocationPlayerInfo) GetPhoto() string {
	if m != nil && m.Photo != nil {
		return *m.Photo
	}
	return ""
}

func (m *LocationPlayerInfo) GetArea() string {
	if m != nil && m.Area != nil {
		return *m.Area
	}
	return ""
}

func (m *LocationPlayerInfo) GetTypes() int32 {
	if m != nil && m.Types != nil {
		return *m.Types
	}
	return 0
}

func (m *LocationPlayerInfo) GetLabelInfo() []*share_message.LabelInfo {
	if m != nil {
		return m.LabelInfo
	}
	return nil
}

type NearByMessage struct {
	PlayerId             *int64   `protobuf:"varint,1,req,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Content              *string  `protobuf:"bytes,2,opt,name=Content" json:"Content,omitempty" bson:"Content,omitempty"`
	NickName             *string  `protobuf:"bytes,3,opt,name=NickName" json:"NickName,omitempty" bson:"NickName,omitempty"`
	HeadIcon             *string  `protobuf:"bytes,4,opt,name=HeadIcon" json:"HeadIcon,omitempty" bson:"HeadIcon,omitempty"`
	Sex                  *int32   `protobuf:"varint,5,opt,name=Sex" json:"Sex,omitempty" bson:"Sex,omitempty"`
	Provice              *string  `protobuf:"bytes,6,opt,name=Provice" json:"Provice,omitempty" bson:"Provice,omitempty"`
	City                 *string  `protobuf:"bytes,7,opt,name=City" json:"City,omitempty" bson:"City,omitempty"`
	Photo                *string  `protobuf:"bytes,8,opt,name=Photo" json:"Photo,omitempty" bson:"Photo,omitempty"`
	Account              *string  `protobuf:"bytes,9,opt,name=Account" json:"Account,omitempty" bson:"Account,omitempty"`
	Time                 *int64   `protobuf:"varint,10,opt,name=Time" json:"Time,omitempty" bson:"Time,omitempty"`
	IsAdd                *bool    `protobuf:"varint,11,opt,name=IsAdd" json:"IsAdd,omitempty" bson:"IsAdd,omitempty"`
	Signature            *string  `protobuf:"bytes,12,opt,name=Signature" json:"Signature,omitempty" bson:"Signature,omitempty"`
	Types                *int32   `protobuf:"varint,13,opt,name=Types" json:"Types,omitempty" bson:"Types,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *NearByMessage) Reset()         { *m = NearByMessage{} }
func (m *NearByMessage) String() string { return proto.CompactTextString(m) }
func (*NearByMessage) ProtoMessage()    {}
func (*NearByMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{17}
}
func (m *NearByMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NearByMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NearByMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NearByMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NearByMessage.Merge(m, src)
}
func (m *NearByMessage) XXX_Size() int {
	return m.Size()
}
func (m *NearByMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_NearByMessage.DiscardUnknown(m)
}

var xxx_messageInfo_NearByMessage proto.InternalMessageInfo

func (m *NearByMessage) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *NearByMessage) GetContent() string {
	if m != nil && m.Content != nil {
		return *m.Content
	}
	return ""
}

func (m *NearByMessage) GetNickName() string {
	if m != nil && m.NickName != nil {
		return *m.NickName
	}
	return ""
}

func (m *NearByMessage) GetHeadIcon() string {
	if m != nil && m.HeadIcon != nil {
		return *m.HeadIcon
	}
	return ""
}

func (m *NearByMessage) GetSex() int32 {
	if m != nil && m.Sex != nil {
		return *m.Sex
	}
	return 0
}

func (m *NearByMessage) GetProvice() string {
	if m != nil && m.Provice != nil {
		return *m.Provice
	}
	return ""
}

func (m *NearByMessage) GetCity() string {
	if m != nil && m.City != nil {
		return *m.City
	}
	return ""
}

func (m *NearByMessage) GetPhoto() string {
	if m != nil && m.Photo != nil {
		return *m.Photo
	}
	return ""
}

func (m *NearByMessage) GetAccount() string {
	if m != nil && m.Account != nil {
		return *m.Account
	}
	return ""
}

func (m *NearByMessage) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *NearByMessage) GetIsAdd() bool {
	if m != nil && m.IsAdd != nil {
		return *m.IsAdd
	}
	return false
}

func (m *NearByMessage) GetSignature() string {
	if m != nil && m.Signature != nil {
		return *m.Signature
	}
	return ""
}

func (m *NearByMessage) GetTypes() int32 {
	if m != nil && m.Types != nil {
		return *m.Types
	}
	return 0
}

type AllNearByMessage struct {
	NearByMessage        []*NearByMessage `protobuf:"bytes,1,rep,name=NearByMessage" json:"NearByMessage,omitempty" bson:"NearByMessage,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-" bson:"-"`
	XXX_unrecognized     []byte           `json:"-" bson:"-"`
	XXX_sizecache        int32            `json:"-" bson:"-"`
}

func (m *AllNearByMessage) Reset()         { *m = AllNearByMessage{} }
func (m *AllNearByMessage) String() string { return proto.CompactTextString(m) }
func (*AllNearByMessage) ProtoMessage()    {}
func (*AllNearByMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{18}
}
func (m *AllNearByMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllNearByMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllNearByMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllNearByMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllNearByMessage.Merge(m, src)
}
func (m *AllNearByMessage) XXX_Size() int {
	return m.Size()
}
func (m *AllNearByMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_AllNearByMessage.DiscardUnknown(m)
}

var xxx_messageInfo_AllNearByMessage proto.InternalMessageInfo

func (m *AllNearByMessage) GetNearByMessage() []*NearByMessage {
	if m != nil {
		return m.NearByMessage
	}
	return nil
}

type NearByInfoReply struct {
	AllNearByInfo        *AllLocationPlayerInfo `protobuf:"bytes,1,opt,name=AllNearByInfo" json:"AllNearByInfo,omitempty" bson:"AllNearByInfo,omitempty"`
	AllNewNearByInfo     []*NearByMessage       `protobuf:"bytes,2,rep,name=AllNewNearByInfo" json:"AllNewNearByInfo,omitempty" bson:"AllNewNearByInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-" bson:"-"`
	XXX_unrecognized     []byte                 `json:"-" bson:"-"`
	XXX_sizecache        int32                  `json:"-" bson:"-"`
}

func (m *NearByInfoReply) Reset()         { *m = NearByInfoReply{} }
func (m *NearByInfoReply) String() string { return proto.CompactTextString(m) }
func (*NearByInfoReply) ProtoMessage()    {}
func (*NearByInfoReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{19}
}
func (m *NearByInfoReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NearByInfoReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NearByInfoReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NearByInfoReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NearByInfoReply.Merge(m, src)
}
func (m *NearByInfoReply) XXX_Size() int {
	return m.Size()
}
func (m *NearByInfoReply) XXX_DiscardUnknown() {
	xxx_messageInfo_NearByInfoReply.DiscardUnknown(m)
}

var xxx_messageInfo_NearByInfoReply proto.InternalMessageInfo

func (m *NearByInfoReply) GetAllNearByInfo() *AllLocationPlayerInfo {
	if m != nil {
		return m.AllNearByInfo
	}
	return nil
}

func (m *NearByInfoReply) GetAllNewNearByInfo() []*NearByMessage {
	if m != nil {
		return m.AllNewNearByInfo
	}
	return nil
}

type NearByInfoReplyByPage struct {
	AllNearByInfo        *AllLocationPlayerInfo `protobuf:"bytes,1,opt,name=AllNearByInfo" json:"AllNearByInfo,omitempty" bson:"AllNearByInfo,omitempty"`
	AllNewNearByInfo     []*NearByMessage       `protobuf:"bytes,2,rep,name=AllNewNearByInfo" json:"AllNewNearByInfo,omitempty" bson:"AllNewNearByInfo,omitempty"`
	Count                *int32                 `protobuf:"varint,3,opt,name=Count" json:"Count,omitempty" bson:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-" bson:"-"`
	XXX_unrecognized     []byte                 `json:"-" bson:"-"`
	XXX_sizecache        int32                  `json:"-" bson:"-"`
}

func (m *NearByInfoReplyByPage) Reset()         { *m = NearByInfoReplyByPage{} }
func (m *NearByInfoReplyByPage) String() string { return proto.CompactTextString(m) }
func (*NearByInfoReplyByPage) ProtoMessage()    {}
func (*NearByInfoReplyByPage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{20}
}
func (m *NearByInfoReplyByPage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NearByInfoReplyByPage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NearByInfoReplyByPage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NearByInfoReplyByPage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NearByInfoReplyByPage.Merge(m, src)
}
func (m *NearByInfoReplyByPage) XXX_Size() int {
	return m.Size()
}
func (m *NearByInfoReplyByPage) XXX_DiscardUnknown() {
	xxx_messageInfo_NearByInfoReplyByPage.DiscardUnknown(m)
}

var xxx_messageInfo_NearByInfoReplyByPage proto.InternalMessageInfo

func (m *NearByInfoReplyByPage) GetAllNearByInfo() *AllLocationPlayerInfo {
	if m != nil {
		return m.AllNearByInfo
	}
	return nil
}

func (m *NearByInfoReplyByPage) GetAllNewNearByInfo() []*NearByMessage {
	if m != nil {
		return m.AllNewNearByInfo
	}
	return nil
}

func (m *NearByInfoReplyByPage) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

type PageInfo struct {
	Page                 *int32   `protobuf:"varint,1,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	Num                  *int32   `protobuf:"varint,2,opt,name=Num" json:"Num,omitempty" bson:"Num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *PageInfo) Reset()         { *m = PageInfo{} }
func (m *PageInfo) String() string { return proto.CompactTextString(m) }
func (*PageInfo) ProtoMessage()    {}
func (*PageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{21}
}
func (m *PageInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PageInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PageInfo.Merge(m, src)
}
func (m *PageInfo) XXX_Size() int {
	return m.Size()
}
func (m *PageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PageInfo proto.InternalMessageInfo

func (m *PageInfo) GetPage() int32 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *PageInfo) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

type MoneyType struct {
	Type                 *int32   `protobuf:"varint,1,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Year                 *int32   `protobuf:"varint,2,opt,name=Year" json:"Year,omitempty" bson:"Year,omitempty"`
	Month                *int32   `protobuf:"varint,3,opt,name=Month" json:"Month,omitempty" bson:"Month,omitempty"`
	Page                 *int32   `protobuf:"varint,4,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	Num                  *int32   `protobuf:"varint,5,opt,name=Num" json:"Num,omitempty" bson:"Num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *MoneyType) Reset()         { *m = MoneyType{} }
func (m *MoneyType) String() string { return proto.CompactTextString(m) }
func (*MoneyType) ProtoMessage()    {}
func (*MoneyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{22}
}
func (m *MoneyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoneyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoneyType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoneyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoneyType.Merge(m, src)
}
func (m *MoneyType) XXX_Size() int {
	return m.Size()
}
func (m *MoneyType) XXX_DiscardUnknown() {
	xxx_messageInfo_MoneyType.DiscardUnknown(m)
}

var xxx_messageInfo_MoneyType proto.InternalMessageInfo

func (m *MoneyType) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *MoneyType) GetYear() int32 {
	if m != nil && m.Year != nil {
		return *m.Year
	}
	return 0
}

func (m *MoneyType) GetMonth() int32 {
	if m != nil && m.Month != nil {
		return *m.Month
	}
	return 0
}

func (m *MoneyType) GetPage() int32 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *MoneyType) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

type OrderInfo struct {
	Name                 *string                  `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	Time                 *int64                   `protobuf:"varint,2,opt,name=Time" json:"Time,omitempty" bson:"Time,omitempty"`
	Money                *int64                   `protobuf:"varint,3,opt,name=Money" json:"Money,omitempty" bson:"Money,omitempty"`
	HeadIcon             *string                  `protobuf:"bytes,4,opt,name=HeadIcon" json:"HeadIcon,omitempty" bson:"HeadIcon,omitempty"`
	Type                 *int32                   `protobuf:"varint,5,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Statue               *int32                   `protobuf:"varint,6,opt,name=Statue" json:"Statue,omitempty" bson:"Statue,omitempty"`
	Text                 *string                  `protobuf:"bytes,7,opt,name=Text" json:"Text,omitempty" bson:"Text,omitempty"`
	OrderId              *string                  `protobuf:"bytes,8,opt,name=OrderId" json:"OrderId,omitempty" bson:"OrderId,omitempty"`
	RedPacket            *share_message.RedPacket `protobuf:"bytes,9,opt,name=RedPacket" json:"RedPacket,omitempty" bson:"RedPacket,omitempty"`
	PayName              *string                  `protobuf:"bytes,10,opt,name=PayName" json:"PayName,omitempty" bson:"PayName,omitempty"`
	ServiceCharge        *int64                   `protobuf:"varint,11,opt,name=ServiceCharge" json:"ServiceCharge,omitempty" bson:"ServiceCharge,omitempty"`
	ReceiveTime          *int64                   `protobuf:"varint,12,opt,name=ReceiveTime" json:"ReceiveTime,omitempty" bson:"ReceiveTime,omitempty"`
	TransferText         *string                  `protobuf:"bytes,13,opt,name=TransferText" json:"TransferText,omitempty" bson:"TransferText,omitempty"`
	ShopName             *string                  `protobuf:"bytes,14,opt,name=ShopName" json:"ShopName,omitempty" bson:"ShopName,omitempty"`
	BankName             *string                  `protobuf:"bytes,15,opt,name=BankName" json:"BankName,omitempty" bson:"BankName,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-" bson:"-"`
	XXX_unrecognized     []byte                   `json:"-" bson:"-"`
	XXX_sizecache        int32                    `json:"-" bson:"-"`
}

func (m *OrderInfo) Reset()         { *m = OrderInfo{} }
func (m *OrderInfo) String() string { return proto.CompactTextString(m) }
func (*OrderInfo) ProtoMessage()    {}
func (*OrderInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{23}
}
func (m *OrderInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderInfo.Merge(m, src)
}
func (m *OrderInfo) XXX_Size() int {
	return m.Size()
}
func (m *OrderInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OrderInfo proto.InternalMessageInfo

func (m *OrderInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *OrderInfo) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *OrderInfo) GetMoney() int64 {
	if m != nil && m.Money != nil {
		return *m.Money
	}
	return 0
}

func (m *OrderInfo) GetHeadIcon() string {
	if m != nil && m.HeadIcon != nil {
		return *m.HeadIcon
	}
	return ""
}

func (m *OrderInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *OrderInfo) GetStatue() int32 {
	if m != nil && m.Statue != nil {
		return *m.Statue
	}
	return 0
}

func (m *OrderInfo) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *OrderInfo) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

func (m *OrderInfo) GetRedPacket() *share_message.RedPacket {
	if m != nil {
		return m.RedPacket
	}
	return nil
}

func (m *OrderInfo) GetPayName() string {
	if m != nil && m.PayName != nil {
		return *m.PayName
	}
	return ""
}

func (m *OrderInfo) GetServiceCharge() int64 {
	if m != nil && m.ServiceCharge != nil {
		return *m.ServiceCharge
	}
	return 0
}

func (m *OrderInfo) GetReceiveTime() int64 {
	if m != nil && m.ReceiveTime != nil {
		return *m.ReceiveTime
	}
	return 0
}

func (m *OrderInfo) GetTransferText() string {
	if m != nil && m.TransferText != nil {
		return *m.TransferText
	}
	return ""
}

func (m *OrderInfo) GetShopName() string {
	if m != nil && m.ShopName != nil {
		return *m.ShopName
	}
	return ""
}

func (m *OrderInfo) GetBankName() string {
	if m != nil && m.BankName != nil {
		return *m.BankName
	}
	return ""
}

type AllOrderInfo struct {
	OrderInfo            []*OrderInfo `protobuf:"bytes,1,rep,name=OrderInfo" json:"OrderInfo,omitempty" bson:"OrderInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-" bson:"-"`
	XXX_unrecognized     []byte       `json:"-" bson:"-"`
	XXX_sizecache        int32        `json:"-" bson:"-"`
}

func (m *AllOrderInfo) Reset()         { *m = AllOrderInfo{} }
func (m *AllOrderInfo) String() string { return proto.CompactTextString(m) }
func (*AllOrderInfo) ProtoMessage()    {}
func (*AllOrderInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{24}
}
func (m *AllOrderInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllOrderInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllOrderInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllOrderInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllOrderInfo.Merge(m, src)
}
func (m *AllOrderInfo) XXX_Size() int {
	return m.Size()
}
func (m *AllOrderInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AllOrderInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AllOrderInfo proto.InternalMessageInfo

func (m *AllOrderInfo) GetOrderInfo() []*OrderInfo {
	if m != nil {
		return m.OrderInfo
	}
	return nil
}

type CashInfo struct {
	OrderId              *string  `protobuf:"bytes,1,opt,name=OrderId" json:"OrderId,omitempty" bson:"OrderId,omitempty"`
	Time                 *int64   `protobuf:"varint,2,opt,name=Time" json:"Time,omitempty" bson:"Time,omitempty"`
	ChangeGold           *int64   `protobuf:"varint,3,opt,name=ChangeGold" json:"ChangeGold,omitempty" bson:"ChangeGold,omitempty"`
	Gold                 *int64   `protobuf:"varint,4,opt,name=Gold" json:"Gold,omitempty" bson:"Gold,omitempty"`
	Type                 *int32   `protobuf:"varint,5,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *CashInfo) Reset()         { *m = CashInfo{} }
func (m *CashInfo) String() string { return proto.CompactTextString(m) }
func (*CashInfo) ProtoMessage()    {}
func (*CashInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{25}
}
func (m *CashInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CashInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CashInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CashInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CashInfo.Merge(m, src)
}
func (m *CashInfo) XXX_Size() int {
	return m.Size()
}
func (m *CashInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CashInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CashInfo proto.InternalMessageInfo

func (m *CashInfo) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

func (m *CashInfo) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *CashInfo) GetChangeGold() int64 {
	if m != nil && m.ChangeGold != nil {
		return *m.ChangeGold
	}
	return 0
}

func (m *CashInfo) GetGold() int64 {
	if m != nil && m.Gold != nil {
		return *m.Gold
	}
	return 0
}

func (m *CashInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type AllCashInfo struct {
	CashInfo             []*CashInfo `protobuf:"bytes,1,rep,name=CashInfo" json:"CashInfo,omitempty" bson:"CashInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-" bson:"-"`
	XXX_unrecognized     []byte      `json:"-" bson:"-"`
	XXX_sizecache        int32       `json:"-" bson:"-"`
}

func (m *AllCashInfo) Reset()         { *m = AllCashInfo{} }
func (m *AllCashInfo) String() string { return proto.CompactTextString(m) }
func (*AllCashInfo) ProtoMessage()    {}
func (*AllCashInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{26}
}
func (m *AllCashInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllCashInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllCashInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllCashInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllCashInfo.Merge(m, src)
}
func (m *AllCashInfo) XXX_Size() int {
	return m.Size()
}
func (m *AllCashInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AllCashInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AllCashInfo proto.InternalMessageInfo

func (m *AllCashInfo) GetCashInfo() []*CashInfo {
	if m != nil {
		return m.CashInfo
	}
	return nil
}

type RedPacketInfo struct {
	Type                 *int32   `protobuf:"varint,1,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Year                 *int32   `protobuf:"varint,2,opt,name=Year" json:"Year,omitempty" bson:"Year,omitempty"`
	Month                *int32   `protobuf:"varint,3,opt,name=Month" json:"Month,omitempty" bson:"Month,omitempty"`
	Page                 *int32   `protobuf:"varint,4,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	Num                  *int32   `protobuf:"varint,5,opt,name=Num" json:"Num,omitempty" bson:"Num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *RedPacketInfo) Reset()         { *m = RedPacketInfo{} }
func (m *RedPacketInfo) String() string { return proto.CompactTextString(m) }
func (*RedPacketInfo) ProtoMessage()    {}
func (*RedPacketInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{27}
}
func (m *RedPacketInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedPacketInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedPacketInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedPacketInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedPacketInfo.Merge(m, src)
}
func (m *RedPacketInfo) XXX_Size() int {
	return m.Size()
}
func (m *RedPacketInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RedPacketInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RedPacketInfo proto.InternalMessageInfo

func (m *RedPacketInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *RedPacketInfo) GetYear() int32 {
	if m != nil && m.Year != nil {
		return *m.Year
	}
	return 0
}

func (m *RedPacketInfo) GetMonth() int32 {
	if m != nil && m.Month != nil {
		return *m.Month
	}
	return 0
}

func (m *RedPacketInfo) GetPage() int32 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *RedPacketInfo) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

type AllRedPacketInfo struct {
	AllInfo              []*share_message.RedPacket `protobuf:"bytes,1,rep,name=AllInfo" json:"AllInfo,omitempty" bson:"AllInfo,omitempty"`
	LuckCnt              *int32                     `protobuf:"varint,2,opt,name=LuckCnt" json:"LuckCnt,omitempty" bson:"LuckCnt,omitempty"`
	TotalCnt             *int32                     `protobuf:"varint,3,opt,name=TotalCnt" json:"TotalCnt,omitempty" bson:"TotalCnt,omitempty"`
	TotalGold            *int64                     `protobuf:"varint,4,opt,name=TotalGold" json:"TotalGold,omitempty" bson:"TotalGold,omitempty"`
	Type                 *int32                     `protobuf:"varint,5,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-" bson:"-"`
	XXX_unrecognized     []byte                     `json:"-" bson:"-"`
	XXX_sizecache        int32                      `json:"-" bson:"-"`
}

func (m *AllRedPacketInfo) Reset()         { *m = AllRedPacketInfo{} }
func (m *AllRedPacketInfo) String() string { return proto.CompactTextString(m) }
func (*AllRedPacketInfo) ProtoMessage()    {}
func (*AllRedPacketInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{28}
}
func (m *AllRedPacketInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllRedPacketInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllRedPacketInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllRedPacketInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllRedPacketInfo.Merge(m, src)
}
func (m *AllRedPacketInfo) XXX_Size() int {
	return m.Size()
}
func (m *AllRedPacketInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AllRedPacketInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AllRedPacketInfo proto.InternalMessageInfo

func (m *AllRedPacketInfo) GetAllInfo() []*share_message.RedPacket {
	if m != nil {
		return m.AllInfo
	}
	return nil
}

func (m *AllRedPacketInfo) GetLuckCnt() int32 {
	if m != nil && m.LuckCnt != nil {
		return *m.LuckCnt
	}
	return 0
}

func (m *AllRedPacketInfo) GetTotalCnt() int32 {
	if m != nil && m.TotalCnt != nil {
		return *m.TotalCnt
	}
	return 0
}

func (m *AllRedPacketInfo) GetTotalGold() int64 {
	if m != nil && m.TotalGold != nil {
		return *m.TotalGold
	}
	return 0
}

func (m *AllRedPacketInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type WithdrawInfo struct {
	BankCode             *string  `protobuf:"bytes,1,opt,name=BankCode" json:"BankCode,omitempty" bson:"BankCode,omitempty"`
	AccountType          *string  `protobuf:"bytes,2,opt,name=AccountType" json:"AccountType,omitempty" bson:"AccountType,omitempty"`
	AccountNo            *string  `protobuf:"bytes,3,opt,name=AccountNo" json:"AccountNo,omitempty" bson:"AccountNo,omitempty"`
	AccountName          *string  `protobuf:"bytes,4,opt,name=AccountName" json:"AccountName,omitempty" bson:"AccountName,omitempty"`
	AccountProp          *string  `protobuf:"bytes,5,opt,name=AccountProp" json:"AccountProp,omitempty" bson:"AccountProp,omitempty"`
	Amount               *int64   `protobuf:"varint,6,opt,name=Amount" json:"Amount,omitempty" bson:"Amount,omitempty"`
	Result               *bool    `protobuf:"varint,7,opt,name=Result" json:"Result,omitempty" bson:"Result,omitempty"`
	OrderId              *string  `protobuf:"bytes,8,opt,name=OrderId" json:"OrderId,omitempty" bson:"OrderId,omitempty"`
	StartTime            *int64   `protobuf:"varint,9,opt,name=StartTime" json:"StartTime,omitempty" bson:"StartTime,omitempty"`
	Tax                  *int64   `protobuf:"varint,10,opt,name=Tax" json:"Tax,omitempty" bson:"Tax,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *WithdrawInfo) Reset()         { *m = WithdrawInfo{} }
func (m *WithdrawInfo) String() string { return proto.CompactTextString(m) }
func (*WithdrawInfo) ProtoMessage()    {}
func (*WithdrawInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{29}
}
func (m *WithdrawInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawInfo.Merge(m, src)
}
func (m *WithdrawInfo) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawInfo proto.InternalMessageInfo

func (m *WithdrawInfo) GetBankCode() string {
	if m != nil && m.BankCode != nil {
		return *m.BankCode
	}
	return ""
}

func (m *WithdrawInfo) GetAccountType() string {
	if m != nil && m.AccountType != nil {
		return *m.AccountType
	}
	return ""
}

func (m *WithdrawInfo) GetAccountNo() string {
	if m != nil && m.AccountNo != nil {
		return *m.AccountNo
	}
	return ""
}

func (m *WithdrawInfo) GetAccountName() string {
	if m != nil && m.AccountName != nil {
		return *m.AccountName
	}
	return ""
}

func (m *WithdrawInfo) GetAccountProp() string {
	if m != nil && m.AccountProp != nil {
		return *m.AccountProp
	}
	return ""
}

func (m *WithdrawInfo) GetAmount() int64 {
	if m != nil && m.Amount != nil {
		return *m.Amount
	}
	return 0
}

func (m *WithdrawInfo) GetResult() bool {
	if m != nil && m.Result != nil {
		return *m.Result
	}
	return false
}

func (m *WithdrawInfo) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

func (m *WithdrawInfo) GetStartTime() int64 {
	if m != nil && m.StartTime != nil {
		return *m.StartTime
	}
	return 0
}

func (m *WithdrawInfo) GetTax() int64 {
	if m != nil && m.Tax != nil {
		return *m.Tax
	}
	return 0
}

type CheckPeopleInfo struct {
	Type                 *int32   `protobuf:"varint,1,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *CheckPeopleInfo) Reset()         { *m = CheckPeopleInfo{} }
func (m *CheckPeopleInfo) String() string { return proto.CompactTextString(m) }
func (*CheckPeopleInfo) ProtoMessage()    {}
func (*CheckPeopleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{30}
}
func (m *CheckPeopleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckPeopleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckPeopleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckPeopleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckPeopleInfo.Merge(m, src)
}
func (m *CheckPeopleInfo) XXX_Size() int {
	return m.Size()
}
func (m *CheckPeopleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckPeopleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CheckPeopleInfo proto.InternalMessageInfo

func (m *CheckPeopleInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type FirstInfo struct {
	Password             *string  `protobuf:"bytes,1,opt,name=Password" json:"Password,omitempty" bson:"Password,omitempty"`
	Label                []int32  `protobuf:"varint,2,rep,name=Label" json:"Label,omitempty" bson:"Label,omitempty"`
	Sex                  *int32   `protobuf:"varint,3,opt,name=Sex" json:"Sex,omitempty" bson:"Sex,omitempty"`
	NickName             *string  `protobuf:"bytes,4,opt,name=NickName" json:"NickName,omitempty" bson:"NickName,omitempty"`
	Signature            *string  `protobuf:"bytes,5,opt,name=Signature" json:"Signature,omitempty" bson:"Signature,omitempty"`
	HeadIcon             *string  `protobuf:"bytes,6,opt,name=HeadIcon" json:"HeadIcon,omitempty" bson:"HeadIcon,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *FirstInfo) Reset()         { *m = FirstInfo{} }
func (m *FirstInfo) String() string { return proto.CompactTextString(m) }
func (*FirstInfo) ProtoMessage()    {}
func (*FirstInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{31}
}
func (m *FirstInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirstInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirstInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirstInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirstInfo.Merge(m, src)
}
func (m *FirstInfo) XXX_Size() int {
	return m.Size()
}
func (m *FirstInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FirstInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FirstInfo proto.InternalMessageInfo

func (m *FirstInfo) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *FirstInfo) GetLabel() []int32 {
	if m != nil {
		return m.Label
	}
	return nil
}

func (m *FirstInfo) GetSex() int32 {
	if m != nil && m.Sex != nil {
		return *m.Sex
	}
	return 0
}

func (m *FirstInfo) GetNickName() string {
	if m != nil && m.NickName != nil {
		return *m.NickName
	}
	return ""
}

func (m *FirstInfo) GetSignature() string {
	if m != nil && m.Signature != nil {
		return *m.Signature
	}
	return ""
}

func (m *FirstInfo) GetHeadIcon() string {
	if m != nil && m.HeadIcon != nil {
		return *m.HeadIcon
	}
	return ""
}

type FirstReturnInfo struct {
	Type                 *int32   `protobuf:"varint,1,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Content              *string  `protobuf:"bytes,2,opt,name=Content" json:"Content,omitempty" bson:"Content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *FirstReturnInfo) Reset()         { *m = FirstReturnInfo{} }
func (m *FirstReturnInfo) String() string { return proto.CompactTextString(m) }
func (*FirstReturnInfo) ProtoMessage()    {}
func (*FirstReturnInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{32}
}
func (m *FirstReturnInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirstReturnInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirstReturnInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirstReturnInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirstReturnInfo.Merge(m, src)
}
func (m *FirstReturnInfo) XXX_Size() int {
	return m.Size()
}
func (m *FirstReturnInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FirstReturnInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FirstReturnInfo proto.InternalMessageInfo

func (m *FirstReturnInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *FirstReturnInfo) GetContent() string {
	if m != nil && m.Content != nil {
		return *m.Content
	}
	return ""
}

type PayInfo struct {
	PlayerId             *int64                      `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Gold                 *int64                      `protobuf:"varint,2,opt,name=Gold" json:"Gold,omitempty" bson:"Gold,omitempty"`
	Type                 *int32                      `protobuf:"varint,3,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Content              *string                     `protobuf:"bytes,4,opt,name=Content" json:"Content,omitempty" bson:"Content,omitempty"`
	PayOrderInfo         *share_message.PayOrderInfo `protobuf:"bytes,5,opt,name=PayOrderInfo" json:"PayOrderInfo,omitempty" bson:"PayOrderInfo,omitempty"`
	IsWay                *bool                       `protobuf:"varint,6,opt,name=IsWay" json:"IsWay,omitempty" bson:"IsWay,omitempty"`
	Password             *string                     `protobuf:"bytes,7,opt,name=Password" json:"Password,omitempty" bson:"Password,omitempty"`
	BankInfo             *string                     `protobuf:"bytes,8,opt,name=BankInfo" json:"BankInfo,omitempty" bson:"BankInfo,omitempty"`
	OrderId              *string                     `protobuf:"bytes,9,opt,name=OrderId" json:"OrderId,omitempty" bson:"OrderId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-" bson:"-"`
	XXX_unrecognized     []byte                      `json:"-" bson:"-"`
	XXX_sizecache        int32                       `json:"-" bson:"-"`
}

func (m *PayInfo) Reset()         { *m = PayInfo{} }
func (m *PayInfo) String() string { return proto.CompactTextString(m) }
func (*PayInfo) ProtoMessage()    {}
func (*PayInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{33}
}
func (m *PayInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayInfo.Merge(m, src)
}
func (m *PayInfo) XXX_Size() int {
	return m.Size()
}
func (m *PayInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PayInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PayInfo proto.InternalMessageInfo

func (m *PayInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *PayInfo) GetGold() int64 {
	if m != nil && m.Gold != nil {
		return *m.Gold
	}
	return 0
}

func (m *PayInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *PayInfo) GetContent() string {
	if m != nil && m.Content != nil {
		return *m.Content
	}
	return ""
}

func (m *PayInfo) GetPayOrderInfo() *share_message.PayOrderInfo {
	if m != nil {
		return m.PayOrderInfo
	}
	return nil
}

func (m *PayInfo) GetIsWay() bool {
	if m != nil && m.IsWay != nil {
		return *m.IsWay
	}
	return false
}

func (m *PayInfo) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *PayInfo) GetBankInfo() string {
	if m != nil && m.BankInfo != nil {
		return *m.BankInfo
	}
	return ""
}

func (m *PayInfo) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

type AllCollectInfo struct {
	CollectInfo          []*share_message.CollectInfo `protobuf:"bytes,1,rep,name=CollectInfo" json:"CollectInfo,omitempty" bson:"CollectInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-" bson:"-"`
	XXX_unrecognized     []byte                       `json:"-" bson:"-"`
	XXX_sizecache        int32                        `json:"-" bson:"-"`
}

func (m *AllCollectInfo) Reset()         { *m = AllCollectInfo{} }
func (m *AllCollectInfo) String() string { return proto.CompactTextString(m) }
func (*AllCollectInfo) ProtoMessage()    {}
func (*AllCollectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{34}
}
func (m *AllCollectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllCollectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllCollectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllCollectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllCollectInfo.Merge(m, src)
}
func (m *AllCollectInfo) XXX_Size() int {
	return m.Size()
}
func (m *AllCollectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AllCollectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AllCollectInfo proto.InternalMessageInfo

func (m *AllCollectInfo) GetCollectInfo() []*share_message.CollectInfo {
	if m != nil {
		return m.CollectInfo
	}
	return nil
}

type DelCollectInfo struct {
	Index                *int32   `protobuf:"varint,1,opt,name=Index" json:"Index,omitempty" bson:"Index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *DelCollectInfo) Reset()         { *m = DelCollectInfo{} }
func (m *DelCollectInfo) String() string { return proto.CompactTextString(m) }
func (*DelCollectInfo) ProtoMessage()    {}
func (*DelCollectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{35}
}
func (m *DelCollectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelCollectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelCollectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelCollectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelCollectInfo.Merge(m, src)
}
func (m *DelCollectInfo) XXX_Size() int {
	return m.Size()
}
func (m *DelCollectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DelCollectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DelCollectInfo proto.InternalMessageInfo

func (m *DelCollectInfo) GetIndex() int32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

type GetCollectInfo struct {
	Page                 *int32   `protobuf:"varint,1,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	Num                  *int32   `protobuf:"varint,2,opt,name=Num" json:"Num,omitempty" bson:"Num,omitempty"`
	Type                 *int32   `protobuf:"varint,3,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *GetCollectInfo) Reset()         { *m = GetCollectInfo{} }
func (m *GetCollectInfo) String() string { return proto.CompactTextString(m) }
func (*GetCollectInfo) ProtoMessage()    {}
func (*GetCollectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{36}
}
func (m *GetCollectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCollectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCollectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCollectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCollectInfo.Merge(m, src)
}
func (m *GetCollectInfo) XXX_Size() int {
	return m.Size()
}
func (m *GetCollectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCollectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GetCollectInfo proto.InternalMessageInfo

func (m *GetCollectInfo) GetPage() int32 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *GetCollectInfo) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

func (m *GetCollectInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type SearchCollectInfo struct {
	Content              *string  `protobuf:"bytes,1,opt,name=Content" json:"Content,omitempty" bson:"Content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *SearchCollectInfo) Reset()         { *m = SearchCollectInfo{} }
func (m *SearchCollectInfo) String() string { return proto.CompactTextString(m) }
func (*SearchCollectInfo) ProtoMessage()    {}
func (*SearchCollectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{37}
}
func (m *SearchCollectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchCollectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchCollectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchCollectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchCollectInfo.Merge(m, src)
}
func (m *SearchCollectInfo) XXX_Size() int {
	return m.Size()
}
func (m *SearchCollectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchCollectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SearchCollectInfo proto.InternalMessageInfo

func (m *SearchCollectInfo) GetContent() string {
	if m != nil && m.Content != nil {
		return *m.Content
	}
	return ""
}

type PayForCodeInfo struct {
	Type                 *int32   `protobuf:"varint,1,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *PayForCodeInfo) Reset()         { *m = PayForCodeInfo{} }
func (m *PayForCodeInfo) String() string { return proto.CompactTextString(m) }
func (*PayForCodeInfo) ProtoMessage()    {}
func (*PayForCodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{38}
}
func (m *PayForCodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayForCodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayForCodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayForCodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayForCodeInfo.Merge(m, src)
}
func (m *PayForCodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *PayForCodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PayForCodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PayForCodeInfo proto.InternalMessageInfo

func (m *PayForCodeInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type CodeInfo struct {
	PlayerId             *int64   `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Gold                 *int64   `protobuf:"varint,2,opt,name=Gold" json:"Gold,omitempty" bson:"Gold,omitempty"`
	Name                 *string  `protobuf:"bytes,3,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	HeadIcon             *string  `protobuf:"bytes,4,opt,name=HeadIcon" json:"HeadIcon,omitempty" bson:"HeadIcon,omitempty"`
	TeamId               *int64   `protobuf:"varint,5,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	FailReason           *string  `protobuf:"bytes,6,opt,name=FailReason" json:"FailReason,omitempty" bson:"FailReason,omitempty"`
	Code                 *string  `protobuf:"bytes,7,opt,name=Code" json:"Code,omitempty" bson:"Code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *CodeInfo) Reset()         { *m = CodeInfo{} }
func (m *CodeInfo) String() string { return proto.CompactTextString(m) }
func (*CodeInfo) ProtoMessage()    {}
func (*CodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{39}
}
func (m *CodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodeInfo.Merge(m, src)
}
func (m *CodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *CodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CodeInfo proto.InternalMessageInfo

func (m *CodeInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *CodeInfo) GetGold() int64 {
	if m != nil && m.Gold != nil {
		return *m.Gold
	}
	return 0
}

func (m *CodeInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CodeInfo) GetHeadIcon() string {
	if m != nil && m.HeadIcon != nil {
		return *m.HeadIcon
	}
	return ""
}

func (m *CodeInfo) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *CodeInfo) GetFailReason() string {
	if m != nil && m.FailReason != nil {
		return *m.FailReason
	}
	return ""
}

func (m *CodeInfo) GetCode() string {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return ""
}

type AInfo struct {
	Type                 *int32   `protobuf:"varint,1,req,name=type" json:"type,omitempty" bson:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *AInfo) Reset()         { *m = AInfo{} }
func (m *AInfo) String() string { return proto.CompactTextString(m) }
func (*AInfo) ProtoMessage()    {}
func (*AInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{40}
}
func (m *AInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AInfo.Merge(m, src)
}
func (m *AInfo) XXX_Size() int {
	return m.Size()
}
func (m *AInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AInfo proto.InternalMessageInfo

func (m *AInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type UnGetMoneyInfo struct {
	TargetId             *int64   `protobuf:"varint,1,opt,name=TargetId" json:"TargetId,omitempty" bson:"TargetId,omitempty"`
	IsHave               *bool    `protobuf:"varint,2,opt,name=IsHave" json:"IsHave,omitempty" bson:"IsHave,omitempty"`
	Type                 *int32   `protobuf:"varint,3,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *UnGetMoneyInfo) Reset()         { *m = UnGetMoneyInfo{} }
func (m *UnGetMoneyInfo) String() string { return proto.CompactTextString(m) }
func (*UnGetMoneyInfo) ProtoMessage()    {}
func (*UnGetMoneyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{41}
}
func (m *UnGetMoneyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnGetMoneyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnGetMoneyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnGetMoneyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnGetMoneyInfo.Merge(m, src)
}
func (m *UnGetMoneyInfo) XXX_Size() int {
	return m.Size()
}
func (m *UnGetMoneyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UnGetMoneyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UnGetMoneyInfo proto.InternalMessageInfo

func (m *UnGetMoneyInfo) GetTargetId() int64 {
	if m != nil && m.TargetId != nil {
		return *m.TargetId
	}
	return 0
}

func (m *UnGetMoneyInfo) GetIsHave() bool {
	if m != nil && m.IsHave != nil {
		return *m.IsHave
	}
	return false
}

func (m *UnGetMoneyInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type CollectIndex struct {
	IndexList            []int32  `protobuf:"varint,1,rep,name=IndexList" json:"IndexList,omitempty" bson:"IndexList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *CollectIndex) Reset()         { *m = CollectIndex{} }
func (m *CollectIndex) String() string { return proto.CompactTextString(m) }
func (*CollectIndex) ProtoMessage()    {}
func (*CollectIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{42}
}
func (m *CollectIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectIndex.Merge(m, src)
}
func (m *CollectIndex) XXX_Size() int {
	return m.Size()
}
func (m *CollectIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectIndex.DiscardUnknown(m)
}

var xxx_messageInfo_CollectIndex proto.InternalMessageInfo

func (m *CollectIndex) GetIndexList() []int32 {
	if m != nil {
		return m.IndexList
	}
	return nil
}

type BankPaySMS struct {
	OrderNo              *string  `protobuf:"bytes,1,opt,name=OrderNo" json:"OrderNo,omitempty" bson:"OrderNo,omitempty"`
	SMS                  *string  `protobuf:"bytes,2,opt,name=SMS" json:"SMS,omitempty" bson:"SMS,omitempty"`
	PayId                *int32   `protobuf:"varint,3,opt,name=PayId" json:"PayId,omitempty" bson:"PayId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *BankPaySMS) Reset()         { *m = BankPaySMS{} }
func (m *BankPaySMS) String() string { return proto.CompactTextString(m) }
func (*BankPaySMS) ProtoMessage()    {}
func (*BankPaySMS) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{43}
}
func (m *BankPaySMS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BankPaySMS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BankPaySMS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BankPaySMS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BankPaySMS.Merge(m, src)
}
func (m *BankPaySMS) XXX_Size() int {
	return m.Size()
}
func (m *BankPaySMS) XXX_DiscardUnknown() {
	xxx_messageInfo_BankPaySMS.DiscardUnknown(m)
}

var xxx_messageInfo_BankPaySMS proto.InternalMessageInfo

func (m *BankPaySMS) GetOrderNo() string {
	if m != nil && m.OrderNo != nil {
		return *m.OrderNo
	}
	return ""
}

func (m *BankPaySMS) GetSMS() string {
	if m != nil && m.SMS != nil {
		return *m.SMS
	}
	return ""
}

func (m *BankPaySMS) GetPayId() int32 {
	if m != nil && m.PayId != nil {
		return *m.PayId
	}
	return 0
}

type RecommendMsg struct {
	PlayerIds            []int64  `protobuf:"varint,1,rep,name=PlayerIds" json:"PlayerIds,omitempty" bson:"PlayerIds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *RecommendMsg) Reset()         { *m = RecommendMsg{} }
func (m *RecommendMsg) String() string { return proto.CompactTextString(m) }
func (*RecommendMsg) ProtoMessage()    {}
func (*RecommendMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{44}
}
func (m *RecommendMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecommendMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecommendMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecommendMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecommendMsg.Merge(m, src)
}
func (m *RecommendMsg) XXX_Size() int {
	return m.Size()
}
func (m *RecommendMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_RecommendMsg.DiscardUnknown(m)
}

var xxx_messageInfo_RecommendMsg proto.InternalMessageInfo

func (m *RecommendMsg) GetPlayerIds() []int64 {
	if m != nil {
		return m.PlayerIds
	}
	return nil
}

type RecommendRefreshInfo struct {
	Type                 *int32   `protobuf:"varint,1,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *RecommendRefreshInfo) Reset()         { *m = RecommendRefreshInfo{} }
func (m *RecommendRefreshInfo) String() string { return proto.CompactTextString(m) }
func (*RecommendRefreshInfo) ProtoMessage()    {}
func (*RecommendRefreshInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{45}
}
func (m *RecommendRefreshInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecommendRefreshInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecommendRefreshInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecommendRefreshInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecommendRefreshInfo.Merge(m, src)
}
func (m *RecommendRefreshInfo) XXX_Size() int {
	return m.Size()
}
func (m *RecommendRefreshInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RecommendRefreshInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RecommendRefreshInfo proto.InternalMessageInfo

func (m *RecommendRefreshInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type AddGoldInfo struct {
	Gold *int64  `protobuf:"varint,1,opt,name=Gold" json:"Gold,omitempty" bson:"Gold,omitempty"`
	Name *string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	//	optional int32 Type =3;//
	PlayerId             *int64   `protobuf:"varint,3,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *AddGoldInfo) Reset()         { *m = AddGoldInfo{} }
func (m *AddGoldInfo) String() string { return proto.CompactTextString(m) }
func (*AddGoldInfo) ProtoMessage()    {}
func (*AddGoldInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{46}
}
func (m *AddGoldInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddGoldInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddGoldInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddGoldInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddGoldInfo.Merge(m, src)
}
func (m *AddGoldInfo) XXX_Size() int {
	return m.Size()
}
func (m *AddGoldInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AddGoldInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AddGoldInfo proto.InternalMessageInfo

func (m *AddGoldInfo) GetGold() int64 {
	if m != nil && m.Gold != nil {
		return *m.Gold
	}
	return 0
}

func (m *AddGoldInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AddGoldInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

type WechatInfo struct {
	Code                 *string  `protobuf:"bytes,1,opt,name=Code" json:"Code,omitempty" bson:"Code,omitempty"`
	Type                 *int32   `protobuf:"varint,2,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	PhoneCode            *string  `protobuf:"bytes,3,opt,name=PhoneCode" json:"PhoneCode,omitempty" bson:"PhoneCode,omitempty"`
	ApkCode              *int32   `protobuf:"varint,4,opt,name=ApkCode" json:"ApkCode,omitempty" bson:"ApkCode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *WechatInfo) Reset()         { *m = WechatInfo{} }
func (m *WechatInfo) String() string { return proto.CompactTextString(m) }
func (*WechatInfo) ProtoMessage()    {}
func (*WechatInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{47}
}
func (m *WechatInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WechatInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WechatInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WechatInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WechatInfo.Merge(m, src)
}
func (m *WechatInfo) XXX_Size() int {
	return m.Size()
}
func (m *WechatInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WechatInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WechatInfo proto.InternalMessageInfo

func (m *WechatInfo) GetCode() string {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return ""
}

func (m *WechatInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *WechatInfo) GetPhoneCode() string {
	if m != nil && m.PhoneCode != nil {
		return *m.PhoneCode
	}
	return ""
}

func (m *WechatInfo) GetApkCode() int32 {
	if m != nil && m.ApkCode != nil {
		return *m.ApkCode
	}
	return 0
}

type MarkName struct {
	PlayerId             *int64   `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Name                 *string  `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *MarkName) Reset()         { *m = MarkName{} }
func (m *MarkName) String() string { return proto.CompactTextString(m) }
func (*MarkName) ProtoMessage()    {}
func (*MarkName) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{48}
}
func (m *MarkName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkName.Merge(m, src)
}
func (m *MarkName) XXX_Size() int {
	return m.Size()
}
func (m *MarkName) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkName.DiscardUnknown(m)
}

var xxx_messageInfo_MarkName proto.InternalMessageInfo

func (m *MarkName) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *MarkName) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type ArticleOptRequest struct {
	ArticleId            *int64   `protobuf:"varint,1,opt,name=ArticleId" json:"ArticleId,omitempty" bson:"ArticleId,omitempty"`
	Type                 *int32   `protobuf:"varint,2,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *ArticleOptRequest) Reset()         { *m = ArticleOptRequest{} }
func (m *ArticleOptRequest) String() string { return proto.CompactTextString(m) }
func (*ArticleOptRequest) ProtoMessage()    {}
func (*ArticleOptRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{49}
}
func (m *ArticleOptRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArticleOptRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArticleOptRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArticleOptRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArticleOptRequest.Merge(m, src)
}
func (m *ArticleOptRequest) XXX_Size() int {
	return m.Size()
}
func (m *ArticleOptRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ArticleOptRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ArticleOptRequest proto.InternalMessageInfo

func (m *ArticleOptRequest) GetArticleId() int64 {
	if m != nil && m.ArticleId != nil {
		return *m.ArticleId
	}
	return 0
}

func (m *ArticleOptRequest) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type NoticeOptRequest struct {
	Id                   *int32   `protobuf:"varint,1,opt,name=Id" json:"Id,omitempty" bson:"Id,omitempty"`
	Type                 *int32   `protobuf:"varint,2,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *NoticeOptRequest) Reset()         { *m = NoticeOptRequest{} }
func (m *NoticeOptRequest) String() string { return proto.CompactTextString(m) }
func (*NoticeOptRequest) ProtoMessage()    {}
func (*NoticeOptRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{50}
}
func (m *NoticeOptRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoticeOptRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoticeOptRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoticeOptRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoticeOptRequest.Merge(m, src)
}
func (m *NoticeOptRequest) XXX_Size() int {
	return m.Size()
}
func (m *NoticeOptRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NoticeOptRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NoticeOptRequest proto.InternalMessageInfo

func (m *NoticeOptRequest) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *NoticeOptRequest) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type MainInfo struct {
	Type                 *int32   `protobuf:"varint,1,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	PlayerId             *int64   `protobuf:"varint,2,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Page                 *int32   `protobuf:"varint,3,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	Count                *int32   `protobuf:"varint,4,opt,name=Count" json:"Count,omitempty" bson:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *MainInfo) Reset()         { *m = MainInfo{} }
func (m *MainInfo) String() string { return proto.CompactTextString(m) }
func (*MainInfo) ProtoMessage()    {}
func (*MainInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{51}
}
func (m *MainInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MainInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MainInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MainInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MainInfo.Merge(m, src)
}
func (m *MainInfo) XXX_Size() int {
	return m.Size()
}
func (m *MainInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MainInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MainInfo proto.InternalMessageInfo

func (m *MainInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *MainInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *MainInfo) GetPage() int32 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *MainInfo) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

type FansInfo struct {
	PlayerId             *int64   `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Sex                  *int32   `protobuf:"varint,2,opt,name=Sex" json:"Sex,omitempty" bson:"Sex,omitempty"`
	Signature            *string  `protobuf:"bytes,3,opt,name=Signature" json:"Signature,omitempty" bson:"Signature,omitempty"`
	Name                 *string  `protobuf:"bytes,4,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	HeadIcon             *string  `protobuf:"bytes,5,opt,name=HeadIcon" json:"HeadIcon,omitempty" bson:"HeadIcon,omitempty"`
	Types                *int32   `protobuf:"varint,6,opt,name=Types" json:"Types,omitempty" bson:"Types,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *FansInfo) Reset()         { *m = FansInfo{} }
func (m *FansInfo) String() string { return proto.CompactTextString(m) }
func (*FansInfo) ProtoMessage()    {}
func (*FansInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{52}
}
func (m *FansInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FansInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FansInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FansInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FansInfo.Merge(m, src)
}
func (m *FansInfo) XXX_Size() int {
	return m.Size()
}
func (m *FansInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FansInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FansInfo proto.InternalMessageInfo

func (m *FansInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *FansInfo) GetSex() int32 {
	if m != nil && m.Sex != nil {
		return *m.Sex
	}
	return 0
}

func (m *FansInfo) GetSignature() string {
	if m != nil && m.Signature != nil {
		return *m.Signature
	}
	return ""
}

func (m *FansInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *FansInfo) GetHeadIcon() string {
	if m != nil && m.HeadIcon != nil {
		return *m.HeadIcon
	}
	return ""
}

func (m *FansInfo) GetTypes() int32 {
	if m != nil && m.Types != nil {
		return *m.Types
	}
	return 0
}

type AllFansInfo struct {
	FansInfo             []*FansInfo `protobuf:"bytes,1,rep,name=FansInfo" json:"FansInfo,omitempty" bson:"FansInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-" bson:"-"`
	XXX_unrecognized     []byte      `json:"-" bson:"-"`
	XXX_sizecache        int32       `json:"-" bson:"-"`
}

func (m *AllFansInfo) Reset()         { *m = AllFansInfo{} }
func (m *AllFansInfo) String() string { return proto.CompactTextString(m) }
func (*AllFansInfo) ProtoMessage()    {}
func (*AllFansInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{53}
}
func (m *AllFansInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllFansInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllFansInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllFansInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllFansInfo.Merge(m, src)
}
func (m *AllFansInfo) XXX_Size() int {
	return m.Size()
}
func (m *AllFansInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AllFansInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AllFansInfo proto.InternalMessageInfo

func (m *AllFansInfo) GetFansInfo() []*FansInfo {
	if m != nil {
		return m.FansInfo
	}
	return nil
}

type DynamicIdInfo struct {
	PlayerId             *int64   `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	LogId                *int64   `protobuf:"varint,2,opt,name=LogId" json:"LogId,omitempty" bson:"LogId,omitempty"`
	Type                 *int32   `protobuf:"varint,3,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *DynamicIdInfo) Reset()         { *m = DynamicIdInfo{} }
func (m *DynamicIdInfo) String() string { return proto.CompactTextString(m) }
func (*DynamicIdInfo) ProtoMessage()    {}
func (*DynamicIdInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{54}
}
func (m *DynamicIdInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicIdInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicIdInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicIdInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicIdInfo.Merge(m, src)
}
func (m *DynamicIdInfo) XXX_Size() int {
	return m.Size()
}
func (m *DynamicIdInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicIdInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicIdInfo proto.InternalMessageInfo

func (m *DynamicIdInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *DynamicIdInfo) GetLogId() int64 {
	if m != nil && m.LogId != nil {
		return *m.LogId
	}
	return 0
}

func (m *DynamicIdInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type DynamicInfo struct {
	DynamicData          []*share_message.DynamicData `protobuf:"bytes,1,rep,name=DynamicData" json:"DynamicData,omitempty" bson:"DynamicData,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-" bson:"-"`
	XXX_unrecognized     []byte                       `json:"-" bson:"-"`
	XXX_sizecache        int32                        `json:"-" bson:"-"`
}

func (m *DynamicInfo) Reset()         { *m = DynamicInfo{} }
func (m *DynamicInfo) String() string { return proto.CompactTextString(m) }
func (*DynamicInfo) ProtoMessage()    {}
func (*DynamicInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{55}
}
func (m *DynamicInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicInfo.Merge(m, src)
}
func (m *DynamicInfo) XXX_Size() int {
	return m.Size()
}
func (m *DynamicInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicInfo proto.InternalMessageInfo

func (m *DynamicInfo) GetDynamicData() []*share_message.DynamicData {
	if m != nil {
		return m.DynamicData
	}
	return nil
}

type TeamMembers struct {
	TeamId               *int64                            `protobuf:"varint,1,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	Members              []*share_message.PersonalTeamData `protobuf:"bytes,2,rep,name=members" json:"members,omitempty" bson:"members,omitempty"`
	Way                  *int32                            `protobuf:"varint,3,opt,name=Way" json:"Way,omitempty" bson:"Way,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-" bson:"-"`
	XXX_unrecognized     []byte                            `json:"-" bson:"-"`
	XXX_sizecache        int32                             `json:"-" bson:"-"`
}

func (m *TeamMembers) Reset()         { *m = TeamMembers{} }
func (m *TeamMembers) String() string { return proto.CompactTextString(m) }
func (*TeamMembers) ProtoMessage()    {}
func (*TeamMembers) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{56}
}
func (m *TeamMembers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TeamMembers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TeamMembers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TeamMembers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TeamMembers.Merge(m, src)
}
func (m *TeamMembers) XXX_Size() int {
	return m.Size()
}
func (m *TeamMembers) XXX_DiscardUnknown() {
	xxx_messageInfo_TeamMembers.DiscardUnknown(m)
}

var xxx_messageInfo_TeamMembers proto.InternalMessageInfo

func (m *TeamMembers) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *TeamMembers) GetMembers() []*share_message.PersonalTeamData {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *TeamMembers) GetWay() int32 {
	if m != nil && m.Way != nil {
		return *m.Way
	}
	return 0
}

type CheckDirtyWord struct {
	Words                []string `protobuf:"bytes,1,rep,name=Words" json:"Words,omitempty" bson:"Words,omitempty"`
	DirtyWords           []string `protobuf:"bytes,2,rep,name=DirtyWords" json:"DirtyWords,omitempty" bson:"DirtyWords,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *CheckDirtyWord) Reset()         { *m = CheckDirtyWord{} }
func (m *CheckDirtyWord) String() string { return proto.CompactTextString(m) }
func (*CheckDirtyWord) ProtoMessage()    {}
func (*CheckDirtyWord) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{57}
}
func (m *CheckDirtyWord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckDirtyWord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckDirtyWord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckDirtyWord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckDirtyWord.Merge(m, src)
}
func (m *CheckDirtyWord) XXX_Size() int {
	return m.Size()
}
func (m *CheckDirtyWord) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckDirtyWord.DiscardUnknown(m)
}

var xxx_messageInfo_CheckDirtyWord proto.InternalMessageInfo

func (m *CheckDirtyWord) GetWords() []string {
	if m != nil {
		return m.Words
	}
	return nil
}

func (m *CheckDirtyWord) GetDirtyWords() []string {
	if m != nil {
		return m.DirtyWords
	}
	return nil
}

type CheckCancelAccount struct {
	ThirtyDays           *bool    `protobuf:"varint,1,opt,name=ThirtyDays" json:"ThirtyDays,omitempty" bson:"ThirtyDays,omitempty"`
	PhoneState           *bool    `protobuf:"varint,2,opt,name=PhoneState" json:"PhoneState,omitempty" bson:"PhoneState,omitempty"`
	PeopleIdState        *bool    `protobuf:"varint,3,opt,name=PeopleIdState" json:"PeopleIdState,omitempty" bson:"PeopleIdState,omitempty"`
	AccountState         *bool    `protobuf:"varint,4,opt,name=AccountState" json:"AccountState,omitempty" bson:"AccountState,omitempty"`
	TradeState           *bool    `protobuf:"varint,5,opt,name=TradeState" json:"TradeState,omitempty" bson:"TradeState,omitempty"`
	BalanceState         *bool    `protobuf:"varint,6,opt,name=BalanceState" json:"BalanceState,omitempty" bson:"BalanceState,omitempty"`
	FriendState          *bool    `protobuf:"varint,7,opt,name=FriendState" json:"FriendState,omitempty" bson:"FriendState,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *CheckCancelAccount) Reset()         { *m = CheckCancelAccount{} }
func (m *CheckCancelAccount) String() string { return proto.CompactTextString(m) }
func (*CheckCancelAccount) ProtoMessage()    {}
func (*CheckCancelAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{58}
}
func (m *CheckCancelAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckCancelAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckCancelAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckCancelAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckCancelAccount.Merge(m, src)
}
func (m *CheckCancelAccount) XXX_Size() int {
	return m.Size()
}
func (m *CheckCancelAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckCancelAccount.DiscardUnknown(m)
}

var xxx_messageInfo_CheckCancelAccount proto.InternalMessageInfo

func (m *CheckCancelAccount) GetThirtyDays() bool {
	if m != nil && m.ThirtyDays != nil {
		return *m.ThirtyDays
	}
	return false
}

func (m *CheckCancelAccount) GetPhoneState() bool {
	if m != nil && m.PhoneState != nil {
		return *m.PhoneState
	}
	return false
}

func (m *CheckCancelAccount) GetPeopleIdState() bool {
	if m != nil && m.PeopleIdState != nil {
		return *m.PeopleIdState
	}
	return false
}

func (m *CheckCancelAccount) GetAccountState() bool {
	if m != nil && m.AccountState != nil {
		return *m.AccountState
	}
	return false
}

func (m *CheckCancelAccount) GetTradeState() bool {
	if m != nil && m.TradeState != nil {
		return *m.TradeState
	}
	return false
}

func (m *CheckCancelAccount) GetBalanceState() bool {
	if m != nil && m.BalanceState != nil {
		return *m.BalanceState
	}
	return false
}

func (m *CheckCancelAccount) GetFriendState() bool {
	if m != nil && m.FriendState != nil {
		return *m.FriendState
	}
	return false
}

type CancelAccountData struct {
	RealName             *string  `protobuf:"bytes,1,opt,name=RealName" json:"RealName,omitempty" bson:"RealName,omitempty"`
	PeopleId             *string  `protobuf:"bytes,2,opt,name=PeopleId" json:"PeopleId,omitempty" bson:"PeopleId,omitempty"`
	PeopleIdBeforeUrl    *string  `protobuf:"bytes,3,opt,name=PeopleIdBeforeUrl" json:"PeopleIdBeforeUrl,omitempty" bson:"PeopleIdBeforeUrl,omitempty"`
	PeopleIdBackUrl      *string  `protobuf:"bytes,4,opt,name=PeopleIdBackUrl" json:"PeopleIdBackUrl,omitempty" bson:"PeopleIdBackUrl,omitempty"`
	PeopleIdHandUrl      *string  `protobuf:"bytes,5,opt,name=PeopleIdHandUrl" json:"PeopleIdHandUrl,omitempty" bson:"PeopleIdHandUrl,omitempty"`
	PhoneCode            *string  `protobuf:"bytes,6,opt,name=PhoneCode" json:"PhoneCode,omitempty" bson:"PhoneCode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *CancelAccountData) Reset()         { *m = CancelAccountData{} }
func (m *CancelAccountData) String() string { return proto.CompactTextString(m) }
func (*CancelAccountData) ProtoMessage()    {}
func (*CancelAccountData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{59}
}
func (m *CancelAccountData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelAccountData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelAccountData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelAccountData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelAccountData.Merge(m, src)
}
func (m *CancelAccountData) XXX_Size() int {
	return m.Size()
}
func (m *CancelAccountData) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelAccountData.DiscardUnknown(m)
}

var xxx_messageInfo_CancelAccountData proto.InternalMessageInfo

func (m *CancelAccountData) GetRealName() string {
	if m != nil && m.RealName != nil {
		return *m.RealName
	}
	return ""
}

func (m *CancelAccountData) GetPeopleId() string {
	if m != nil && m.PeopleId != nil {
		return *m.PeopleId
	}
	return ""
}

func (m *CancelAccountData) GetPeopleIdBeforeUrl() string {
	if m != nil && m.PeopleIdBeforeUrl != nil {
		return *m.PeopleIdBeforeUrl
	}
	return ""
}

func (m *CancelAccountData) GetPeopleIdBackUrl() string {
	if m != nil && m.PeopleIdBackUrl != nil {
		return *m.PeopleIdBackUrl
	}
	return ""
}

func (m *CancelAccountData) GetPeopleIdHandUrl() string {
	if m != nil && m.PeopleIdHandUrl != nil {
		return *m.PeopleIdHandUrl
	}
	return ""
}

func (m *CancelAccountData) GetPhoneCode() string {
	if m != nil && m.PhoneCode != nil {
		return *m.PhoneCode
	}
	return ""
}

type OpenMyMainPageByPageReq struct {
	Page                 *int32   `protobuf:"varint,1,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	PageSize             *int32   `protobuf:"varint,2,opt,name=PageSize" json:"PageSize,omitempty" bson:"PageSize,omitempty"`
	PlayerId             *int64   `protobuf:"varint,3,req,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *OpenMyMainPageByPageReq) Reset()         { *m = OpenMyMainPageByPageReq{} }
func (m *OpenMyMainPageByPageReq) String() string { return proto.CompactTextString(m) }
func (*OpenMyMainPageByPageReq) ProtoMessage()    {}
func (*OpenMyMainPageByPageReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{60}
}
func (m *OpenMyMainPageByPageReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenMyMainPageByPageReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenMyMainPageByPageReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenMyMainPageByPageReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenMyMainPageByPageReq.Merge(m, src)
}
func (m *OpenMyMainPageByPageReq) XXX_Size() int {
	return m.Size()
}
func (m *OpenMyMainPageByPageReq) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenMyMainPageByPageReq.DiscardUnknown(m)
}

var xxx_messageInfo_OpenMyMainPageByPageReq proto.InternalMessageInfo

func (m *OpenMyMainPageByPageReq) GetPage() int32 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *OpenMyMainPageByPageReq) GetPageSize() int32 {
	if m != nil && m.PageSize != nil {
		return *m.PageSize
	}
	return 0
}

func (m *OpenMyMainPageByPageReq) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

type NewUnReadMessageResp struct {
	UnreadComment        *int32   `protobuf:"varint,1,opt,name=UnreadComment" json:"UnreadComment,omitempty" bson:"UnreadComment,omitempty"`
	UnreadZan            *int32   `protobuf:"varint,2,opt,name=UnreadZan" json:"UnreadZan,omitempty" bson:"UnreadZan,omitempty"`
	UnreadAttention      *int32   `protobuf:"varint,3,opt,name=UnreadAttention" json:"UnreadAttention,omitempty" bson:"UnreadAttention,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *NewUnReadMessageResp) Reset()         { *m = NewUnReadMessageResp{} }
func (m *NewUnReadMessageResp) String() string { return proto.CompactTextString(m) }
func (*NewUnReadMessageResp) ProtoMessage()    {}
func (*NewUnReadMessageResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{61}
}
func (m *NewUnReadMessageResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewUnReadMessageResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewUnReadMessageResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewUnReadMessageResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewUnReadMessageResp.Merge(m, src)
}
func (m *NewUnReadMessageResp) XXX_Size() int {
	return m.Size()
}
func (m *NewUnReadMessageResp) XXX_DiscardUnknown() {
	xxx_messageInfo_NewUnReadMessageResp.DiscardUnknown(m)
}

var xxx_messageInfo_NewUnReadMessageResp proto.InternalMessageInfo

func (m *NewUnReadMessageResp) GetUnreadComment() int32 {
	if m != nil && m.UnreadComment != nil {
		return *m.UnreadComment
	}
	return 0
}

func (m *NewUnReadMessageResp) GetUnreadZan() int32 {
	if m != nil && m.UnreadZan != nil {
		return *m.UnreadZan
	}
	return 0
}

func (m *NewUnReadMessageResp) GetUnreadAttention() int32 {
	if m != nil && m.UnreadAttention != nil {
		return *m.UnreadAttention
	}
	return 0
}

type ComplaintID struct {
	ComplaintId          *int64   `protobuf:"varint,1,req,name=ComplaintId" json:"ComplaintId,omitempty" bson:"ComplaintId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *ComplaintID) Reset()         { *m = ComplaintID{} }
func (m *ComplaintID) String() string { return proto.CompactTextString(m) }
func (*ComplaintID) ProtoMessage()    {}
func (*ComplaintID) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{62}
}
func (m *ComplaintID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplaintID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplaintID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplaintID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplaintID.Merge(m, src)
}
func (m *ComplaintID) XXX_Size() int {
	return m.Size()
}
func (m *ComplaintID) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplaintID.DiscardUnknown(m)
}

var xxx_messageInfo_ComplaintID proto.InternalMessageInfo

func (m *ComplaintID) GetComplaintId() int64 {
	if m != nil && m.ComplaintId != nil {
		return *m.ComplaintId
	}
	return 0
}

type ShopOrderComplaintDetailRsp struct {
	SponsorNickname      *string                 `protobuf:"bytes,1,opt,name=sponsor_nickname" json:"sponsor_nickname,omitempty" bson:"sponsor_nickname,omitempty"`
	SponsorAvatar        *string                 `protobuf:"bytes,2,opt,name=sponsor_avatar" json:"sponsor_avatar,omitempty" bson:"sponsor_avatar,omitempty"`
	ItemFile             *share_message.ItemFile `protobuf:"bytes,3,opt,name=item_file" json:"item_file,omitempty" bson:"item_file,omitempty"`
	ItemName             *string                 `protobuf:"bytes,4,opt,name=item_name" json:"item_name,omitempty" bson:"item_name,omitempty"`
	ItemTitle            *string                 `protobuf:"bytes,5,opt,name=item_title" json:"item_title,omitempty" bson:"item_title,omitempty"`
	OrderCreateTime      *int64                  `protobuf:"varint,6,opt,name=order_create_time" json:"order_create_time,omitempty" bson:"order_create_time,omitempty"`
	OrderId              *int64                  `protobuf:"varint,7,opt,name=order_id" json:"order_id,omitempty" bson:"order_id,omitempty"`
	ComplaintAvatar      *string                 `protobuf:"bytes,8,opt,name=complaint_avatar" json:"complaint_avatar,omitempty" bson:"complaint_avatar,omitempty"`
	ComplaintNickname    *string                 `protobuf:"bytes,9,opt,name=complaint_nickname" json:"complaint_nickname,omitempty" bson:"complaint_nickname,omitempty"`
	ComplaintContent     *string                 `protobuf:"bytes,10,opt,name=complaint_content" json:"complaint_content,omitempty" bson:"complaint_content,omitempty"`
	ComplaintReContent   *string                 `protobuf:"bytes,11,opt,name=complaint_reContent" json:"complaint_reContent,omitempty" bson:"complaint_reContent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-" bson:"-"`
	XXX_unrecognized     []byte                  `json:"-" bson:"-"`
	XXX_sizecache        int32                   `json:"-" bson:"-"`
}

func (m *ShopOrderComplaintDetailRsp) Reset()         { *m = ShopOrderComplaintDetailRsp{} }
func (m *ShopOrderComplaintDetailRsp) String() string { return proto.CompactTextString(m) }
func (*ShopOrderComplaintDetailRsp) ProtoMessage()    {}
func (*ShopOrderComplaintDetailRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{63}
}
func (m *ShopOrderComplaintDetailRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShopOrderComplaintDetailRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShopOrderComplaintDetailRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShopOrderComplaintDetailRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShopOrderComplaintDetailRsp.Merge(m, src)
}
func (m *ShopOrderComplaintDetailRsp) XXX_Size() int {
	return m.Size()
}
func (m *ShopOrderComplaintDetailRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ShopOrderComplaintDetailRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ShopOrderComplaintDetailRsp proto.InternalMessageInfo

func (m *ShopOrderComplaintDetailRsp) GetSponsorNickname() string {
	if m != nil && m.SponsorNickname != nil {
		return *m.SponsorNickname
	}
	return ""
}

func (m *ShopOrderComplaintDetailRsp) GetSponsorAvatar() string {
	if m != nil && m.SponsorAvatar != nil {
		return *m.SponsorAvatar
	}
	return ""
}

func (m *ShopOrderComplaintDetailRsp) GetItemFile() *share_message.ItemFile {
	if m != nil {
		return m.ItemFile
	}
	return nil
}

func (m *ShopOrderComplaintDetailRsp) GetItemName() string {
	if m != nil && m.ItemName != nil {
		return *m.ItemName
	}
	return ""
}

func (m *ShopOrderComplaintDetailRsp) GetItemTitle() string {
	if m != nil && m.ItemTitle != nil {
		return *m.ItemTitle
	}
	return ""
}

func (m *ShopOrderComplaintDetailRsp) GetOrderCreateTime() int64 {
	if m != nil && m.OrderCreateTime != nil {
		return *m.OrderCreateTime
	}
	return 0
}

func (m *ShopOrderComplaintDetailRsp) GetOrderId() int64 {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return 0
}

func (m *ShopOrderComplaintDetailRsp) GetComplaintAvatar() string {
	if m != nil && m.ComplaintAvatar != nil {
		return *m.ComplaintAvatar
	}
	return ""
}

func (m *ShopOrderComplaintDetailRsp) GetComplaintNickname() string {
	if m != nil && m.ComplaintNickname != nil {
		return *m.ComplaintNickname
	}
	return ""
}

func (m *ShopOrderComplaintDetailRsp) GetComplaintContent() string {
	if m != nil && m.ComplaintContent != nil {
		return *m.ComplaintContent
	}
	return ""
}

func (m *ShopOrderComplaintDetailRsp) GetComplaintReContent() string {
	if m != nil && m.ComplaintReContent != nil {
		return *m.ComplaintReContent
	}
	return ""
}

type AdvSettingRequest struct {
	Location             *int32   `protobuf:"varint,1,opt,name=Location" json:"Location,omitempty" bson:"Location,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *AdvSettingRequest) Reset()         { *m = AdvSettingRequest{} }
func (m *AdvSettingRequest) String() string { return proto.CompactTextString(m) }
func (*AdvSettingRequest) ProtoMessage()    {}
func (*AdvSettingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{64}
}
func (m *AdvSettingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvSettingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdvSettingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdvSettingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvSettingRequest.Merge(m, src)
}
func (m *AdvSettingRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdvSettingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvSettingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdvSettingRequest proto.InternalMessageInfo

func (m *AdvSettingRequest) GetLocation() int32 {
	if m != nil && m.Location != nil {
		return *m.Location
	}
	return 0
}

type AdvSettingResponse struct {
	List                 []*share_message.AdvSetting `protobuf:"bytes,1,rep,name=List" json:"List,omitempty" bson:"List,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-" bson:"-"`
	XXX_unrecognized     []byte                      `json:"-" bson:"-"`
	XXX_sizecache        int32                       `json:"-" bson:"-"`
}

func (m *AdvSettingResponse) Reset()         { *m = AdvSettingResponse{} }
func (m *AdvSettingResponse) String() string { return proto.CompactTextString(m) }
func (*AdvSettingResponse) ProtoMessage()    {}
func (*AdvSettingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{65}
}
func (m *AdvSettingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvSettingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdvSettingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdvSettingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvSettingResponse.Merge(m, src)
}
func (m *AdvSettingResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdvSettingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvSettingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdvSettingResponse proto.InternalMessageInfo

func (m *AdvSettingResponse) GetList() []*share_message.AdvSetting {
	if m != nil {
		return m.List
	}
	return nil
}

type DelNewFriendListReq struct {
	PlayerIds            []int64  `protobuf:"varint,1,rep,name=PlayerIds" json:"PlayerIds,omitempty" bson:"PlayerIds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *DelNewFriendListReq) Reset()         { *m = DelNewFriendListReq{} }
func (m *DelNewFriendListReq) String() string { return proto.CompactTextString(m) }
func (*DelNewFriendListReq) ProtoMessage()    {}
func (*DelNewFriendListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{66}
}
func (m *DelNewFriendListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelNewFriendListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelNewFriendListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelNewFriendListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelNewFriendListReq.Merge(m, src)
}
func (m *DelNewFriendListReq) XXX_Size() int {
	return m.Size()
}
func (m *DelNewFriendListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DelNewFriendListReq.DiscardUnknown(m)
}

var xxx_messageInfo_DelNewFriendListReq proto.InternalMessageInfo

func (m *DelNewFriendListReq) GetPlayerIds() []int64 {
	if m != nil {
		return m.PlayerIds
	}
	return nil
}

// 群设置后下行给前端刷新数据.
type TeamSettingNotify struct {
	TeamId               *int64                        `protobuf:"varint,1,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	WelcomeWord          *string                       `protobuf:"bytes,2,opt,name=WelcomeWord" json:"WelcomeWord,omitempty" bson:"WelcomeWord,omitempty"`
	MessageSetting       *share_message.MessageSetting `protobuf:"bytes,3,opt,name=MessageSetting" json:"MessageSetting,omitempty" bson:"MessageSetting,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-" bson:"-"`
	XXX_unrecognized     []byte                        `json:"-" bson:"-"`
	XXX_sizecache        int32                         `json:"-" bson:"-"`
}

func (m *TeamSettingNotify) Reset()         { *m = TeamSettingNotify{} }
func (m *TeamSettingNotify) String() string { return proto.CompactTextString(m) }
func (*TeamSettingNotify) ProtoMessage()    {}
func (*TeamSettingNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{67}
}
func (m *TeamSettingNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TeamSettingNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TeamSettingNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TeamSettingNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TeamSettingNotify.Merge(m, src)
}
func (m *TeamSettingNotify) XXX_Size() int {
	return m.Size()
}
func (m *TeamSettingNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_TeamSettingNotify.DiscardUnknown(m)
}

var xxx_messageInfo_TeamSettingNotify proto.InternalMessageInfo

func (m *TeamSettingNotify) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *TeamSettingNotify) GetWelcomeWord() string {
	if m != nil && m.WelcomeWord != nil {
		return *m.WelcomeWord
	}
	return ""
}

func (m *TeamSettingNotify) GetMessageSetting() *share_message.MessageSetting {
	if m != nil {
		return m.MessageSetting
	}
	return nil
}

type NewTeamSettingReq struct {
	TeamId               *int64   `protobuf:"varint,1,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *NewTeamSettingReq) Reset()         { *m = NewTeamSettingReq{} }
func (m *NewTeamSettingReq) String() string { return proto.CompactTextString(m) }
func (*NewTeamSettingReq) ProtoMessage()    {}
func (*NewTeamSettingReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{68}
}
func (m *NewTeamSettingReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewTeamSettingReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewTeamSettingReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewTeamSettingReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewTeamSettingReq.Merge(m, src)
}
func (m *NewTeamSettingReq) XXX_Size() int {
	return m.Size()
}
func (m *NewTeamSettingReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NewTeamSettingReq.DiscardUnknown(m)
}

var xxx_messageInfo_NewTeamSettingReq proto.InternalMessageInfo

func (m *NewTeamSettingReq) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

// 附近的人新版本
type LocationInfoNewReq struct {
	X                    *float64 `protobuf:"fixed64,1,opt,name=X" json:"X,omitempty" bson:"X,omitempty"`
	Y                    *float64 `protobuf:"fixed64,2,opt,name=Y" json:"Y,omitempty" bson:"Y,omitempty"`
	Sex                  *int32   `protobuf:"varint,3,opt,name=Sex" json:"Sex,omitempty" bson:"Sex,omitempty"`
	Sort                 *int32   `protobuf:"varint,4,opt,name=Sort" json:"Sort,omitempty" bson:"Sort,omitempty"`
	Page                 *int64   `protobuf:"varint,5,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	PageSize             *int64   `protobuf:"varint,6,opt,name=PageSize" json:"PageSize,omitempty" bson:"PageSize,omitempty"`
	IsNewFlush           *bool    `protobuf:"varint,7,opt,name=IsNewFlush" json:"IsNewFlush,omitempty" bson:"IsNewFlush,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *LocationInfoNewReq) Reset()         { *m = LocationInfoNewReq{} }
func (m *LocationInfoNewReq) String() string { return proto.CompactTextString(m) }
func (*LocationInfoNewReq) ProtoMessage()    {}
func (*LocationInfoNewReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{69}
}
func (m *LocationInfoNewReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationInfoNewReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationInfoNewReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationInfoNewReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationInfoNewReq.Merge(m, src)
}
func (m *LocationInfoNewReq) XXX_Size() int {
	return m.Size()
}
func (m *LocationInfoNewReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationInfoNewReq.DiscardUnknown(m)
}

var xxx_messageInfo_LocationInfoNewReq proto.InternalMessageInfo

func (m *LocationInfoNewReq) GetX() float64 {
	if m != nil && m.X != nil {
		return *m.X
	}
	return 0
}

func (m *LocationInfoNewReq) GetY() float64 {
	if m != nil && m.Y != nil {
		return *m.Y
	}
	return 0
}

func (m *LocationInfoNewReq) GetSex() int32 {
	if m != nil && m.Sex != nil {
		return *m.Sex
	}
	return 0
}

func (m *LocationInfoNewReq) GetSort() int32 {
	if m != nil && m.Sort != nil {
		return *m.Sort
	}
	return 0
}

func (m *LocationInfoNewReq) GetPage() int64 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *LocationInfoNewReq) GetPageSize() int64 {
	if m != nil && m.PageSize != nil {
		return *m.PageSize
	}
	return 0
}

func (m *LocationInfoNewReq) GetIsNewFlush() bool {
	if m != nil && m.IsNewFlush != nil {
		return *m.IsNewFlush
	}
	return false
}

type LocationInfoNew struct {
	PlayerId             *int64                       `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	HeadIcon             *string                      `protobuf:"bytes,2,opt,name=HeadIcon" json:"HeadIcon,omitempty" bson:"HeadIcon,omitempty"`
	NickName             *string                      `protobuf:"bytes,3,opt,name=NickName" json:"NickName,omitempty" bson:"NickName,omitempty"`
	Sex                  *int32                       `protobuf:"varint,4,opt,name=Sex" json:"Sex,omitempty" bson:"Sex,omitempty"`
	OnlineStatus         *int32                       `protobuf:"varint,5,opt,name=OnlineStatus" json:"OnlineStatus,omitempty" bson:"OnlineStatus,omitempty"`
	Signature            *string                      `protobuf:"bytes,6,opt,name=Signature" json:"Signature,omitempty" bson:"Signature,omitempty"`
	Distance             *float64                     `protobuf:"fixed64,7,opt,name=Distance" json:"Distance,omitempty" bson:"Distance,omitempty"`
	IsFriend             *bool                        `protobuf:"varint,8,opt,name=IsFriend" json:"IsFriend,omitempty" bson:"IsFriend,omitempty"`
	DynamicList          []*share_message.DynamicData `protobuf:"bytes,9,rep,name=DynamicList" json:"DynamicList,omitempty" bson:"DynamicList,omitempty"`
	DataType             *int32                       `protobuf:"varint,10,opt,name=DataType" json:"DataType,omitempty" bson:"DataType,omitempty"`
	IsRobot              *bool                        `protobuf:"varint,11,opt,name=IsRobot" json:"IsRobot,omitempty" bson:"IsRobot,omitempty"`
	NearSet              *share_message.NearSet       `protobuf:"bytes,12,opt,name=NearSet" json:"NearSet,omitempty" bson:"NearSet,omitempty"`
	Account              *string                      `protobuf:"bytes,13,opt,name=Account" json:"Account,omitempty" bson:"Account,omitempty"`
	Types                *int32                       `protobuf:"varint,14,opt,name=Types" json:"Types,omitempty" bson:"Types,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-" bson:"-"`
	XXX_unrecognized     []byte                       `json:"-" bson:"-"`
	XXX_sizecache        int32                        `json:"-" bson:"-"`
}

func (m *LocationInfoNew) Reset()         { *m = LocationInfoNew{} }
func (m *LocationInfoNew) String() string { return proto.CompactTextString(m) }
func (*LocationInfoNew) ProtoMessage()    {}
func (*LocationInfoNew) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{70}
}
func (m *LocationInfoNew) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationInfoNew) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationInfoNew.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationInfoNew) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationInfoNew.Merge(m, src)
}
func (m *LocationInfoNew) XXX_Size() int {
	return m.Size()
}
func (m *LocationInfoNew) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationInfoNew.DiscardUnknown(m)
}

var xxx_messageInfo_LocationInfoNew proto.InternalMessageInfo

func (m *LocationInfoNew) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *LocationInfoNew) GetHeadIcon() string {
	if m != nil && m.HeadIcon != nil {
		return *m.HeadIcon
	}
	return ""
}

func (m *LocationInfoNew) GetNickName() string {
	if m != nil && m.NickName != nil {
		return *m.NickName
	}
	return ""
}

func (m *LocationInfoNew) GetSex() int32 {
	if m != nil && m.Sex != nil {
		return *m.Sex
	}
	return 0
}

func (m *LocationInfoNew) GetOnlineStatus() int32 {
	if m != nil && m.OnlineStatus != nil {
		return *m.OnlineStatus
	}
	return 0
}

func (m *LocationInfoNew) GetSignature() string {
	if m != nil && m.Signature != nil {
		return *m.Signature
	}
	return ""
}

func (m *LocationInfoNew) GetDistance() float64 {
	if m != nil && m.Distance != nil {
		return *m.Distance
	}
	return 0
}

func (m *LocationInfoNew) GetIsFriend() bool {
	if m != nil && m.IsFriend != nil {
		return *m.IsFriend
	}
	return false
}

func (m *LocationInfoNew) GetDynamicList() []*share_message.DynamicData {
	if m != nil {
		return m.DynamicList
	}
	return nil
}

func (m *LocationInfoNew) GetDataType() int32 {
	if m != nil && m.DataType != nil {
		return *m.DataType
	}
	return 0
}

func (m *LocationInfoNew) GetIsRobot() bool {
	if m != nil && m.IsRobot != nil {
		return *m.IsRobot
	}
	return false
}

func (m *LocationInfoNew) GetNearSet() *share_message.NearSet {
	if m != nil {
		return m.NearSet
	}
	return nil
}

func (m *LocationInfoNew) GetAccount() string {
	if m != nil && m.Account != nil {
		return *m.Account
	}
	return ""
}

func (m *LocationInfoNew) GetTypes() int32 {
	if m != nil && m.Types != nil {
		return *m.Types
	}
	return 0
}

type LocationInfoNewResp struct {
	LocationInfo         []*LocationInfoNew `protobuf:"bytes,1,rep,name=LocationInfo" json:"LocationInfo,omitempty" bson:"LocationInfo,omitempty"`
	Count                *int32             `protobuf:"varint,2,opt,name=Count" json:"Count,omitempty" bson:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-" bson:"-"`
	XXX_unrecognized     []byte             `json:"-" bson:"-"`
	XXX_sizecache        int32              `json:"-" bson:"-"`
}

func (m *LocationInfoNewResp) Reset()         { *m = LocationInfoNewResp{} }
func (m *LocationInfoNewResp) String() string { return proto.CompactTextString(m) }
func (*LocationInfoNewResp) ProtoMessage()    {}
func (*LocationInfoNewResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{71}
}
func (m *LocationInfoNewResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationInfoNewResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationInfoNewResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationInfoNewResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationInfoNewResp.Merge(m, src)
}
func (m *LocationInfoNewResp) XXX_Size() int {
	return m.Size()
}
func (m *LocationInfoNewResp) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationInfoNewResp.DiscardUnknown(m)
}

var xxx_messageInfo_LocationInfoNewResp proto.InternalMessageInfo

func (m *LocationInfoNewResp) GetLocationInfo() []*LocationInfoNew {
	if m != nil {
		return m.LocationInfo
	}
	return nil
}

func (m *LocationInfoNewResp) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

// 附近的人推荐用户列表
type NearRecommendReq struct {
	X                    *float64 `protobuf:"fixed64,1,opt,name=X" json:"X,omitempty" bson:"X,omitempty"`
	Y                    *float64 `protobuf:"fixed64,2,opt,name=Y" json:"Y,omitempty" bson:"Y,omitempty"`
	Page                 *int64   `protobuf:"varint,5,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	PageSize             *int64   `protobuf:"varint,6,opt,name=PageSize" json:"PageSize,omitempty" bson:"PageSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *NearRecommendReq) Reset()         { *m = NearRecommendReq{} }
func (m *NearRecommendReq) String() string { return proto.CompactTextString(m) }
func (*NearRecommendReq) ProtoMessage()    {}
func (*NearRecommendReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{72}
}
func (m *NearRecommendReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NearRecommendReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NearRecommendReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NearRecommendReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NearRecommendReq.Merge(m, src)
}
func (m *NearRecommendReq) XXX_Size() int {
	return m.Size()
}
func (m *NearRecommendReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NearRecommendReq.DiscardUnknown(m)
}

var xxx_messageInfo_NearRecommendReq proto.InternalMessageInfo

func (m *NearRecommendReq) GetX() float64 {
	if m != nil && m.X != nil {
		return *m.X
	}
	return 0
}

func (m *NearRecommendReq) GetY() float64 {
	if m != nil && m.Y != nil {
		return *m.Y
	}
	return 0
}

func (m *NearRecommendReq) GetPage() int64 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *NearRecommendReq) GetPageSize() int64 {
	if m != nil && m.PageSize != nil {
		return *m.PageSize
	}
	return 0
}

type NearRecommendResp struct {
	RecommendList        []*NearRecommend `protobuf:"bytes,1,rep,name=RecommendList" json:"RecommendList,omitempty" bson:"RecommendList,omitempty"`
	Count                *int32           `protobuf:"varint,2,opt,name=Count" json:"Count,omitempty" bson:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-" bson:"-"`
	XXX_unrecognized     []byte           `json:"-" bson:"-"`
	XXX_sizecache        int32            `json:"-" bson:"-"`
}

func (m *NearRecommendResp) Reset()         { *m = NearRecommendResp{} }
func (m *NearRecommendResp) String() string { return proto.CompactTextString(m) }
func (*NearRecommendResp) ProtoMessage()    {}
func (*NearRecommendResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{73}
}
func (m *NearRecommendResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NearRecommendResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NearRecommendResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NearRecommendResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NearRecommendResp.Merge(m, src)
}
func (m *NearRecommendResp) XXX_Size() int {
	return m.Size()
}
func (m *NearRecommendResp) XXX_DiscardUnknown() {
	xxx_messageInfo_NearRecommendResp.DiscardUnknown(m)
}

var xxx_messageInfo_NearRecommendResp proto.InternalMessageInfo

func (m *NearRecommendResp) GetRecommendList() []*NearRecommend {
	if m != nil {
		return m.RecommendList
	}
	return nil
}

func (m *NearRecommendResp) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

// 附近的人推荐
type NearRecommend struct {
	PlayerId             *int64   `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	NickName             *string  `protobuf:"bytes,2,opt,name=NickName" json:"NickName,omitempty" bson:"NickName,omitempty"`
	HeadIcon             *string  `protobuf:"bytes,3,opt,name=HeadIcon" json:"HeadIcon,omitempty" bson:"HeadIcon,omitempty"`
	Sex                  *int32   `protobuf:"varint,4,opt,name=Sex" json:"Sex,omitempty" bson:"Sex,omitempty"`
	Signature            *string  `protobuf:"bytes,5,opt,name=Signature" json:"Signature,omitempty" bson:"Signature,omitempty"`
	OnlineStatus         *int32   `protobuf:"varint,6,opt,name=OnlineStatus" json:"OnlineStatus,omitempty" bson:"OnlineStatus,omitempty"`
	GJId                 *int64   `protobuf:"varint,7,opt,name=GJId" json:"GJId,omitempty" bson:"GJId,omitempty"`
	QPId                 *int64   `protobuf:"varint,8,opt,name=QPId" json:"QPId,omitempty" bson:"QPId,omitempty"`
	MPId                 *int64   `protobuf:"varint,9,opt,name=MPId" json:"MPId,omitempty" bson:"MPId,omitempty"`
	QTXId                *int64   `protobuf:"varint,10,opt,name=QTXId" json:"QTXId,omitempty" bson:"QTXId,omitempty"`
	MZBSId               *int64   `protobuf:"varint,11,opt,name=MZBSId" json:"MZBSId,omitempty" bson:"MZBSId,omitempty"`
	IsFriend             *bool    `protobuf:"varint,12,opt,name=IsFriend" json:"IsFriend,omitempty" bson:"IsFriend,omitempty"`
	Distance             *float64 `protobuf:"fixed64,13,opt,name=Distance" json:"Distance,omitempty" bson:"Distance,omitempty"`
	Types                *int32   `protobuf:"varint,14,opt,name=Types" json:"Types,omitempty" bson:"Types,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *NearRecommend) Reset()         { *m = NearRecommend{} }
func (m *NearRecommend) String() string { return proto.CompactTextString(m) }
func (*NearRecommend) ProtoMessage()    {}
func (*NearRecommend) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{74}
}
func (m *NearRecommend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NearRecommend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NearRecommend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NearRecommend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NearRecommend.Merge(m, src)
}
func (m *NearRecommend) XXX_Size() int {
	return m.Size()
}
func (m *NearRecommend) XXX_DiscardUnknown() {
	xxx_messageInfo_NearRecommend.DiscardUnknown(m)
}

var xxx_messageInfo_NearRecommend proto.InternalMessageInfo

func (m *NearRecommend) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *NearRecommend) GetNickName() string {
	if m != nil && m.NickName != nil {
		return *m.NickName
	}
	return ""
}

func (m *NearRecommend) GetHeadIcon() string {
	if m != nil && m.HeadIcon != nil {
		return *m.HeadIcon
	}
	return ""
}

func (m *NearRecommend) GetSex() int32 {
	if m != nil && m.Sex != nil {
		return *m.Sex
	}
	return 0
}

func (m *NearRecommend) GetSignature() string {
	if m != nil && m.Signature != nil {
		return *m.Signature
	}
	return ""
}

func (m *NearRecommend) GetOnlineStatus() int32 {
	if m != nil && m.OnlineStatus != nil {
		return *m.OnlineStatus
	}
	return 0
}

func (m *NearRecommend) GetGJId() int64 {
	if m != nil && m.GJId != nil {
		return *m.GJId
	}
	return 0
}

func (m *NearRecommend) GetQPId() int64 {
	if m != nil && m.QPId != nil {
		return *m.QPId
	}
	return 0
}

func (m *NearRecommend) GetMPId() int64 {
	if m != nil && m.MPId != nil {
		return *m.MPId
	}
	return 0
}

func (m *NearRecommend) GetQTXId() int64 {
	if m != nil && m.QTXId != nil {
		return *m.QTXId
	}
	return 0
}

func (m *NearRecommend) GetMZBSId() int64 {
	if m != nil && m.MZBSId != nil {
		return *m.MZBSId
	}
	return 0
}

func (m *NearRecommend) GetIsFriend() bool {
	if m != nil && m.IsFriend != nil {
		return *m.IsFriend
	}
	return false
}

func (m *NearRecommend) GetDistance() float64 {
	if m != nil && m.Distance != nil {
		return *m.Distance
	}
	return 0
}

func (m *NearRecommend) GetTypes() int32 {
	if m != nil && m.Types != nil {
		return *m.Types
	}
	return 0
}

// 下行消息请求.
type NotifyNewSayMessageReq struct {
	Id                   *int64   `protobuf:"varint,1,opt,name=Id" json:"Id,omitempty" bson:"Id,omitempty"`
	SendPlayerId         *int64   `protobuf:"varint,2,opt,name=SendPlayerId" json:"SendPlayerId,omitempty" bson:"SendPlayerId,omitempty"`
	Content              *string  `protobuf:"bytes,3,opt,name=Content" json:"Content,omitempty" bson:"Content,omitempty"`
	ClientUnique         *string  `protobuf:"bytes,4,opt,name=ClientUnique" json:"ClientUnique,omitempty" bson:"ClientUnique,omitempty"`
	ContentType          *int32   `protobuf:"varint,5,opt,name=ContentType" json:"ContentType,omitempty" bson:"ContentType,omitempty"`
	PropsId              *int64   `protobuf:"varint,6,opt,name=PropsId" json:"PropsId,omitempty" bson:"PropsId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *NotifyNewSayMessageReq) Reset()         { *m = NotifyNewSayMessageReq{} }
func (m *NotifyNewSayMessageReq) String() string { return proto.CompactTextString(m) }
func (*NotifyNewSayMessageReq) ProtoMessage()    {}
func (*NotifyNewSayMessageReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{75}
}
func (m *NotifyNewSayMessageReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotifyNewSayMessageReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotifyNewSayMessageReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotifyNewSayMessageReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotifyNewSayMessageReq.Merge(m, src)
}
func (m *NotifyNewSayMessageReq) XXX_Size() int {
	return m.Size()
}
func (m *NotifyNewSayMessageReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NotifyNewSayMessageReq.DiscardUnknown(m)
}

var xxx_messageInfo_NotifyNewSayMessageReq proto.InternalMessageInfo

func (m *NotifyNewSayMessageReq) GetId() int64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *NotifyNewSayMessageReq) GetSendPlayerId() int64 {
	if m != nil && m.SendPlayerId != nil {
		return *m.SendPlayerId
	}
	return 0
}

func (m *NotifyNewSayMessageReq) GetContent() string {
	if m != nil && m.Content != nil {
		return *m.Content
	}
	return ""
}

func (m *NotifyNewSayMessageReq) GetClientUnique() string {
	if m != nil && m.ClientUnique != nil {
		return *m.ClientUnique
	}
	return ""
}

func (m *NotifyNewSayMessageReq) GetContentType() int32 {
	if m != nil && m.ContentType != nil {
		return *m.ContentType
	}
	return 0
}

func (m *NotifyNewSayMessageReq) GetPropsId() int64 {
	if m != nil && m.PropsId != nil {
		return *m.PropsId
	}
	return 0
}

// 附近的人给我打招呼会话列表.
type NearSessionListReq struct {
	Page                 *int64   `protobuf:"varint,1,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	PageSize             *int64   `protobuf:"varint,2,opt,name=PageSize" json:"PageSize,omitempty" bson:"PageSize,omitempty"`
	QueryTime            *int64   `protobuf:"varint,3,opt,name=QueryTime" json:"QueryTime,omitempty" bson:"QueryTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *NearSessionListReq) Reset()         { *m = NearSessionListReq{} }
func (m *NearSessionListReq) String() string { return proto.CompactTextString(m) }
func (*NearSessionListReq) ProtoMessage()    {}
func (*NearSessionListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{76}
}
func (m *NearSessionListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NearSessionListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NearSessionListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NearSessionListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NearSessionListReq.Merge(m, src)
}
func (m *NearSessionListReq) XXX_Size() int {
	return m.Size()
}
func (m *NearSessionListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NearSessionListReq.DiscardUnknown(m)
}

var xxx_messageInfo_NearSessionListReq proto.InternalMessageInfo

func (m *NearSessionListReq) GetPage() int64 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *NearSessionListReq) GetPageSize() int64 {
	if m != nil && m.PageSize != nil {
		return *m.PageSize
	}
	return 0
}

func (m *NearSessionListReq) GetQueryTime() int64 {
	if m != nil && m.QueryTime != nil {
		return *m.QueryTime
	}
	return 0
}

type NearSessionListResp struct {
	SessionList          []*NearSessionList `protobuf:"bytes,1,rep,name=SessionList" json:"SessionList,omitempty" bson:"SessionList,omitempty"`
	Count                *int32             `protobuf:"varint,2,opt,name=Count" json:"Count,omitempty" bson:"Count,omitempty"`
	QueryTime            *int64             `protobuf:"varint,3,opt,name=QueryTime" json:"QueryTime,omitempty" bson:"QueryTime,omitempty"`
	MaxId                *int64             `protobuf:"varint,4,opt,name=MaxId" json:"MaxId,omitempty" bson:"MaxId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-" bson:"-"`
	XXX_unrecognized     []byte             `json:"-" bson:"-"`
	XXX_sizecache        int32              `json:"-" bson:"-"`
}

func (m *NearSessionListResp) Reset()         { *m = NearSessionListResp{} }
func (m *NearSessionListResp) String() string { return proto.CompactTextString(m) }
func (*NearSessionListResp) ProtoMessage()    {}
func (*NearSessionListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{77}
}
func (m *NearSessionListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NearSessionListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NearSessionListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NearSessionListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NearSessionListResp.Merge(m, src)
}
func (m *NearSessionListResp) XXX_Size() int {
	return m.Size()
}
func (m *NearSessionListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_NearSessionListResp.DiscardUnknown(m)
}

var xxx_messageInfo_NearSessionListResp proto.InternalMessageInfo

func (m *NearSessionListResp) GetSessionList() []*NearSessionList {
	if m != nil {
		return m.SessionList
	}
	return nil
}

func (m *NearSessionListResp) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *NearSessionListResp) GetQueryTime() int64 {
	if m != nil && m.QueryTime != nil {
		return *m.QueryTime
	}
	return 0
}

func (m *NearSessionListResp) GetMaxId() int64 {
	if m != nil && m.MaxId != nil {
		return *m.MaxId
	}
	return 0
}

type NearSessionList struct {
	Id                   *int64   `protobuf:"varint,1,opt,name=Id" json:"Id,omitempty" bson:"Id,omitempty"`
	SendPlayerId         *int64   `protobuf:"varint,2,opt,name=SendPlayerId" json:"SendPlayerId,omitempty" bson:"SendPlayerId,omitempty"`
	NickName             *string  `protobuf:"bytes,3,opt,name=NickName" json:"NickName,omitempty" bson:"NickName,omitempty"`
	HeadIcon             *string  `protobuf:"bytes,4,opt,name=HeadIcon" json:"HeadIcon,omitempty" bson:"HeadIcon,omitempty"`
	Sex                  *int32   `protobuf:"varint,5,opt,name=Sex" json:"Sex,omitempty" bson:"Sex,omitempty"`
	Content              *string  `protobuf:"bytes,6,opt,name=Content" json:"Content,omitempty" bson:"Content,omitempty"`
	IsRead               *bool    `protobuf:"varint,7,opt,name=IsRead" json:"IsRead,omitempty" bson:"IsRead,omitempty"`
	ContentType          *int32   `protobuf:"varint,8,opt,name=ContentType" json:"ContentType,omitempty" bson:"ContentType,omitempty"`
	Distance             *float64 `protobuf:"fixed64,9,opt,name=Distance" json:"Distance,omitempty" bson:"Distance,omitempty"`
	IsFriend             *bool    `protobuf:"varint,10,opt,name=IsFriend" json:"IsFriend,omitempty" bson:"IsFriend,omitempty"`
	PropsId              *int64   `protobuf:"varint,11,opt,name=PropsId" json:"PropsId,omitempty" bson:"PropsId,omitempty"`
	CreateTime           *int64   `protobuf:"varint,12,opt,name=CreateTime" json:"CreateTime,omitempty" bson:"CreateTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *NearSessionList) Reset()         { *m = NearSessionList{} }
func (m *NearSessionList) String() string { return proto.CompactTextString(m) }
func (*NearSessionList) ProtoMessage()    {}
func (*NearSessionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{78}
}
func (m *NearSessionList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NearSessionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NearSessionList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NearSessionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NearSessionList.Merge(m, src)
}
func (m *NearSessionList) XXX_Size() int {
	return m.Size()
}
func (m *NearSessionList) XXX_DiscardUnknown() {
	xxx_messageInfo_NearSessionList.DiscardUnknown(m)
}

var xxx_messageInfo_NearSessionList proto.InternalMessageInfo

func (m *NearSessionList) GetId() int64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *NearSessionList) GetSendPlayerId() int64 {
	if m != nil && m.SendPlayerId != nil {
		return *m.SendPlayerId
	}
	return 0
}

func (m *NearSessionList) GetNickName() string {
	if m != nil && m.NickName != nil {
		return *m.NickName
	}
	return ""
}

func (m *NearSessionList) GetHeadIcon() string {
	if m != nil && m.HeadIcon != nil {
		return *m.HeadIcon
	}
	return ""
}

func (m *NearSessionList) GetSex() int32 {
	if m != nil && m.Sex != nil {
		return *m.Sex
	}
	return 0
}

func (m *NearSessionList) GetContent() string {
	if m != nil && m.Content != nil {
		return *m.Content
	}
	return ""
}

func (m *NearSessionList) GetIsRead() bool {
	if m != nil && m.IsRead != nil {
		return *m.IsRead
	}
	return false
}

func (m *NearSessionList) GetContentType() int32 {
	if m != nil && m.ContentType != nil {
		return *m.ContentType
	}
	return 0
}

func (m *NearSessionList) GetDistance() float64 {
	if m != nil && m.Distance != nil {
		return *m.Distance
	}
	return 0
}

func (m *NearSessionList) GetIsFriend() bool {
	if m != nil && m.IsFriend != nil {
		return *m.IsFriend
	}
	return false
}

func (m *NearSessionList) GetPropsId() int64 {
	if m != nil && m.PropsId != nil {
		return *m.PropsId
	}
	return 0
}

func (m *NearSessionList) GetCreateTime() int64 {
	if m != nil && m.CreateTime != nil {
		return *m.CreateTime
	}
	return 0
}

type SendPlayerMessageListReq struct {
	SendPlayerId         *int64   `protobuf:"varint,1,opt,name=SendPlayerId" json:"SendPlayerId,omitempty" bson:"SendPlayerId,omitempty"`
	Page                 *int64   `protobuf:"varint,2,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	PageSize             *int64   `protobuf:"varint,3,opt,name=PageSize" json:"PageSize,omitempty" bson:"PageSize,omitempty"`
	MaxId                *int64   `protobuf:"varint,4,opt,name=MaxId" json:"MaxId,omitempty" bson:"MaxId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *SendPlayerMessageListReq) Reset()         { *m = SendPlayerMessageListReq{} }
func (m *SendPlayerMessageListReq) String() string { return proto.CompactTextString(m) }
func (*SendPlayerMessageListReq) ProtoMessage()    {}
func (*SendPlayerMessageListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{79}
}
func (m *SendPlayerMessageListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendPlayerMessageListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendPlayerMessageListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendPlayerMessageListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendPlayerMessageListReq.Merge(m, src)
}
func (m *SendPlayerMessageListReq) XXX_Size() int {
	return m.Size()
}
func (m *SendPlayerMessageListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SendPlayerMessageListReq.DiscardUnknown(m)
}

var xxx_messageInfo_SendPlayerMessageListReq proto.InternalMessageInfo

func (m *SendPlayerMessageListReq) GetSendPlayerId() int64 {
	if m != nil && m.SendPlayerId != nil {
		return *m.SendPlayerId
	}
	return 0
}

func (m *SendPlayerMessageListReq) GetPage() int64 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *SendPlayerMessageListReq) GetPageSize() int64 {
	if m != nil && m.PageSize != nil {
		return *m.PageSize
	}
	return 0
}

func (m *SendPlayerMessageListReq) GetMaxId() int64 {
	if m != nil && m.MaxId != nil {
		return *m.MaxId
	}
	return 0
}

// 附近的人聊天列表
type GetNearChatListReq struct {
	ReceivePlayerId      *int64   `protobuf:"varint,1,opt,name=ReceivePlayerId" json:"ReceivePlayerId,omitempty" bson:"ReceivePlayerId,omitempty"`
	Page                 *int64   `protobuf:"varint,2,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	PageSize             *int64   `protobuf:"varint,3,opt,name=PageSize" json:"PageSize,omitempty" bson:"PageSize,omitempty"`
	MaxId                *int64   `protobuf:"varint,4,opt,name=MaxId" json:"MaxId,omitempty" bson:"MaxId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *GetNearChatListReq) Reset()         { *m = GetNearChatListReq{} }
func (m *GetNearChatListReq) String() string { return proto.CompactTextString(m) }
func (*GetNearChatListReq) ProtoMessage()    {}
func (*GetNearChatListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{80}
}
func (m *GetNearChatListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetNearChatListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetNearChatListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetNearChatListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNearChatListReq.Merge(m, src)
}
func (m *GetNearChatListReq) XXX_Size() int {
	return m.Size()
}
func (m *GetNearChatListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNearChatListReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetNearChatListReq proto.InternalMessageInfo

func (m *GetNearChatListReq) GetReceivePlayerId() int64 {
	if m != nil && m.ReceivePlayerId != nil {
		return *m.ReceivePlayerId
	}
	return 0
}

func (m *GetNearChatListReq) GetPage() int64 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *GetNearChatListReq) GetPageSize() int64 {
	if m != nil && m.PageSize != nil {
		return *m.PageSize
	}
	return 0
}

func (m *GetNearChatListReq) GetMaxId() int64 {
	if m != nil && m.MaxId != nil {
		return *m.MaxId
	}
	return 0
}

// 删除附近的人打招呼信息
type DelNearMessageReq struct {
	SendPlayerId         []int64  `protobuf:"varint,1,rep,name=SendPlayerId" json:"SendPlayerId,omitempty" bson:"SendPlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *DelNearMessageReq) Reset()         { *m = DelNearMessageReq{} }
func (m *DelNearMessageReq) String() string { return proto.CompactTextString(m) }
func (*DelNearMessageReq) ProtoMessage()    {}
func (*DelNearMessageReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{81}
}
func (m *DelNearMessageReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelNearMessageReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelNearMessageReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelNearMessageReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelNearMessageReq.Merge(m, src)
}
func (m *DelNearMessageReq) XXX_Size() int {
	return m.Size()
}
func (m *DelNearMessageReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DelNearMessageReq.DiscardUnknown(m)
}

var xxx_messageInfo_DelNearMessageReq proto.InternalMessageInfo

func (m *DelNearMessageReq) GetSendPlayerId() []int64 {
	if m != nil {
		return m.SendPlayerId
	}
	return nil
}

// 修改消息已读.
type UpdateIsReadReq struct {
	Id                   *int64   `protobuf:"varint,1,opt,name=Id" json:"Id,omitempty" bson:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *UpdateIsReadReq) Reset()         { *m = UpdateIsReadReq{} }
func (m *UpdateIsReadReq) String() string { return proto.CompactTextString(m) }
func (*UpdateIsReadReq) ProtoMessage()    {}
func (*UpdateIsReadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{82}
}
func (m *UpdateIsReadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateIsReadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateIsReadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateIsReadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateIsReadReq.Merge(m, src)
}
func (m *UpdateIsReadReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateIsReadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateIsReadReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateIsReadReq proto.InternalMessageInfo

func (m *UpdateIsReadReq) GetId() int64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

type HasUnReadNearResp struct {
	HasUnReadNear        *bool    `protobuf:"varint,1,opt,name=HasUnReadNear" json:"HasUnReadNear,omitempty" bson:"HasUnReadNear,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *HasUnReadNearResp) Reset()         { *m = HasUnReadNearResp{} }
func (m *HasUnReadNearResp) String() string { return proto.CompactTextString(m) }
func (*HasUnReadNearResp) ProtoMessage()    {}
func (*HasUnReadNearResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{83}
}
func (m *HasUnReadNearResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HasUnReadNearResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HasUnReadNearResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HasUnReadNearResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HasUnReadNearResp.Merge(m, src)
}
func (m *HasUnReadNearResp) XXX_Size() int {
	return m.Size()
}
func (m *HasUnReadNearResp) XXX_DiscardUnknown() {
	xxx_messageInfo_HasUnReadNearResp.DiscardUnknown(m)
}

var xxx_messageInfo_HasUnReadNearResp proto.InternalMessageInfo

func (m *HasUnReadNearResp) GetHasUnReadNear() bool {
	if m != nil && m.HasUnReadNear != nil {
		return *m.HasUnReadNear
	}
	return false
}

type YoungPassWord struct {
	Opt                  *int32   `protobuf:"varint,1,opt,name=Opt" json:"Opt,omitempty" bson:"Opt,omitempty"`
	PassWord             *string  `protobuf:"bytes,2,opt,name=PassWord" json:"PassWord,omitempty" bson:"PassWord,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *YoungPassWord) Reset()         { *m = YoungPassWord{} }
func (m *YoungPassWord) String() string { return proto.CompactTextString(m) }
func (*YoungPassWord) ProtoMessage()    {}
func (*YoungPassWord) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{84}
}
func (m *YoungPassWord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *YoungPassWord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_YoungPassWord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *YoungPassWord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_YoungPassWord.Merge(m, src)
}
func (m *YoungPassWord) XXX_Size() int {
	return m.Size()
}
func (m *YoungPassWord) XXX_DiscardUnknown() {
	xxx_messageInfo_YoungPassWord.DiscardUnknown(m)
}

var xxx_messageInfo_YoungPassWord proto.InternalMessageInfo

func (m *YoungPassWord) GetOpt() int32 {
	if m != nil && m.Opt != nil {
		return *m.Opt
	}
	return 0
}

func (m *YoungPassWord) GetPassWord() string {
	if m != nil && m.PassWord != nil {
		return *m.PassWord
	}
	return ""
}

type FriendNum struct {
	Num                  *int32   `protobuf:"varint,1,opt,name=Num" json:"Num,omitempty" bson:"Num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *FriendNum) Reset()         { *m = FriendNum{} }
func (m *FriendNum) String() string { return proto.CompactTextString(m) }
func (*FriendNum) ProtoMessage()    {}
func (*FriendNum) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{85}
}
func (m *FriendNum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FriendNum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FriendNum.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FriendNum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FriendNum.Merge(m, src)
}
func (m *FriendNum) XXX_Size() int {
	return m.Size()
}
func (m *FriendNum) XXX_DiscardUnknown() {
	xxx_messageInfo_FriendNum.DiscardUnknown(m)
}

var xxx_messageInfo_FriendNum proto.InternalMessageInfo

func (m *FriendNum) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

type TeamChangePos struct {
	PlayerId             *int64   `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Position             *int32   `protobuf:"varint,2,opt,name=Position" json:"Position,omitempty" bson:"Position,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *TeamChangePos) Reset()         { *m = TeamChangePos{} }
func (m *TeamChangePos) String() string { return proto.CompactTextString(m) }
func (*TeamChangePos) ProtoMessage()    {}
func (*TeamChangePos) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{86}
}
func (m *TeamChangePos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TeamChangePos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TeamChangePos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TeamChangePos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TeamChangePos.Merge(m, src)
}
func (m *TeamChangePos) XXX_Size() int {
	return m.Size()
}
func (m *TeamChangePos) XXX_DiscardUnknown() {
	xxx_messageInfo_TeamChangePos.DiscardUnknown(m)
}

var xxx_messageInfo_TeamChangePos proto.InternalMessageInfo

func (m *TeamChangePos) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *TeamChangePos) GetPosition() int32 {
	if m != nil && m.Position != nil {
		return *m.Position
	}
	return 0
}

type TeamMembersChange struct {
	TeamId               *int64                            `protobuf:"varint,1,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	DelList              []int64                           `protobuf:"varint,2,rep,name=DelList" json:"DelList,omitempty" bson:"DelList,omitempty"`
	AddList              []*share_message.PersonalTeamData `protobuf:"bytes,3,rep,name=AddList" json:"AddList,omitempty" bson:"AddList,omitempty"`
	Time                 *int64                            `protobuf:"varint,4,opt,name=Time" json:"Time,omitempty" bson:"Time,omitempty"`
	PosChange            []*TeamChangePos                  `protobuf:"bytes,5,rep,name=PosChange" json:"PosChange,omitempty" bson:"PosChange,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-" bson:"-"`
	XXX_unrecognized     []byte                            `json:"-" bson:"-"`
	XXX_sizecache        int32                             `json:"-" bson:"-"`
}

func (m *TeamMembersChange) Reset()         { *m = TeamMembersChange{} }
func (m *TeamMembersChange) String() string { return proto.CompactTextString(m) }
func (*TeamMembersChange) ProtoMessage()    {}
func (*TeamMembersChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{87}
}
func (m *TeamMembersChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TeamMembersChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TeamMembersChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TeamMembersChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TeamMembersChange.Merge(m, src)
}
func (m *TeamMembersChange) XXX_Size() int {
	return m.Size()
}
func (m *TeamMembersChange) XXX_DiscardUnknown() {
	xxx_messageInfo_TeamMembersChange.DiscardUnknown(m)
}

var xxx_messageInfo_TeamMembersChange proto.InternalMessageInfo

func (m *TeamMembersChange) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *TeamMembersChange) GetDelList() []int64 {
	if m != nil {
		return m.DelList
	}
	return nil
}

func (m *TeamMembersChange) GetAddList() []*share_message.PersonalTeamData {
	if m != nil {
		return m.AddList
	}
	return nil
}

func (m *TeamMembersChange) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *TeamMembersChange) GetPosChange() []*TeamChangePos {
	if m != nil {
		return m.PosChange
	}
	return nil
}

type GetNewFriends struct {
	Time                 *int64   `protobuf:"varint,1,opt,name=Time" json:"Time,omitempty" bson:"Time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *GetNewFriends) Reset()         { *m = GetNewFriends{} }
func (m *GetNewFriends) String() string { return proto.CompactTextString(m) }
func (*GetNewFriends) ProtoMessage()    {}
func (*GetNewFriends) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{88}
}
func (m *GetNewFriends) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetNewFriends) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetNewFriends.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetNewFriends) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNewFriends.Merge(m, src)
}
func (m *GetNewFriends) XXX_Size() int {
	return m.Size()
}
func (m *GetNewFriends) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNewFriends.DiscardUnknown(m)
}

var xxx_messageInfo_GetNewFriends proto.InternalMessageInfo

func (m *GetNewFriends) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

type BankData struct {
	Code                 *string  `protobuf:"bytes,1,opt,name=Code" json:"Code,omitempty" bson:"Code,omitempty"`
	Name                 *string  `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *BankData) Reset()         { *m = BankData{} }
func (m *BankData) String() string { return proto.CompactTextString(m) }
func (*BankData) ProtoMessage()    {}
func (*BankData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{89}
}
func (m *BankData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BankData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BankData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BankData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BankData.Merge(m, src)
}
func (m *BankData) XXX_Size() int {
	return m.Size()
}
func (m *BankData) XXX_DiscardUnknown() {
	xxx_messageInfo_BankData.DiscardUnknown(m)
}

var xxx_messageInfo_BankData proto.InternalMessageInfo

func (m *BankData) GetCode() string {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return ""
}

func (m *BankData) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type SupportBankList struct {
	PayId                *int32      `protobuf:"varint,1,opt,name=PayId" json:"PayId,omitempty" bson:"PayId,omitempty"`
	Banks                []*BankData `protobuf:"bytes,2,rep,name=Banks" json:"Banks,omitempty" bson:"Banks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-" bson:"-"`
	XXX_unrecognized     []byte      `json:"-" bson:"-"`
	XXX_sizecache        int32       `json:"-" bson:"-"`
}

func (m *SupportBankList) Reset()         { *m = SupportBankList{} }
func (m *SupportBankList) String() string { return proto.CompactTextString(m) }
func (*SupportBankList) ProtoMessage()    {}
func (*SupportBankList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{90}
}
func (m *SupportBankList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupportBankList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupportBankList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupportBankList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupportBankList.Merge(m, src)
}
func (m *SupportBankList) XXX_Size() int {
	return m.Size()
}
func (m *SupportBankList) XXX_DiscardUnknown() {
	xxx_messageInfo_SupportBankList.DiscardUnknown(m)
}

var xxx_messageInfo_SupportBankList proto.InternalMessageInfo

func (m *SupportBankList) GetPayId() int32 {
	if m != nil && m.PayId != nil {
		return *m.PayId
	}
	return 0
}

func (m *SupportBankList) GetBanks() []*BankData {
	if m != nil {
		return m.Banks
	}
	return nil
}

//埋点结构
type BuryingPoint struct {
	EventType            *int32   `protobuf:"varint,1,opt,name=EventType" json:"EventType,omitempty" bson:"EventType,omitempty"`
	Time                 *int64   `protobuf:"varint,2,opt,name=Time" json:"Time,omitempty" bson:"Time,omitempty"`
	LastTime             *int64   `protobuf:"varint,3,opt,name=LastTime" json:"LastTime,omitempty" bson:"LastTime,omitempty"`
	TargetId             *int64   `protobuf:"varint,4,opt,name=TargetId" json:"TargetId,omitempty" bson:"TargetId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *BuryingPoint) Reset()         { *m = BuryingPoint{} }
func (m *BuryingPoint) String() string { return proto.CompactTextString(m) }
func (*BuryingPoint) ProtoMessage()    {}
func (*BuryingPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{91}
}
func (m *BuryingPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuryingPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuryingPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuryingPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuryingPoint.Merge(m, src)
}
func (m *BuryingPoint) XXX_Size() int {
	return m.Size()
}
func (m *BuryingPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_BuryingPoint.DiscardUnknown(m)
}

var xxx_messageInfo_BuryingPoint proto.InternalMessageInfo

func (m *BuryingPoint) GetEventType() int32 {
	if m != nil && m.EventType != nil {
		return *m.EventType
	}
	return 0
}

func (m *BuryingPoint) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *BuryingPoint) GetLastTime() int64 {
	if m != nil && m.LastTime != nil {
		return *m.LastTime
	}
	return 0
}

func (m *BuryingPoint) GetTargetId() int64 {
	if m != nil && m.TargetId != nil {
		return *m.TargetId
	}
	return 0
}

//埋点数据
type BuryingPointList struct {
	Data                 []*BuryingPoint `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" bson:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-" bson:"-"`
	XXX_unrecognized     []byte          `json:"-" bson:"-"`
	XXX_sizecache        int32           `json:"-" bson:"-"`
}

func (m *BuryingPointList) Reset()         { *m = BuryingPointList{} }
func (m *BuryingPointList) String() string { return proto.CompactTextString(m) }
func (*BuryingPointList) ProtoMessage()    {}
func (*BuryingPointList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{92}
}
func (m *BuryingPointList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuryingPointList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuryingPointList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuryingPointList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuryingPointList.Merge(m, src)
}
func (m *BuryingPointList) XXX_Size() int {
	return m.Size()
}
func (m *BuryingPointList) XXX_DiscardUnknown() {
	xxx_messageInfo_BuryingPointList.DiscardUnknown(m)
}

var xxx_messageInfo_BuryingPointList proto.InternalMessageInfo

func (m *BuryingPointList) GetData() []*BuryingPoint {
	if m != nil {
		return m.Data
	}
	return nil
}

//在线人数
type OnLineNum struct {
	Num                  *int64   `protobuf:"varint,1,opt,name=Num" json:"Num,omitempty" bson:"Num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *OnLineNum) Reset()         { *m = OnLineNum{} }
func (m *OnLineNum) String() string { return proto.CompactTextString(m) }
func (*OnLineNum) ProtoMessage()    {}
func (*OnLineNum) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{93}
}
func (m *OnLineNum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnLineNum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnLineNum.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnLineNum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnLineNum.Merge(m, src)
}
func (m *OnLineNum) XXX_Size() int {
	return m.Size()
}
func (m *OnLineNum) XXX_DiscardUnknown() {
	xxx_messageInfo_OnLineNum.DiscardUnknown(m)
}

var xxx_messageInfo_OnLineNum proto.InternalMessageInfo

func (m *OnLineNum) GetNum() int64 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

//消息页 banner广告列表
type MsgAdv struct {
	Advs                 []*share_message.AdvSetting `protobuf:"bytes,1,rep,name=Advs" json:"Advs,omitempty" bson:"Advs,omitempty"`
	RightList            []*share_message.AdvSetting `protobuf:"bytes,2,rep,name=RightList" json:"RightList,omitempty" bson:"RightList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-" bson:"-"`
	XXX_unrecognized     []byte                      `json:"-" bson:"-"`
	XXX_sizecache        int32                       `json:"-" bson:"-"`
}

func (m *MsgAdv) Reset()         { *m = MsgAdv{} }
func (m *MsgAdv) String() string { return proto.CompactTextString(m) }
func (*MsgAdv) ProtoMessage()    {}
func (*MsgAdv) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{94}
}
func (m *MsgAdv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAdv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAdv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAdv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAdv.Merge(m, src)
}
func (m *MsgAdv) XXX_Size() int {
	return m.Size()
}
func (m *MsgAdv) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAdv.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAdv proto.InternalMessageInfo

func (m *MsgAdv) GetAdvs() []*share_message.AdvSetting {
	if m != nil {
		return m.Advs
	}
	return nil
}

func (m *MsgAdv) GetRightList() []*share_message.AdvSetting {
	if m != nil {
		return m.RightList
	}
	return nil
}

type PlayerDiamond struct {
	PlayerId             *int64   `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Diamond              *int64   `protobuf:"varint,2,opt,name=Diamond" json:"Diamond,omitempty" bson:"Diamond,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *PlayerDiamond) Reset()         { *m = PlayerDiamond{} }
func (m *PlayerDiamond) String() string { return proto.CompactTextString(m) }
func (*PlayerDiamond) ProtoMessage()    {}
func (*PlayerDiamond) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{95}
}
func (m *PlayerDiamond) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerDiamond) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerDiamond.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerDiamond) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerDiamond.Merge(m, src)
}
func (m *PlayerDiamond) XXX_Size() int {
	return m.Size()
}
func (m *PlayerDiamond) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerDiamond.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerDiamond proto.InternalMessageInfo

func (m *PlayerDiamond) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *PlayerDiamond) GetDiamond() int64 {
	if m != nil && m.Diamond != nil {
		return *m.Diamond
	}
	return 0
}

//服务器当前支持的支付渠道
type PayChannels struct {
	Type                 *int32                           `protobuf:"varint,1,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Channels             []*share_message.PlatformChannel `protobuf:"bytes,2,rep,name=Channels" json:"Channels,omitempty" bson:"Channels,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-" bson:"-"`
	XXX_unrecognized     []byte                           `json:"-" bson:"-"`
	XXX_sizecache        int32                            `json:"-" bson:"-"`
}

func (m *PayChannels) Reset()         { *m = PayChannels{} }
func (m *PayChannels) String() string { return proto.CompactTextString(m) }
func (*PayChannels) ProtoMessage()    {}
func (*PayChannels) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{96}
}
func (m *PayChannels) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayChannels) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayChannels.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayChannels) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayChannels.Merge(m, src)
}
func (m *PayChannels) XXX_Size() int {
	return m.Size()
}
func (m *PayChannels) XXX_DiscardUnknown() {
	xxx_messageInfo_PayChannels.DiscardUnknown(m)
}

var xxx_messageInfo_PayChannels proto.InternalMessageInfo

func (m *PayChannels) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *PayChannels) GetChannels() []*share_message.PlatformChannel {
	if m != nil {
		return m.Channels
	}
	return nil
}

type TopicTeamDynamicReq struct {
	TopicTeamId          *int64   `protobuf:"varint,1,opt,name=TopicTeamId" json:"TopicTeamId,omitempty" bson:"TopicTeamId,omitempty"`
	Page                 *int32   `protobuf:"varint,2,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	PageSize             *int32   `protobuf:"varint,3,opt,name=PageSize" json:"PageSize,omitempty" bson:"PageSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *TopicTeamDynamicReq) Reset()         { *m = TopicTeamDynamicReq{} }
func (m *TopicTeamDynamicReq) String() string { return proto.CompactTextString(m) }
func (*TopicTeamDynamicReq) ProtoMessage()    {}
func (*TopicTeamDynamicReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{97}
}
func (m *TopicTeamDynamicReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicTeamDynamicReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicTeamDynamicReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicTeamDynamicReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicTeamDynamicReq.Merge(m, src)
}
func (m *TopicTeamDynamicReq) XXX_Size() int {
	return m.Size()
}
func (m *TopicTeamDynamicReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicTeamDynamicReq.DiscardUnknown(m)
}

var xxx_messageInfo_TopicTeamDynamicReq proto.InternalMessageInfo

func (m *TopicTeamDynamicReq) GetTopicTeamId() int64 {
	if m != nil && m.TopicTeamId != nil {
		return *m.TopicTeamId
	}
	return 0
}

func (m *TopicTeamDynamicReq) GetPage() int32 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *TopicTeamDynamicReq) GetPageSize() int32 {
	if m != nil && m.PageSize != nil {
		return *m.PageSize
	}
	return 0
}

type TopicTeamDynamicResp struct {
	TopicTeamId          *int64                       `protobuf:"varint,1,opt,name=TopicTeamId" json:"TopicTeamId,omitempty" bson:"TopicTeamId,omitempty"`
	DynamicList          []*share_message.DynamicData `protobuf:"bytes,2,rep,name=DynamicList" json:"DynamicList,omitempty" bson:"DynamicList,omitempty"`
	Count                *int32                       `protobuf:"varint,3,opt,name=count" json:"count,omitempty" bson:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-" bson:"-"`
	XXX_unrecognized     []byte                       `json:"-" bson:"-"`
	XXX_sizecache        int32                        `json:"-" bson:"-"`
}

func (m *TopicTeamDynamicResp) Reset()         { *m = TopicTeamDynamicResp{} }
func (m *TopicTeamDynamicResp) String() string { return proto.CompactTextString(m) }
func (*TopicTeamDynamicResp) ProtoMessage()    {}
func (*TopicTeamDynamicResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{98}
}
func (m *TopicTeamDynamicResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicTeamDynamicResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicTeamDynamicResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicTeamDynamicResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicTeamDynamicResp.Merge(m, src)
}
func (m *TopicTeamDynamicResp) XXX_Size() int {
	return m.Size()
}
func (m *TopicTeamDynamicResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicTeamDynamicResp.DiscardUnknown(m)
}

var xxx_messageInfo_TopicTeamDynamicResp proto.InternalMessageInfo

func (m *TopicTeamDynamicResp) GetTopicTeamId() int64 {
	if m != nil && m.TopicTeamId != nil {
		return *m.TopicTeamId
	}
	return 0
}

func (m *TopicTeamDynamicResp) GetDynamicList() []*share_message.DynamicData {
	if m != nil {
		return m.DynamicList
	}
	return nil
}

func (m *TopicTeamDynamicResp) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

//话题群
type TopicTeams struct {
	Topic                *string                   `protobuf:"bytes,1,opt,name=Topic" json:"Topic,omitempty" bson:"Topic,omitempty"`
	Teams                []*share_message.TeamData `protobuf:"bytes,2,rep,name=Teams" json:"Teams,omitempty" bson:"Teams,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-" bson:"-"`
	XXX_unrecognized     []byte                    `json:"-" bson:"-"`
	XXX_sizecache        int32                     `json:"-" bson:"-"`
}

func (m *TopicTeams) Reset()         { *m = TopicTeams{} }
func (m *TopicTeams) String() string { return proto.CompactTextString(m) }
func (*TopicTeams) ProtoMessage()    {}
func (*TopicTeams) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{99}
}
func (m *TopicTeams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicTeams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicTeams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicTeams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicTeams.Merge(m, src)
}
func (m *TopicTeams) XXX_Size() int {
	return m.Size()
}
func (m *TopicTeams) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicTeams.DiscardUnknown(m)
}

var xxx_messageInfo_TopicTeams proto.InternalMessageInfo

func (m *TopicTeams) GetTopic() string {
	if m != nil && m.Topic != nil {
		return *m.Topic
	}
	return ""
}

func (m *TopicTeams) GetTeams() []*share_message.TeamData {
	if m != nil {
		return m.Teams
	}
	return nil
}

//解散群
type DefunctTeam struct {
	TeamId               *int64   `protobuf:"varint,1,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	Result               *int32   `protobuf:"varint,2,opt,name=Result" json:"Result,omitempty" bson:"Result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *DefunctTeam) Reset()         { *m = DefunctTeam{} }
func (m *DefunctTeam) String() string { return proto.CompactTextString(m) }
func (*DefunctTeam) ProtoMessage()    {}
func (*DefunctTeam) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{100}
}
func (m *DefunctTeam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefunctTeam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DefunctTeam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DefunctTeam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefunctTeam.Merge(m, src)
}
func (m *DefunctTeam) XXX_Size() int {
	return m.Size()
}
func (m *DefunctTeam) XXX_DiscardUnknown() {
	xxx_messageInfo_DefunctTeam.DiscardUnknown(m)
}

var xxx_messageInfo_DefunctTeam proto.InternalMessageInfo

func (m *DefunctTeam) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *DefunctTeam) GetResult() int32 {
	if m != nil && m.Result != nil {
		return *m.Result
	}
	return 0
}

//主页菜单
type MainMenu struct {
	Id                   *int32                    `protobuf:"varint,1,opt,name=Id" json:"Id,omitempty" bson:"Id,omitempty"`
	Type                 *int32                    `protobuf:"varint,2,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	IsOpen               *bool                     `protobuf:"varint,3,opt,name=IsOpen" json:"IsOpen,omitempty" bson:"IsOpen,omitempty"`
	Adv                  *share_message.AdvSetting `protobuf:"bytes,4,opt,name=Adv" json:"Adv,omitempty" bson:"Adv,omitempty"`
	Slot                 *int32                    `protobuf:"varint,5,opt,name=Slot" json:"Slot,omitempty" bson:"Slot,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-" bson:"-"`
	XXX_unrecognized     []byte                    `json:"-" bson:"-"`
	XXX_sizecache        int32                     `json:"-" bson:"-"`
}

func (m *MainMenu) Reset()         { *m = MainMenu{} }
func (m *MainMenu) String() string { return proto.CompactTextString(m) }
func (*MainMenu) ProtoMessage()    {}
func (*MainMenu) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{101}
}
func (m *MainMenu) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MainMenu) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MainMenu.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MainMenu) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MainMenu.Merge(m, src)
}
func (m *MainMenu) XXX_Size() int {
	return m.Size()
}
func (m *MainMenu) XXX_DiscardUnknown() {
	xxx_messageInfo_MainMenu.DiscardUnknown(m)
}

var xxx_messageInfo_MainMenu proto.InternalMessageInfo

func (m *MainMenu) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *MainMenu) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *MainMenu) GetIsOpen() bool {
	if m != nil && m.IsOpen != nil {
		return *m.IsOpen
	}
	return false
}

func (m *MainMenu) GetAdv() *share_message.AdvSetting {
	if m != nil {
		return m.Adv
	}
	return nil
}

func (m *MainMenu) GetSlot() int32 {
	if m != nil && m.Slot != nil {
		return *m.Slot
	}
	return 0
}

//所有菜单选项
type AllMainMenu struct {
	Menus                []*MainMenu `protobuf:"bytes,1,rep,name=Menus" json:"Menus,omitempty" bson:"Menus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-" bson:"-"`
	XXX_unrecognized     []byte      `json:"-" bson:"-"`
	XXX_sizecache        int32       `json:"-" bson:"-"`
}

func (m *AllMainMenu) Reset()         { *m = AllMainMenu{} }
func (m *AllMainMenu) String() string { return proto.CompactTextString(m) }
func (*AllMainMenu) ProtoMessage()    {}
func (*AllMainMenu) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{102}
}
func (m *AllMainMenu) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllMainMenu) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllMainMenu.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllMainMenu) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllMainMenu.Merge(m, src)
}
func (m *AllMainMenu) XXX_Size() int {
	return m.Size()
}
func (m *AllMainMenu) XXX_DiscardUnknown() {
	xxx_messageInfo_AllMainMenu.DiscardUnknown(m)
}

var xxx_messageInfo_AllMainMenu proto.InternalMessageInfo

func (m *AllMainMenu) GetMenus() []*MainMenu {
	if m != nil {
		return m.Menus
	}
	return nil
}

//弹窗广告
type TipAdv struct {
	Page                 *int32                    `protobuf:"varint,1,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	Issuspension         *bool                     `protobuf:"varint,2,opt,name=Issuspension" json:"Issuspension,omitempty" bson:"Issuspension,omitempty"`
	IsJump               *bool                     `protobuf:"varint,3,opt,name=IsJump" json:"IsJump,omitempty" bson:"IsJump,omitempty"`
	Adv                  *share_message.AdvSetting `protobuf:"bytes,4,opt,name=Adv" json:"Adv,omitempty" bson:"Adv,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-" bson:"-"`
	XXX_unrecognized     []byte                    `json:"-" bson:"-"`
	XXX_sizecache        int32                     `json:"-" bson:"-"`
}

func (m *TipAdv) Reset()         { *m = TipAdv{} }
func (m *TipAdv) String() string { return proto.CompactTextString(m) }
func (*TipAdv) ProtoMessage()    {}
func (*TipAdv) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{103}
}
func (m *TipAdv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TipAdv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TipAdv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TipAdv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TipAdv.Merge(m, src)
}
func (m *TipAdv) XXX_Size() int {
	return m.Size()
}
func (m *TipAdv) XXX_DiscardUnknown() {
	xxx_messageInfo_TipAdv.DiscardUnknown(m)
}

var xxx_messageInfo_TipAdv proto.InternalMessageInfo

func (m *TipAdv) GetPage() int32 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *TipAdv) GetIssuspension() bool {
	if m != nil && m.Issuspension != nil {
		return *m.Issuspension
	}
	return false
}

func (m *TipAdv) GetIsJump() bool {
	if m != nil && m.IsJump != nil {
		return *m.IsJump
	}
	return false
}

func (m *TipAdv) GetAdv() *share_message.AdvSetting {
	if m != nil {
		return m.Adv
	}
	return nil
}

//所有弹窗广告
type AllTipAdv struct {
	Advs                 []*TipAdv `protobuf:"bytes,1,rep,name=Advs" json:"Advs,omitempty" bson:"Advs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" bson:"-"`
	XXX_unrecognized     []byte    `json:"-" bson:"-"`
	XXX_sizecache        int32     `json:"-" bson:"-"`
}

func (m *AllTipAdv) Reset()         { *m = AllTipAdv{} }
func (m *AllTipAdv) String() string { return proto.CompactTextString(m) }
func (*AllTipAdv) ProtoMessage()    {}
func (*AllTipAdv) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e4708d60e92570f, []int{104}
}
func (m *AllTipAdv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllTipAdv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllTipAdv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllTipAdv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllTipAdv.Merge(m, src)
}
func (m *AllTipAdv) XXX_Size() int {
	return m.Size()
}
func (m *AllTipAdv) XXX_DiscardUnknown() {
	xxx_messageInfo_AllTipAdv.DiscardUnknown(m)
}

var xxx_messageInfo_AllTipAdv proto.InternalMessageInfo

func (m *AllTipAdv) GetAdvs() []*TipAdv {
	if m != nil {
		return m.Advs
	}
	return nil
}

func init() {
	proto.RegisterType((*LoginMsg)(nil), "client_hall.LoginMsg")
	proto.RegisterType((*UpdateGold)(nil), "client_hall.UpdateGold")
	proto.RegisterType((*AddPlayerInfo)(nil), "client_hall.AddPlayerInfo")
	proto.RegisterType((*AccountInfo)(nil), "client_hall.AccountInfo")
	proto.RegisterType((*AddBookInfo)(nil), "client_hall.AddBookInfo")
	proto.RegisterType((*CreateTeam)(nil), "client_hall.CreateTeam")
	proto.RegisterType((*PeopleIdInfo)(nil), "client_hall.PeopleIdInfo")
	proto.RegisterType((*BankMessage)(nil), "client_hall.BankMessage")
	proto.RegisterType((*VersionInfo)(nil), "client_hall.VersionInfo")
	proto.RegisterType((*DelFriendInfo)(nil), "client_hall.DelFriendInfo")
	proto.RegisterType((*BlackInfo)(nil), "client_hall.BlackInfo")
	proto.RegisterType((*MoneyAssistantInfo)(nil), "client_hall.MoneyAssistantInfo")
	proto.RegisterType((*AllMoneyAssistantInfo)(nil), "client_hall.AllMoneyAssistantInfo")
	proto.RegisterType((*LocationInfo)(nil), "client_hall.LocationInfo")
	proto.RegisterType((*LocationInfoByPage)(nil), "client_hall.LocationInfoByPage")
	proto.RegisterType((*AllLocationPlayerInfo)(nil), "client_hall.AllLocationPlayerInfo")
	proto.RegisterType((*LocationPlayerInfo)(nil), "client_hall.LocationPlayerInfo")
	proto.RegisterType((*NearByMessage)(nil), "client_hall.NearByMessage")
	proto.RegisterType((*AllNearByMessage)(nil), "client_hall.AllNearByMessage")
	proto.RegisterType((*NearByInfoReply)(nil), "client_hall.NearByInfoReply")
	proto.RegisterType((*NearByInfoReplyByPage)(nil), "client_hall.NearByInfoReplyByPage")
	proto.RegisterType((*PageInfo)(nil), "client_hall.PageInfo")
	proto.RegisterType((*MoneyType)(nil), "client_hall.MoneyType")
	proto.RegisterType((*OrderInfo)(nil), "client_hall.OrderInfo")
	proto.RegisterType((*AllOrderInfo)(nil), "client_hall.AllOrderInfo")
	proto.RegisterType((*CashInfo)(nil), "client_hall.CashInfo")
	proto.RegisterType((*AllCashInfo)(nil), "client_hall.AllCashInfo")
	proto.RegisterType((*RedPacketInfo)(nil), "client_hall.RedPacketInfo")
	proto.RegisterType((*AllRedPacketInfo)(nil), "client_hall.AllRedPacketInfo")
	proto.RegisterType((*WithdrawInfo)(nil), "client_hall.WithdrawInfo")
	proto.RegisterType((*CheckPeopleInfo)(nil), "client_hall.CheckPeopleInfo")
	proto.RegisterType((*FirstInfo)(nil), "client_hall.FirstInfo")
	proto.RegisterType((*FirstReturnInfo)(nil), "client_hall.FirstReturnInfo")
	proto.RegisterType((*PayInfo)(nil), "client_hall.PayInfo")
	proto.RegisterType((*AllCollectInfo)(nil), "client_hall.AllCollectInfo")
	proto.RegisterType((*DelCollectInfo)(nil), "client_hall.DelCollectInfo")
	proto.RegisterType((*GetCollectInfo)(nil), "client_hall.GetCollectInfo")
	proto.RegisterType((*SearchCollectInfo)(nil), "client_hall.SearchCollectInfo")
	proto.RegisterType((*PayForCodeInfo)(nil), "client_hall.PayForCodeInfo")
	proto.RegisterType((*CodeInfo)(nil), "client_hall.CodeInfo")
	proto.RegisterType((*AInfo)(nil), "client_hall.AInfo")
	proto.RegisterType((*UnGetMoneyInfo)(nil), "client_hall.UnGetMoneyInfo")
	proto.RegisterType((*CollectIndex)(nil), "client_hall.CollectIndex")
	proto.RegisterType((*BankPaySMS)(nil), "client_hall.BankPaySMS")
	proto.RegisterType((*RecommendMsg)(nil), "client_hall.RecommendMsg")
	proto.RegisterType((*RecommendRefreshInfo)(nil), "client_hall.RecommendRefreshInfo")
	proto.RegisterType((*AddGoldInfo)(nil), "client_hall.AddGoldInfo")
	proto.RegisterType((*WechatInfo)(nil), "client_hall.WechatInfo")
	proto.RegisterType((*MarkName)(nil), "client_hall.MarkName")
	proto.RegisterType((*ArticleOptRequest)(nil), "client_hall.ArticleOptRequest")
	proto.RegisterType((*NoticeOptRequest)(nil), "client_hall.NoticeOptRequest")
	proto.RegisterType((*MainInfo)(nil), "client_hall.MainInfo")
	proto.RegisterType((*FansInfo)(nil), "client_hall.FansInfo")
	proto.RegisterType((*AllFansInfo)(nil), "client_hall.AllFansInfo")
	proto.RegisterType((*DynamicIdInfo)(nil), "client_hall.DynamicIdInfo")
	proto.RegisterType((*DynamicInfo)(nil), "client_hall.DynamicInfo")
	proto.RegisterType((*TeamMembers)(nil), "client_hall.TeamMembers")
	proto.RegisterType((*CheckDirtyWord)(nil), "client_hall.CheckDirtyWord")
	proto.RegisterType((*CheckCancelAccount)(nil), "client_hall.CheckCancelAccount")
	proto.RegisterType((*CancelAccountData)(nil), "client_hall.CancelAccountData")
	proto.RegisterType((*OpenMyMainPageByPageReq)(nil), "client_hall.OpenMyMainPageByPageReq")
	proto.RegisterType((*NewUnReadMessageResp)(nil), "client_hall.NewUnReadMessageResp")
	proto.RegisterType((*ComplaintID)(nil), "client_hall.ComplaintID")
	proto.RegisterType((*ShopOrderComplaintDetailRsp)(nil), "client_hall.ShopOrderComplaintDetailRsp")
	proto.RegisterType((*AdvSettingRequest)(nil), "client_hall.AdvSettingRequest")
	proto.RegisterType((*AdvSettingResponse)(nil), "client_hall.AdvSettingResponse")
	proto.RegisterType((*DelNewFriendListReq)(nil), "client_hall.DelNewFriendListReq")
	proto.RegisterType((*TeamSettingNotify)(nil), "client_hall.TeamSettingNotify")
	proto.RegisterType((*NewTeamSettingReq)(nil), "client_hall.NewTeamSettingReq")
	proto.RegisterType((*LocationInfoNewReq)(nil), "client_hall.LocationInfoNewReq")
	proto.RegisterType((*LocationInfoNew)(nil), "client_hall.LocationInfoNew")
	proto.RegisterType((*LocationInfoNewResp)(nil), "client_hall.LocationInfoNewResp")
	proto.RegisterType((*NearRecommendReq)(nil), "client_hall.NearRecommendReq")
	proto.RegisterType((*NearRecommendResp)(nil), "client_hall.NearRecommendResp")
	proto.RegisterType((*NearRecommend)(nil), "client_hall.NearRecommend")
	proto.RegisterType((*NotifyNewSayMessageReq)(nil), "client_hall.NotifyNewSayMessageReq")
	proto.RegisterType((*NearSessionListReq)(nil), "client_hall.NearSessionListReq")
	proto.RegisterType((*NearSessionListResp)(nil), "client_hall.NearSessionListResp")
	proto.RegisterType((*NearSessionList)(nil), "client_hall.NearSessionList")
	proto.RegisterType((*SendPlayerMessageListReq)(nil), "client_hall.SendPlayerMessageListReq")
	proto.RegisterType((*GetNearChatListReq)(nil), "client_hall.GetNearChatListReq")
	proto.RegisterType((*DelNearMessageReq)(nil), "client_hall.DelNearMessageReq")
	proto.RegisterType((*UpdateIsReadReq)(nil), "client_hall.UpdateIsReadReq")
	proto.RegisterType((*HasUnReadNearResp)(nil), "client_hall.HasUnReadNearResp")
	proto.RegisterType((*YoungPassWord)(nil), "client_hall.YoungPassWord")
	proto.RegisterType((*FriendNum)(nil), "client_hall.FriendNum")
	proto.RegisterType((*TeamChangePos)(nil), "client_hall.TeamChangePos")
	proto.RegisterType((*TeamMembersChange)(nil), "client_hall.TeamMembersChange")
	proto.RegisterType((*GetNewFriends)(nil), "client_hall.GetNewFriends")
	proto.RegisterType((*BankData)(nil), "client_hall.BankData")
	proto.RegisterType((*SupportBankList)(nil), "client_hall.SupportBankList")
	proto.RegisterType((*BuryingPoint)(nil), "client_hall.BuryingPoint")
	proto.RegisterType((*BuryingPointList)(nil), "client_hall.BuryingPointList")
	proto.RegisterType((*OnLineNum)(nil), "client_hall.OnLineNum")
	proto.RegisterType((*MsgAdv)(nil), "client_hall.MsgAdv")
	proto.RegisterType((*PlayerDiamond)(nil), "client_hall.PlayerDiamond")
	proto.RegisterType((*PayChannels)(nil), "client_hall.PayChannels")
	proto.RegisterType((*TopicTeamDynamicReq)(nil), "client_hall.TopicTeamDynamicReq")
	proto.RegisterType((*TopicTeamDynamicResp)(nil), "client_hall.TopicTeamDynamicResp")
	proto.RegisterType((*TopicTeams)(nil), "client_hall.TopicTeams")
	proto.RegisterType((*DefunctTeam)(nil), "client_hall.DefunctTeam")
	proto.RegisterType((*MainMenu)(nil), "client_hall.MainMenu")
	proto.RegisterType((*AllMainMenu)(nil), "client_hall.AllMainMenu")
	proto.RegisterType((*TipAdv)(nil), "client_hall.TipAdv")
	proto.RegisterType((*AllTipAdv)(nil), "client_hall.AllTipAdv")
}

func init() { proto.RegisterFile("mainlogic.proto", fileDescriptor_0e4708d60e92570f) }

var fileDescriptor_0e4708d60e92570f = []byte{
	// 6082 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x7c, 0xcd, 0x73, 0x1b, 0x47,
	0x76, 0x78, 0x81, 0x20, 0x48, 0xe0, 0x01, 0xfc, 0x1a, 0xea, 0x03, 0x82, 0x56, 0x1f, 0x9e, 0xb5,
	0xd7, 0xf2, 0x7a, 0x57, 0xb6, 0x69, 0xef, 0xae, 0xbd, 0xf6, 0x7a, 0x0d, 0x92, 0x22, 0x05, 0x2f,
	0x01, 0xc1, 0x00, 0xb5, 0xb2, 0xfd, 0xdb, 0x5f, 0x58, 0xad, 0x99, 0x16, 0x38, 0xe1, 0x60, 0x06,
	0x9a, 0x19, 0x50, 0x82, 0x93, 0x4b, 0x52, 0xa9, 0xe4, 0x94, 0xaa, 0x1c, 0x52, 0x95, 0x54, 0x0e,
	0xb9, 0xe4, 0x92, 0xfc, 0x11, 0x49, 0x0e, 0xb9, 0xe4, 0x98, 0x3f, 0x21, 0xd9, 0xfc, 0x11, 0xb9,
	0xa6, 0xfa, 0x75, 0xf7, 0x4c, 0x77, 0xcf, 0x00, 0xa4, 0xb4, 0xa9, 0x3d, 0x51, 0xe8, 0xee, 0xf7,
	0xfa, 0xf5, 0xeb, 0xf7, 0xdd, 0x6f, 0x04, 0x1b, 0x63, 0xe2, 0x05, 0x7e, 0x38, 0xf2, 0x9c, 0xfb,
	0x93, 0x28, 0x4c, 0x42, 0xab, 0xee, 0xf8, 0x1e, 0x0d, 0x92, 0x93, 0x53, 0xe2, 0xfb, 0x2d, 0x78,
	0x4a, 0x62, 0xca, 0x27, 0x5a, 0x0d, 0x27, 0x1c, 0x8f, 0xc3, 0x40, 0xfc, 0x7a, 0x6f, 0x44, 0xc6,
	0xf4, 0x24, 0xa6, 0xd1, 0x39, 0x8d, 0xde, 0xc3, 0xa1, 0xf7, 0xe2, 0x53, 0x12, 0xd1, 0x93, 0x31,
	0x8d, 0x63, 0x32, 0xa2, 0xef, 0x11, 0xdf, 0xd7, 0x00, 0x76, 0x2e, 0x02, 0x48, 0xc8, 0x53, 0x9f,
	0x9e, 0xc4, 0x49, 0x34, 0x75, 0x12, 0x01, 0xf3, 0xf9, 0xab, 0xc0, 0x9c, 0x4c, 0x7c, 0x32, 0xa3,
	0xd1, 0x89, 0x42, 0xf2, 0xfb, 0x17, 0xc1, 0x0f, 0x4f, 0xc3, 0xc9, 0x9e, 0x42, 0xa5, 0xfd, 0x57,
	0x4b, 0x50, 0x3d, 0x0a, 0x47, 0x5e, 0xd0, 0x8d, 0x47, 0xd6, 0x06, 0xac, 0xb6, 0x1d, 0x27, 0x9c,
	0x06, 0x49, 0xb3, 0x74, 0x77, 0xe9, 0x5e, 0xcd, 0x5a, 0x83, 0xca, 0x71, 0x78, 0x46, 0x83, 0xe6,
	0xd2, 0xdd, 0xd2, 0xbd, 0x9a, 0x75, 0x0d, 0xd6, 0x07, 0x74, 0xe4, 0xc5, 0x49, 0x44, 0x12, 0x2f,
	0x0c, 0x3a, 0x6e, 0xb3, 0x8c, 0xe3, 0x1b, 0xb0, 0xba, 0x77, 0x4a, 0x82, 0x80, 0xfa, 0xcd, 0x65,
	0x1c, 0xb0, 0x00, 0x18, 0x8b, 0x83, 0x93, 0x64, 0x36, 0xa1, 0xcd, 0xca, 0xdd, 0xd2, 0xbd, 0x8a,
	0xb5, 0x0d, 0x75, 0x97, 0x9e, 0x7b, 0x0e, 0xe5, 0x83, 0x2b, 0x38, 0xd8, 0x80, 0xe5, 0x63, 0xf6,
	0x6b, 0x15, 0x7f, 0x6d, 0x42, 0xb5, 0x8f, 0x67, 0xea, 0xb8, 0xcd, 0xea, 0xdd, 0xd2, 0xbd, 0xb2,
	0x75, 0x15, 0xd6, 0x7e, 0x4d, 0xa3, 0xd8, 0x0b, 0x83, 0xde, 0x74, 0xfc, 0x94, 0x46, 0xcd, 0x1a,
	0xe2, 0x5f, 0x83, 0xca, 0x6e, 0x44, 0x02, 0xb7, 0x09, 0xf8, 0x73, 0x13, 0xaa, 0x9d, 0xb8, 0x3d,
	0x99, 0xb4, 0x9d, 0xa4, 0x59, 0xbf, 0x5b, 0xba, 0x57, 0xb5, 0xb6, 0xa0, 0xd6, 0x89, 0x1f, 0xc7,
	0x34, 0x1a, 0xd0, 0x51, 0xb3, 0x81, 0x43, 0x16, 0x40, 0x27, 0xe6, 0x47, 0x25, 0x41, 0x73, 0x0d,
	0xc7, 0xb6, 0xa1, 0x2e, 0xc6, 0x0e, 0x22, 0xfa, 0xbc, 0xb9, 0xce, 0x06, 0xed, 0x16, 0xc0, 0xe3,
	0x89, 0x4b, 0x12, 0x7a, 0x18, 0xfa, 0x2e, 0xa3, 0x90, 0xfd, 0x6d, 0x96, 0x18, 0x3d, 0xf6, 0x1f,
	0xc1, 0x5a, 0xdb, 0x75, 0x05, 0x91, 0xc1, 0xb3, 0x30, 0xcf, 0xb2, 0x77, 0xc5, 0x89, 0x18, 0xc7,
	0xd6, 0x77, 0x6e, 0xdd, 0xd7, 0xf8, 0x7f, 0xbf, 0xed, 0xba, 0x07, 0x91, 0x47, 0x03, 0xf7, 0x84,
	0x2d, 0xc2, 0xe3, 0xd3, 0x97, 0x89, 0x60, 0xa3, 0x7a, 0xfc, 0x65, 0x3c, 0x7e, 0x03, 0x96, 0xbb,
	0x24, 0x3a, 0x43, 0x0e, 0x56, 0xed, 0xff, 0x0f, 0x75, 0xb1, 0x57, 0x7e, 0xeb, 0xd2, 0xab, 0x6e,
	0xad, 0x6e, 0x56, 0xc6, 0xb3, 0xdd, 0x85, 0x7a, 0xdb, 0x75, 0x77, 0xc3, 0xf0, 0x0c, 0xd1, 0x6f,
	0x41, 0xad, 0x7f, 0x1a, 0x06, 0xf4, 0xc8, 0x8b, 0xd9, 0x06, 0xe5, 0x7b, 0x35, 0xfb, 0xcf, 0x4a,
	0x00, 0x7b, 0x11, 0x25, 0x09, 0x3d, 0xa6, 0x64, 0x9c, 0x52, 0x57, 0xc2, 0xcb, 0xb3, 0x00, 0x38,
	0x42, 0x04, 0x58, 0xba, 0x5b, 0xbe, 0x57, 0x66, 0x9b, 0xb0, 0x95, 0x3d, 0x32, 0xa6, 0x99, 0xa8,
	0xb4, 0xdd, 0xb1, 0x17, 0xa4, 0x47, 0xdc, 0x80, 0xd5, 0x87, 0x94, 0xb8, 0x8f, 0x23, 0x1f, 0x4f,
	0x29, 0x64, 0x6e, 0xe2, 0x39, 0x28, 0x21, 0x35, 0x46, 0x06, 0xfe, 0xdc, 0xa7, 0xb1, 0x83, 0x62,
	0x52, 0xb3, 0xef, 0x43, 0xa3, 0x4f, 0xc3, 0x89, 0x4f, 0x3b, 0x2e, 0x52, 0xda, 0x80, 0x65, 0xdc,
	0xa1, 0x94, 0x72, 0x51, 0xcc, 0x72, 0xb1, 0xb5, 0xff, 0x6e, 0x09, 0xea, 0xbb, 0x24, 0x38, 0xeb,
	0x72, 0x4e, 0xb0, 0x15, 0x4c, 0x34, 0x14, 0x98, 0x75, 0x58, 0xe9, 0xb8, 0x29, 0xef, 0x6a, 0x0c,
	0x63, 0xc7, 0xed, 0x85, 0x82, 0x66, 0x0b, 0x80, 0x81, 0xef, 0x91, 0x88, 0x8d, 0x2d, 0xcb, 0x5d,
	0xba, 0xe1, 0x53, 0xcf, 0xa7, 0xbd, 0x50, 0xd0, 0x6d, 0x01, 0x3c, 0x78, 0x39, 0xf1, 0x22, 0xba,
	0x4f, 0x12, 0x2a, 0x88, 0xaf, 0x43, 0x79, 0xef, 0xfc, 0x9c, 0x93, 0xcd, 0x40, 0x10, 0x4d, 0xe8,
	0x52, 0x94, 0x6e, 0x3c, 0xdb, 0x97, 0xfd, 0x47, 0x91, 0x4b, 0xa3, 0x5e, 0x28, 0x24, 0x7b, 0x03,
	0x56, 0xe5, 0x00, 0xc8, 0x81, 0x6e, 0x3c, 0x42, 0xa0, 0xba, 0xa4, 0x75, 0xe8, 0x8d, 0x82, 0x5e,
	0x88, 0x72, 0x8d, 0x0b, 0xfa, 0x51, 0xc8, 0x14, 0x0b, 0x85, 0x1a, 0x89, 0xdf, 0xf3, 0x92, 0x19,
	0x4a, 0x33, 0xfe, 0x6a, 0x47, 0x94, 0x34, 0x37, 0x32, 0x4d, 0xe9, 0x86, 0xae, 0xf7, 0x6c, 0xd6,
	0xdc, 0x44, 0xa1, 0xba, 0x0d, 0x75, 0xa1, 0x61, 0x52, 0xa8, 0xc4, 0x4f, 0xce, 0x1a, 0x7b, 0x07,
	0xd6, 0xf6, 0xa9, 0xcf, 0x25, 0x07, 0x57, 0xa8, 0x82, 0x53, 0x92, 0x57, 0xd8, 0x89, 0x77, 0x7d,
	0xe2, 0x9c, 0x21, 0xfb, 0xaa, 0xf6, 0xbb, 0x50, 0xc3, 0x9f, 0xf2, 0x76, 0x90, 0xb3, 0xa5, 0x9c,
	0x8a, 0x2f, 0xa1, 0xd8, 0xfd, 0x7d, 0x09, 0xac, 0x6e, 0x18, 0xd0, 0x59, 0x3b, 0x8e, 0xbd, 0x38,
	0x21, 0x42, 0xba, 0xd7, 0xa0, 0x72, 0x14, 0x8e, 0x70, 0x8f, 0x25, 0x2e, 0x49, 0x3a, 0x1c, 0xe3,
	0x37, 0x33, 0x3a, 0x23, 0x54, 0x53, 0x2e, 0xc2, 0x6c, 0x6c, 0x18, 0x4e, 0x23, 0x87, 0xe2, 0x8e,
	0xcb, 0xd2, 0xc4, 0xf4, 0xc2, 0x84, 0x66, 0xb7, 0x24, 0x24, 0xd8, 0x1b, 0xf3, 0x5b, 0x2a, 0xa7,
	0x2a, 0xbe, 0x2a, 0x4f, 0x83, 0x37, 0x20, 0x6c, 0x50, 0xcd, 0x3e, 0x80, 0xab, 0x6d, 0xdf, 0x2f,
	0x20, 0xf1, 0xc7, 0xb0, 0xcc, 0xfe, 0xa2, 0x72, 0xd4, 0x77, 0xee, 0xdc, 0x57, 0x1c, 0xc9, 0xfd,
	0xfc, 0x72, 0x3b, 0x82, 0xc6, 0x51, 0xe8, 0x70, 0xcb, 0xc9, 0xc0, 0x6b, 0x50, 0xfa, 0x1a, 0xb9,
	0x52, 0x62, 0xff, 0xfc, 0x06, 0x8f, 0x55, 0xc2, 0x83, 0xb2, 0xeb, 0x0c, 0x1c, 0xa9, 0x32, 0xf2,
	0x3e, 0x97, 0x73, 0x46, 0xa2, 0x22, 0xc9, 0x3f, 0xd6, 0x2c, 0x2a, 0xde, 0x37, 0x57, 0x95, 0xbf,
	0x2d, 0x81, 0xa5, 0x6e, 0xba, 0x3b, 0xeb, 0x33, 0x0d, 0xf8, 0x3d, 0x6c, 0xcd, 0x7e, 0xb1, 0xbd,
	0x90, 0x89, 0xfc, 0xde, 0xc9, 0x88, 0x0e, 0xbd, 0xef, 0x28, 0x4a, 0x7a, 0xc5, 0x3e, 0x42, 0xb6,
	0x4a, 0xe2, 0x14, 0x93, 0xfa, 0xa1, 0x34, 0x24, 0x73, 0x99, 0x9b, 0x07, 0xb2, 0xff, 0x7a, 0x29,
	0x3b, 0xa8, 0x82, 0x2b, 0x2f, 0xac, 0x75, 0x28, 0x0f, 0xe9, 0x4b, 0x3c, 0x31, 0x52, 0xb5, 0x8f,
	0x37, 0x24, 0x4e, 0x5c, 0x62, 0x2a, 0xc9, 0xb4, 0x8b, 0x24, 0xd3, 0x88, 0x66, 0xc7, 0xee, 0xc4,
	0x5c, 0x01, 0xb8, 0x21, 0x66, 0x23, 0xcc, 0x66, 0x75, 0x9c, 0x30, 0x10, 0x8a, 0x2e, 0x4d, 0x50,
	0xaa, 0xe9, 0x29, 0x23, 0xab, 0x1a, 0x23, 0x53, 0x25, 0x97, 0x96, 0x1b, 0xa4, 0xcd, 0xeb, 0x9f,
	0x86, 0x49, 0x28, 0x54, 0x5c, 0x32, 0xb2, 0x91, 0x1a, 0xc4, 0xd9, 0x84, 0xc6, 0xa8, 0xde, 0x15,
	0xeb, 0x5d, 0xa8, 0x1d, 0x91, 0xa7, 0xd4, 0x47, 0xee, 0xdc, 0x41, 0xee, 0x34, 0x0d, 0x53, 0x9f,
	0xce, 0xdb, 0xff, 0x55, 0x82, 0xb5, 0x1e, 0x25, 0xd1, 0xee, 0x4c, 0x31, 0x7e, 0x0a, 0x47, 0x96,
	0xb8, 0xc0, 0xef, 0x85, 0x41, 0x42, 0x83, 0x44, 0x58, 0xbf, 0x4d, 0xa8, 0xf6, 0x3c, 0xe7, 0x4c,
	0xb1, 0xda, 0xea, 0x81, 0x97, 0xa5, 0x65, 0x63, 0x6c, 0xe4, 0xae, 0x5d, 0x31, 0x41, 0x2b, 0xda,
	0x71, 0x57, 0xf5, 0xd3, 0x55, 0xcd, 0xd3, 0xd7, 0xe4, 0x6a, 0xd4, 0x46, 0xc0, 0x0b, 0x5a, 0x83,
	0x4a, 0x27, 0x6e, 0xbb, 0x6e, 0xe6, 0xc9, 0xb3, 0x0b, 0x29, 0x62, 0x88, 0xfd, 0x00, 0x36, 0xdb,
	0xbe, 0xaf, 0x9f, 0xf2, 0x03, 0xe3, 0xd8, 0x42, 0x8c, 0x5a, 0x9a, 0x18, 0x69, 0x2b, 0xec, 0x3f,
	0x2d, 0xc1, 0x06, 0x1f, 0x61, 0x9c, 0x1b, 0xd0, 0x89, 0x3f, 0xb3, 0x3e, 0x81, 0xb5, 0x14, 0xb5,
	0x90, 0xc6, 0xd2, 0xbd, 0xfa, 0x8e, 0xad, 0xa1, 0x29, 0x96, 0xe2, 0x8f, 0x04, 0x55, 0x2f, 0x14,
	0xe8, 0xa5, 0x0b, 0x89, 0xf8, 0x9b, 0x12, 0x5c, 0x35, 0x88, 0x10, 0x2a, 0xfb, 0xfb, 0x26, 0x85,
	0x71, 0x79, 0x0f, 0x2f, 0xa9, 0x8c, 0x5c, 0x7e, 0x8b, 0x2b, 0xb0, 0x34, 0xe9, 0x7d, 0xce, 0x54,
	0x76, 0xfb, 0x75, 0x28, 0xf7, 0xa6, 0x63, 0xae, 0x51, 0xf6, 0x57, 0x50, 0x43, 0xd3, 0x97, 0x86,
	0x37, 0x99, 0xe9, 0x6f, 0xc0, 0xf2, 0x37, 0x94, 0x44, 0x42, 0xf5, 0xd6, 0xa0, 0xd2, 0x0d, 0x83,
	0xe4, 0x94, 0xa3, 0x4f, 0x51, 0x2e, 0xab, 0x28, 0x51, 0xba, 0xec, 0x7f, 0x5a, 0x82, 0x1a, 0xb7,
	0xc8, 0x79, 0x67, 0x2f, 0x45, 0x67, 0x49, 0x8a, 0x0e, 0x6e, 0x2e, 0xbc, 0x41, 0x5e, 0x6a, 0x25,
	0x41, 0x5c, 0x6c, 0x99, 0x27, 0x4d, 0x48, 0x32, 0x55, 0x83, 0x51, 0x16, 0x8d, 0xad, 0x6a, 0x9e,
	0x58, 0xfa, 0x01, 0xa6, 0x78, 0x03, 0xea, 0xf6, 0x89, 0x73, 0x46, 0xb9, 0xe4, 0xe6, 0x15, 0x2f,
	0x9d, 0x47, 0x95, 0x20, 0x33, 0xa4, 0x94, 0xab, 0xf8, 0x55, 0x58, 0x1b, 0xd2, 0x88, 0xe9, 0xc8,
	0xde, 0x29, 0x89, 0x46, 0xdc, 0x9b, 0x97, 0x59, 0x04, 0x3a, 0xa0, 0x0e, 0xf5, 0xce, 0xb9, 0x43,
	0x6a, 0xe0, 0xe0, 0x15, 0x68, 0x1c, 0x47, 0x24, 0x88, 0x9f, 0xd1, 0x08, 0x09, 0x5a, 0x93, 0x4a,
	0xc8, 0xc2, 0x77, 0xc4, 0xb9, 0xae, 0x46, 0x14, 0x38, 0x82, 0xfe, 0xdd, 0xfe, 0x04, 0x1a, 0x6d,
	0xdf, 0xcf, 0xb8, 0xf5, 0x8e, 0xc2, 0x3a, 0xa1, 0x03, 0xd7, 0xb4, 0x3b, 0x4f, 0x67, 0xed, 0x6f,
	0xa0, 0xba, 0x47, 0xe2, 0x53, 0x19, 0x05, 0xc8, 0xb3, 0x17, 0xf1, 0xb9, 0xc8, 0xf5, 0x4a, 0x27,
	0xba, 0xac, 0x39, 0x06, 0x7e, 0x83, 0x3f, 0x85, 0x7a, 0xdb, 0xf7, 0x53, 0xec, 0x6f, 0x67, 0x3b,
	0x09, 0x9a, 0xae, 0x6a, 0x34, 0xc9, 0x49, 0xfb, 0x31, 0xac, 0xa5, 0x1c, 0x2d, 0x88, 0x25, 0x5e,
	0x57, 0xa0, 0xfe, 0xa4, 0x84, 0x0a, 0xa1, 0xa3, 0x7e, 0x07, 0x56, 0xdb, 0xbe, 0xaf, 0xd0, 0xb4,
	0xf0, 0x6e, 0x8f, 0xa6, 0xce, 0xd9, 0x9e, 0x30, 0x98, 0xe8, 0x46, 0x8e, 0xc3, 0x84, 0xf8, 0x7b,
	0x52, 0x5b, 0x78, 0xd4, 0x9a, 0x10, 0x7f, 0x2e, 0x4b, 0xfe, 0xad, 0x04, 0x8d, 0x27, 0x5e, 0x72,
	0xea, 0x46, 0xe4, 0x85, 0xf4, 0x54, 0x69, 0x74, 0xc8, 0x79, 0xbe, 0x9d, 0x86, 0xfb, 0x4a, 0x64,
	0xba, 0x05, 0x35, 0x31, 0x98, 0x86, 0xa7, 0xd9, 0x3a, 0x14, 0x84, 0x65, 0x63, 0xb0, 0x1f, 0x85,
	0x13, 0x11, 0xfc, 0xac, 0xc3, 0x4a, 0x7b, 0x8c, 0x3a, 0xcd, 0x03, 0x9f, 0x75, 0x58, 0x19, 0xd0,
	0x78, 0xea, 0x73, 0x91, 0xaf, 0xe6, 0x45, 0x9e, 0x19, 0xdf, 0x84, 0x44, 0x09, 0xde, 0x7d, 0x4d,
	0xfa, 0xcf, 0x63, 0xf2, 0x92, 0xdb, 0x6a, 0xfb, 0x0e, 0x6c, 0xec, 0x9d, 0x52, 0xe7, 0x4c, 0x04,
	0xdc, 0xb9, 0x2b, 0xb2, 0x27, 0x50, 0x3b, 0xf0, 0xa2, 0x38, 0x49, 0x9d, 0x31, 0x89, 0xe3, 0x17,
	0x61, 0x24, 0xc5, 0x8a, 0x05, 0x79, 0xcc, 0x57, 0xa1, 0x39, 0xaa, 0x48, 0xa7, 0x52, 0x96, 0x4c,
	0x4d, 0xbd, 0xd0, 0x72, 0x4a, 0x4d, 0xea, 0x0a, 0x2a, 0x39, 0xc7, 0x84, 0xae, 0xc7, 0x7e, 0x1f,
	0x36, 0x70, 0xc7, 0x01, 0x4d, 0xa6, 0x51, 0x50, 0x20, 0x35, 0xa6, 0xbb, 0xb3, 0xff, 0xb5, 0x84,
	0xba, 0x3a, 0x27, 0x5e, 0x90, 0x72, 0xbd, 0xa4, 0x5d, 0x62, 0xd9, 0x44, 0xc5, 0x29, 0xfc, 0x00,
	0x1a, 0x7d, 0x32, 0xcb, 0x34, 0xae, 0x82, 0x56, 0xe2, 0xa6, 0x21, 0x49, 0xea, 0x12, 0xee, 0xee,
	0x9e, 0x90, 0x19, 0x92, 0x5f, 0xd5, 0x78, 0xa4, 0xa5, 0x0d, 0x88, 0xaf, 0x6a, 0x5a, 0x26, 0x74,
	0xa0, 0x76, 0x1b, 0xd6, 0x99, 0x7e, 0x85, 0xbe, 0x4f, 0x1d, 0xce, 0xea, 0xf7, 0xa0, 0xae, 0xfc,
	0x4c, 0xbd, 0x9f, 0x4e, 0x87, 0xb2, 0xc2, 0xbe, 0x03, 0xeb, 0xfb, 0x54, 0x43, 0xc1, 0x08, 0x0b,
	0x5c, 0xfa, 0x52, 0xdc, 0xe4, 0x27, 0xb0, 0x7e, 0x48, 0x13, 0x75, 0xc1, 0x7c, 0x2f, 0xa0, 0xb3,
	0xc9, 0x7e, 0x13, 0xb6, 0x86, 0x94, 0x44, 0xce, 0xa9, 0x0a, 0xad, 0xf0, 0x8e, 0x27, 0x1a, 0xb7,
	0x61, 0xbd, 0x4f, 0x66, 0x07, 0x61, 0xc4, 0x54, 0xa0, 0x40, 0x94, 0xfe, 0x18, 0xaa, 0xe9, 0xcc,
	0x25, 0xae, 0x69, 0x61, 0xf4, 0xb2, 0x0e, 0x2b, 0x2c, 0x2f, 0x4d, 0xe3, 0x58, 0x0b, 0xe0, 0x80,
	0x78, 0xfe, 0x80, 0x92, 0x58, 0x0d, 0xe9, 0x50, 0x19, 0x79, 0x20, 0x7d, 0x15, 0x2a, 0x6d, 0x49,
	0x54, 0xc2, 0x89, 0x5a, 0xba, 0x57, 0xb1, 0xbf, 0x80, 0xf5, 0xc7, 0xc1, 0x21, 0x4d, 0xd0, 0xed,
	0x48, 0xd2, 0x8e, 0x99, 0x7d, 0x4f, 0x52, 0xd2, 0x58, 0x72, 0x19, 0x3f, 0x24, 0xe7, 0x5c, 0x85,
	0xab, 0x06, 0x73, 0xde, 0x80, 0x46, 0xca, 0x16, 0x97, 0xbe, 0xc4, 0xca, 0x05, 0xfb, 0x47, 0x9a,
	0x76, 0x33, 0xd6, 0x63, 0xfe, 0xd9, 0x27, 0xb3, 0x61, 0x77, 0xa8, 0x66, 0x88, 0xa5, 0x34, 0x14,
	0xeb, 0x0e, 0x85, 0x7d, 0x60, 0xb1, 0x16, 0x99, 0x89, 0x9c, 0x1e, 0xb1, 0x0f, 0xa8, 0x13, 0x8e,
	0xc7, 0x34, 0x70, 0xbb, 0xf1, 0x08, 0x93, 0x7a, 0xc1, 0xb8, 0x18, 0xb1, 0x97, 0xed, 0x37, 0xe1,
	0x4a, 0xba, 0x64, 0x40, 0x9f, 0x45, 0x54, 0x58, 0x69, 0x9d, 0xfb, 0x9f, 0x62, 0x71, 0x80, 0xb1,
	0x58, 0x4e, 0x66, 0x55, 0x91, 0x94, 0xdd, 0x4b, 0xb9, 0x34, 0x81, 0x57, 0x16, 0x8e, 0x00, 0x9e,
	0x50, 0xe7, 0x94, 0xa4, 0x72, 0xa3, 0x58, 0xb9, 0x86, 0x52, 0xb4, 0xa8, 0xa4, 0x45, 0x07, 0x5c,
	0x90, 0x55, 0x0c, 0x26, 0xdc, 0x2e, 0xa2, 0x2d, 0xb7, 0x7f, 0x08, 0xd5, 0x2e, 0x89, 0xd0, 0x30,
	0x14, 0x0b, 0x42, 0x46, 0x8b, 0xfd, 0x11, 0x6c, 0xb5, 0xa3, 0xc4, 0x73, 0x7c, 0xfa, 0x68, 0x92,
	0x0c, 0xe8, 0xf3, 0x29, 0x8d, 0x13, 0xb4, 0xa1, 0x7c, 0x50, 0x85, 0xca, 0xa8, 0xb0, 0x7f, 0x04,
	0x9b, 0xbd, 0x30, 0xf1, 0x1c, 0x15, 0x08, 0x60, 0x49, 0xac, 0xae, 0x18, 0xab, 0x0f, 0x19, 0x3d,
	0x5e, 0x70, 0x99, 0x64, 0x37, 0xd5, 0x99, 0xb2, 0x74, 0x59, 0x3c, 0xc4, 0xe2, 0x07, 0x3b, 0x83,
	0xea, 0x01, 0x09, 0xe2, 0xcb, 0x24, 0x2e, 0x9a, 0x29, 0x2c, 0x6b, 0x29, 0xc8, 0x72, 0x4e, 0xe6,
	0x2b, 0x7a, 0xd4, 0xbc, 0xa2, 0xf8, 0xe4, 0x74, 0xbf, 0xb7, 0xb3, 0xbd, 0x0b, 0x7d, 0xb2, 0x9c,
	0xb4, 0x3f, 0x87, 0xb5, 0xfd, 0x59, 0x40, 0xc6, 0x9e, 0xd3, 0x99, 0x57, 0x0f, 0x48, 0x53, 0xf7,
	0x02, 0x9b, 0x69, 0x7f, 0x0e, 0x75, 0x09, 0x2f, 0x0c, 0x95, 0xf8, 0xb9, 0x4f, 0x12, 0x32, 0xc7,
	0x50, 0x29, 0x2b, 0xec, 0xdf, 0x40, 0x9d, 0xa9, 0x6e, 0x97, 0x8e, 0x9f, 0xd2, 0x28, 0x56, 0x34,
	0x99, 0xef, 0xfd, 0x3e, 0xac, 0x8e, 0xf9, 0x94, 0x08, 0x71, 0xef, 0x98, 0xc6, 0x97, 0x46, 0x71,
	0x18, 0x10, 0x9f, 0x41, 0x31, 0x84, 0x8c, 0xaf, 0xcc, 0xfc, 0x72, 0xea, 0x3e, 0x84, 0x75, 0x74,
	0x68, 0xfb, 0x5e, 0x94, 0xcc, 0x9e, 0x84, 0x91, 0xcb, 0x0e, 0xc3, 0xfe, 0x72, 0x6d, 0xc1, 0xfa,
	0x41, 0x3a, 0xc7, 0xb7, 0xa8, 0xd9, 0xff, 0x58, 0x02, 0x0b, 0xa1, 0xf6, 0x58, 0x22, 0xe9, 0x0b,
	0xbf, 0xcb, 0x96, 0x1e, 0x9f, 0xb2, 0xb5, 0xfb, 0x64, 0x16, 0x23, 0x79, 0x58, 0x84, 0x44, 0xf9,
	0x66, 0x71, 0xa7, 0xb4, 0x07, 0x57, 0x61, 0x4d, 0x16, 0xac, 0xf8, 0x70, 0x19, 0x87, 0xaf, 0x40,
	0x43, 0x60, 0xe2, 0xa3, 0xcb, 0x12, 0xc1, 0x71, 0x44, 0x5c, 0x81, 0xa0, 0x22, 0x57, 0xee, 0x12,
	0x9f, 0xed, 0xcd, 0x47, 0x57, 0x64, 0x6d, 0x93, 0x27, 0xad, 0x7c, 0x10, 0x3d, 0x3c, 0xcb, 0x2f,
	0xb6, 0x34, 0x2a, 0x91, 0x05, 0x9b, 0x50, 0x1d, 0x50, 0xe2, 0x2f, 0x2a, 0xa2, 0x59, 0x37, 0x60,
	0x4b, 0x8e, 0xec, 0xd2, 0x67, 0x61, 0x44, 0x1f, 0x47, 0xbe, 0x90, 0xbc, 0xeb, 0xb0, 0x91, 0x4e,
	0x11, 0xe7, 0x8c, 0x4d, 0x2c, 0x9b, 0x13, 0x0f, 0x49, 0xa0, 0xd4, 0xf8, 0x34, 0x35, 0xe7, 0x7e,
	0xfb, 0x57, 0x70, 0xfd, 0xd1, 0x84, 0x06, 0xdd, 0x19, 0xd3, 0x25, 0xa6, 0x23, 0x3c, 0xef, 0x19,
	0xd0, 0xe7, 0x86, 0xa3, 0x51, 0x2b, 0x09, 0x4b, 0x39, 0x35, 0x2b, 0xb3, 0x94, 0xd6, 0xfe, 0x06,
	0xae, 0xf4, 0xe8, 0x8b, 0xc7, 0xc1, 0x80, 0x12, 0x57, 0xe4, 0x33, 0x03, 0x1a, 0x4f, 0x18, 0xab,
	0x1f, 0x07, 0x11, 0x25, 0xee, 0x1e, 0xda, 0xbb, 0x44, 0xa0, 0xdc, 0x82, 0x1a, 0x1f, 0xfe, 0x96,
	0x04, 0x02, 0xe7, 0x75, 0xd8, 0xe0, 0x43, 0xed, 0x84, 0xf9, 0x28, 0x2f, 0x0c, 0x84, 0x84, 0xd8,
	0xcc, 0xb3, 0x8e, 0x27, 0x3e, 0xf1, 0x82, 0xa4, 0xb3, 0xcf, 0xb8, 0x9c, 0xfd, 0x14, 0x19, 0xb5,
	0xfd, 0xcf, 0x4b, 0x70, 0x93, 0x85, 0xea, 0x68, 0xa7, 0xd3, 0xe9, 0x7d, 0x9a, 0x30, 0x1f, 0x13,
	0x4f, 0xac, 0x26, 0x6c, 0xc6, 0x93, 0x30, 0x88, 0xc3, 0xe8, 0x24, 0xf0, 0x9c, 0xb3, 0x20, 0xe3,
	0xfb, 0x35, 0x58, 0x97, 0x33, 0xe4, 0x9c, 0x24, 0x22, 0xb8, 0xad, 0x59, 0x3f, 0x84, 0x9a, 0x97,
	0xd0, 0xf1, 0xc9, 0x33, 0xcf, 0xe7, 0xf2, 0x51, 0xdf, 0xb9, 0x6e, 0x08, 0x76, 0x27, 0xa1, 0xe3,
	0x03, 0xcf, 0xa7, 0xec, 0x34, 0xb8, 0x36, 0xc8, 0xac, 0x81, 0x05, 0x80, 0x43, 0x89, 0x97, 0xf8,
	0x32, 0x74, 0xba, 0x01, 0x5b, 0x21, 0xa3, 0xef, 0xc4, 0xc1, 0x7a, 0xd8, 0x49, 0x92, 0x15, 0xc4,
	0x36, 0xa1, 0xca, 0xa7, 0x3c, 0x59, 0x14, 0x6b, 0xc2, 0xa6, 0x23, 0xcf, 0x21, 0x29, 0xe3, 0xc1,
	0x48, 0x0b, 0xac, 0x6c, 0x26, 0x3d, 0x4d, 0x4d, 0x6e, 0x91, 0xcd, 0x39, 0xc2, 0xdb, 0xf3, 0x74,
	0xe8, 0x26, 0x6c, 0x67, 0x53, 0x11, 0x95, 0xa1, 0x00, 0xd6, 0x3f, 0xec, 0xb7, 0x60, 0xab, 0xed,
	0x9e, 0x0f, 0x69, 0x92, 0x78, 0xc1, 0x48, 0x1a, 0xe0, 0x4d, 0xa8, 0xca, 0xdc, 0x56, 0xf8, 0xa4,
	0x5f, 0x80, 0xa5, 0x2e, 0x43, 0xc6, 0x51, 0xeb, 0x6d, 0x58, 0x4e, 0x7d, 0x67, 0x7d, 0xe7, 0x46,
	0xae, 0x0a, 0x2e, 0x01, 0xec, 0x7b, 0xb0, 0xbd, 0x4f, 0x59, 0x5a, 0xcc, 0xd5, 0x84, 0x01, 0x31,
	0x69, 0x2b, 0x70, 0x91, 0x21, 0x6c, 0x31, 0x73, 0x21, 0x00, 0x99, 0x6b, 0x78, 0x36, 0xcb, 0x59,
	0x9e, 0x6d, 0xa8, 0x3f, 0xa1, 0xbe, 0x13, 0x8e, 0x29, 0xb3, 0x0d, 0xe2, 0xde, 0x7e, 0x02, 0xeb,
	0x42, 0xfe, 0x04, 0xb0, 0xb8, 0x3c, 0xb3, 0x38, 0xaf, 0x2f, 0xb2, 0xbf, 0x0f, 0x5b, 0x3d, 0xfa,
	0x42, 0xd9, 0x93, 0x11, 0x66, 0x6c, 0x68, 0xcf, 0xf4, 0xd2, 0x5e, 0x8f, 0xbe, 0x60, 0xab, 0x8a,
	0x4b, 0x7b, 0x5a, 0x64, 0xdd, 0x80, 0xe5, 0x61, 0x18, 0x25, 0x59, 0x7d, 0x14, 0xb5, 0xab, 0x22,
	0xaf, 0x3e, 0xd5, 0xae, 0x15, 0x19, 0x1b, 0x75, 0x62, 0xc6, 0x25, 0x7f, 0x1a, 0x9f, 0x0a, 0x33,
	0xf2, 0x2f, 0x4b, 0xb0, 0x61, 0xec, 0x5d, 0xe0, 0x07, 0x54, 0x1f, 0x34, 0xaf, 0xb2, 0x24, 0x08,
	0xe3, 0xa4, 0x5c, 0x81, 0xc6, 0xa3, 0xc0, 0xf7, 0xb8, 0x79, 0x9c, 0xc6, 0x22, 0x4d, 0xd7, 0x7c,
	0xdd, 0x8a, 0xc4, 0x93, 0xd6, 0xed, 0x56, 0x65, 0xed, 0x32, 0x2d, 0xd2, 0x55, 0xd1, 0xfe, 0x65,
	0x9e, 0x05, 0xc5, 0xa1, 0x76, 0x91, 0x67, 0x41, 0xa4, 0x24, 0x21, 0xe8, 0xab, 0x40, 0xc6, 0xf7,
	0x9d, 0x78, 0x10, 0x3e, 0x0d, 0xe5, 0xb3, 0xd2, 0xdb, 0xb0, 0xda, 0xa3, 0x24, 0x1a, 0xd2, 0x04,
	0x33, 0x75, 0x96, 0x4c, 0xeb, 0xf8, 0xc4, 0xac, 0x5a, 0xe3, 0x5a, 0xd3, 0xbd, 0xef, 0x3a, 0x8a,
	0xee, 0xd7, 0xb0, 0x9d, 0xbb, 0xbb, 0x78, 0x62, 0xed, 0xe8, 0x25, 0x62, 0x21, 0xc3, 0xdf, 0x2b,
	0x2c, 0x7e, 0x4a, 0xbe, 0xa7, 0x41, 0x04, 0x8f, 0x46, 0x1e, 0xc2, 0x26, 0x23, 0x42, 0x09, 0xe9,
	0xe6, 0xc9, 0xc4, 0x05, 0x17, 0x6f, 0x3f, 0x66, 0x42, 0xa8, 0x61, 0x8a, 0x27, 0xd6, 0x07, 0x2c,
	0x25, 0x17, 0x03, 0x8a, 0x9a, 0xe5, 0x0b, 0x49, 0xe9, 0x2a, 0x93, 0xc0, 0xff, 0x11, 0x25, 0xc9,
	0x6c, 0x41, 0xa1, 0xe4, 0xa4, 0x72, 0xb2, 0x94, 0x8b, 0x67, 0x0a, 0x24, 0xa7, 0x20, 0x35, 0x34,
	0x85, 0x29, 0xad, 0xf1, 0x1c, 0x7e, 0xd9, 0x91, 0x66, 0xad, 0x01, 0xcb, 0x5f, 0xf5, 0xd3, 0xc7,
	0xc6, 0x06, 0x2c, 0x77, 0xfb, 0x22, 0xa9, 0xc2, 0x28, 0xe6, 0xab, 0xe3, 0xaf, 0x3b, 0xae, 0x28,
	0x4b, 0xae, 0xc3, 0x4a, 0xf7, 0xdb, 0xdd, 0x61, 0xc7, 0x15, 0x85, 0x1b, 0x55, 0xe0, 0x1a, 0x32,
	0x75, 0x4b, 0x85, 0x72, 0x0d, 0x39, 0x6c, 0x5c, 0xfa, 0x5f, 0x94, 0xe0, 0x1a, 0x37, 0x1e, 0x3d,
	0xfa, 0x62, 0x48, 0x66, 0xa9, 0x67, 0x7a, 0xae, 0x44, 0x97, 0x58, 0xfd, 0x19, 0xd2, 0xc0, 0x35,
	0x22, 0x47, 0x25, 0x5f, 0x2a, 0xcb, 0xf3, 0xed, 0x21, 0xcf, 0x1f, 0x07, 0xde, 0xf3, 0xa9, 0x92,
	0xf7, 0x8b, 0x65, 0x4a, 0xa1, 0x8b, 0xd7, 0x67, 0x27, 0x71, 0xc7, 0x15, 0x57, 0x7b, 0x08, 0x16,
	0x97, 0xd4, 0x38, 0xf6, 0xc2, 0x40, 0x5a, 0x3e, 0xd5, 0xcf, 0x96, 0x73, 0x7e, 0xb6, 0xcc, 0x98,
	0xfc, 0xd5, 0x94, 0x46, 0x33, 0xac, 0x06, 0x94, 0x85, 0x0d, 0xda, 0xce, 0x21, 0x42, 0x29, 0xa9,
	0x2b, 0x43, 0x85, 0x62, 0x6c, 0x80, 0x19, 0x52, 0x52, 0xb0, 0x17, 0x16, 0x78, 0xc8, 0x4b, 0xf9,
	0x70, 0x68, 0xff, 0xb7, 0xa8, 0xd7, 0xaa, 0x48, 0x2e, 0x66, 0xe3, 0xeb, 0xd4, 0xb6, 0x25, 0xdf,
	0x57, 0xd2, 0xb7, 0xc2, 0x98, 0x05, 0x16, 0xa2, 0x68, 0x62, 0x70, 0xbc, 0x9a, 0x7b, 0x58, 0xa8,
	0xe5, 0x0c, 0x14, 0xc8, 0x6a, 0x8b, 0xbc, 0x95, 0x7a, 0x5a, 0x56, 0xcb, 0xde, 0xa6, 0xb0, 0x14,
	0x68, 0x9f, 0x40, 0x33, 0x3b, 0x85, 0x10, 0x18, 0x79, 0x5f, 0xe6, 0x09, 0x4b, 0x5a, 0x8a, 0xb1,
	0x94, 0xbb, 0xc5, 0x42, 0x36, 0xfe, 0x06, 0xac, 0x43, 0x9a, 0x30, 0x46, 0xee, 0x9d, 0x92, 0x44,
	0xa2, 0xbe, 0x0e, 0x1b, 0xa2, 0x2c, 0xf9, 0xbb, 0x61, 0x7f, 0x07, 0xb6, 0xd0, 0xc7, 0x92, 0x48,
	0x11, 0xf6, 0x3c, 0xdd, 0xcc, 0xc9, 0xde, 0x82, 0x0d, 0xfe, 0xec, 0xce, 0xb9, 0x6b, 0x68, 0x85,
	0xfd, 0x43, 0xd8, 0x7a, 0x48, 0x62, 0x1e, 0xd2, 0x71, 0xf3, 0xc1, 0xe3, 0x39, 0x6d, 0x90, 0x47,
	0xd9, 0xf6, 0x7d, 0x58, 0xfb, 0x26, 0x9c, 0x06, 0xa3, 0x3e, 0x89, 0x63, 0x0c, 0xe2, 0xeb, 0x50,
	0x7e, 0x34, 0x49, 0xd4, 0x00, 0x92, 0x4f, 0x88, 0x2c, 0xb1, 0x09, 0x35, 0x7e, 0x33, 0xbd, 0xe9,
	0x58, 0x16, 0x32, 0x4a, 0x22, 0x1f, 0x58, 0x63, 0x3e, 0x97, 0x57, 0x3b, 0xfb, 0x61, 0x5c, 0x6c,
	0xab, 0xfa, 0x61, 0xec, 0x61, 0x5c, 0xc2, 0x2d, 0xdc, 0x3f, 0x94, 0x78, 0xbc, 0x20, 0x72, 0x14,
	0x0e, 0x9c, 0x8b, 0x17, 0x36, 0x60, 0x75, 0x9f, 0xfa, 0xca, 0x63, 0xf9, 0xfb, 0xb0, 0xda, 0x76,
	0xb9, 0x51, 0x2d, 0x5f, 0x2e, 0x75, 0x91, 0x55, 0x59, 0x5e, 0x60, 0xfc, 0x31, 0xd4, 0xfa, 0xa1,
	0xd8, 0xad, 0x59, 0x29, 0x30, 0xcb, 0xda, 0x49, 0xec, 0x5b, 0xb0, 0x86, 0x17, 0x2f, 0xc2, 0x9f,
	0x38, 0xc5, 0xc6, 0xf9, 0xfd, 0x03, 0x5e, 0x76, 0x92, 0xfb, 0xe8, 0x19, 0xbb, 0x92, 0x61, 0x1f,
	0xc0, 0xc6, 0x70, 0x3a, 0x99, 0x84, 0x51, 0xc2, 0x96, 0x4b, 0x55, 0xe6, 0x35, 0x08, 0xce, 0xef,
	0x37, 0xa1, 0xc2, 0xa6, 0x64, 0x42, 0xa6, 0xe7, 0x95, 0x72, 0x0f, 0x7b, 0x08, 0x8d, 0xdd, 0x69,
	0x34, 0xf3, 0x82, 0x51, 0x3f, 0xf4, 0x02, 0x4c, 0xd2, 0x1f, 0x9c, 0x4b, 0xa5, 0xca, 0xd2, 0xee,
	0xac, 0x08, 0xcd, 0xe2, 0x41, 0x12, 0x27, 0x8a, 0x81, 0x50, 0x4b, 0x2f, 0x5c, 0xfc, 0x3e, 0x85,
	0x4d, 0x15, 0x29, 0x52, 0xf7, 0x36, 0x2c, 0x2b, 0xa9, 0xe6, 0x0d, 0x9d, 0x1a, 0x65, 0x31, 0x93,
	0x8a, 0x47, 0xc1, 0x91, 0x17, 0x50, 0x43, 0x2a, 0x98, 0x52, 0xae, 0x74, 0xe3, 0x51, 0xdb, 0x3d,
	0x67, 0xc8, 0xda, 0xee, 0x79, 0x7c, 0x61, 0xb0, 0x69, 0xfd, 0x08, 0x6a, 0x03, 0x6f, 0x74, 0x9a,
	0xa4, 0xf7, 0xbd, 0x30, 0x34, 0xdd, 0x81, 0x35, 0x2e, 0x65, 0xfb, 0x1e, 0x19, 0x87, 0x85, 0x2e,
	0x92, 0x89, 0x0f, 0x9f, 0x14, 0xef, 0xe8, 0x5d, 0xa8, 0xf7, 0xc9, 0x4c, 0xf4, 0xe1, 0xc4, 0x46,
	0x25, 0xe2, 0x7d, 0xa8, 0xca, 0x19, 0xb1, 0xfb, 0x6d, 0x53, 0xb8, 0x7c, 0x92, 0x3c, 0x0b, 0xa3,
	0xb1, 0x58, 0x66, 0x7f, 0x09, 0xdb, 0xd8, 0x77, 0x81, 0xc2, 0xc6, 0xa3, 0x24, 0xa6, 0x92, 0xdb,
	0x50, 0x4f, 0x87, 0x0b, 0x8d, 0x42, 0x25, 0x67, 0x14, 0x2a, 0xf6, 0x19, 0x5c, 0xc9, 0xe3, 0x8a,
	0x27, 0xc5, 0xc8, 0x8c, 0xb8, 0x6d, 0xe9, 0xc2, 0xb8, 0x6d, 0x0d, 0x2a, 0x8e, 0xf2, 0x50, 0xb5,
	0x07, 0x90, 0x22, 0x8d, 0xb3, 0x6e, 0x12, 0x2e, 0xbb, 0x3f, 0x80, 0x0a, 0x8e, 0x0b, 0xb4, 0x66,
	0x0e, 0x25, 0x35, 0xcb, 0xfe, 0x31, 0xd4, 0xf7, 0xe9, 0xb3, 0x69, 0xe0, 0x24, 0xd8, 0xe9, 0x62,
	0xea, 0x6e, 0x56, 0x38, 0xe7, 0x1a, 0xff, 0x87, 0xbc, 0x04, 0xd4, 0xa5, 0xc1, 0x74, 0x7e, 0xa1,
	0x88, 0x7b, 0x0e, 0x96, 0xe4, 0x8a, 0x0c, 0xff, 0x07, 0x50, 0x6e, 0xbb, 0xe7, 0x28, 0xaa, 0x0b,
	0x65, 0x87, 0xc5, 0xeb, 0x7e, 0x98, 0x88, 0x97, 0x83, 0x0f, 0xb1, 0x70, 0x93, 0x6e, 0xf7, 0x26,
	0x54, 0xd8, 0xdf, 0xb8, 0xb0, 0x6a, 0x23, 0x57, 0xd9, 0x2e, 0xac, 0x1c, 0x7b, 0x13, 0x26, 0xb1,
	0x7a, 0x32, 0x7d, 0x05, 0x1a, 0x9d, 0x38, 0x9e, 0xc6, 0x13, 0x1a, 0xc4, 0xd2, 0x80, 0x55, 0x39,
	0xa1, 0x5f, 0x4e, 0xc7, 0x93, 0x57, 0x23, 0xd4, 0xbe, 0x0f, 0xb5, 0xb6, 0xef, 0x8b, 0x8d, 0xde,
	0xd0, 0x54, 0x63, 0x5b, 0xb7, 0x44, 0xb8, 0x64, 0xe7, 0xcf, 0x1f, 0x80, 0x25, 0xc2, 0x64, 0x1e,
	0xca, 0xec, 0x3c, 0x24, 0xbe, 0x6f, 0x7d, 0x0c, 0xd5, 0xc1, 0xc4, 0xc1, 0xb6, 0x2c, 0xeb, 0xaa,
	0x11, 0xfb, 0xf2, 0x4e, 0xb5, 0x56, 0xf1, 0xb0, 0xb5, 0x0b, 0xd6, 0x60, 0xe2, 0xf0, 0xfe, 0x16,
	0xe1, 0x32, 0xe3, 0x91, 0x95, 0x36, 0x0f, 0xf0, 0xc6, 0xb8, 0xfb, 0xc2, 0x06, 0xa6, 0x0f, 0xa4,
	0xad, 0xfa, 0x7d, 0xec, 0xa1, 0x7b, 0x30, 0x9e, 0x24, 0x33, 0xeb, 0x67, 0xd0, 0x18, 0x4c, 0x9c,
	0xb4, 0x5b, 0xca, 0xd2, 0x6d, 0xa8, 0xd6, 0xfd, 0x65, 0x02, 0xae, 0x33, 0xc0, 0x51, 0x44, 0xa9,
	0x00, 0x6d, 0xea, 0xa0, 0x59, 0xef, 0x96, 0x0e, 0xf8, 0x53, 0x58, 0x1b, 0x4c, 0x9c, 0x03, 0x2f,
	0x70, 0x5f, 0x0d, 0xee, 0x27, 0x08, 0xa7, 0x34, 0x64, 0x5d, 0xd7, 0x9f, 0xd1, 0xd2, 0x09, 0x1d,
	0xec, 0xe7, 0xc8, 0x24, 0x31, 0x2b, 0x35, 0xe5, 0x92, 0xb0, 0xbb, 0xb0, 0x3d, 0x98, 0x38, 0x87,
	0x34, 0xe1, 0x94, 0xca, 0xdc, 0x5c, 0x5d, 0xd3, 0x32, 0x2d, 0x4b, 0xdb, 0xf7, 0x53, 0xae, 0xb1,
	0xeb, 0x38, 0x82, 0x5b, 0x83, 0x89, 0xd3, 0xa3, 0x2f, 0x44, 0xa3, 0xd1, 0xef, 0x86, 0xed, 0x10,
	0xee, 0x16, 0x63, 0xeb, 0x4d, 0xc7, 0x85, 0x08, 0xf5, 0xf7, 0xcf, 0xcc, 0xef, 0x7f, 0x06, 0x57,
	0x06, 0x13, 0x87, 0x45, 0x12, 0x3a, 0x35, 0xd7, 0x0d, 0xe9, 0x61, 0x2b, 0xf2, 0x77, 0xd1, 0x43,
	0x68, 0xfe, 0xcc, 0xd1, 0x76, 0xdd, 0x88, 0xc6, 0xf1, 0x6e, 0x18, 0x9e, 0x99, 0x57, 0x99, 0xf5,
	0xd7, 0xb5, 0xbe, 0x67, 0xe0, 0x6d, 0xfb, 0xbe, 0xf2, 0x66, 0xff, 0x73, 0x14, 0xa6, 0x21, 0x4d,
	0xe4, 0x6b, 0x90, 0x75, 0xd3, 0x58, 0x2f, 0x27, 0xf2, 0xb4, 0xfc, 0x02, 0xb6, 0xd8, 0x05, 0x73,
	0x29, 0x7f, 0x75, 0xf0, 0x2f, 0xf0, 0x28, 0x07, 0x21, 0xf3, 0xa4, 0x7d, 0x32, 0x7b, 0x0d, 0x0c,
	0x9f, 0xc3, 0x26, 0x23, 0x00, 0x57, 0xe3, 0xa3, 0x91, 0x4b, 0xad, 0x5b, 0x06, 0xb4, 0x18, 0x17,
	0x5c, 0xd6, 0xe1, 0x7f, 0x89, 0x52, 0x86, 0x25, 0x55, 0x11, 0x36, 0x22, 0x0a, 0x93, 0x00, 0x0e,
	0xcf, 0xcb, 0x3e, 0x3a, 0x82, 0x1f, 0x09, 0x02, 0xc2, 0x38, 0x63, 0x80, 0x26, 0x04, 0xc6, 0x81,
	0xaf, 0xc9, 0xed, 0xf8, 0x0d, 0xc8, 0xa2, 0xa5, 0xa5, 0x47, 0x07, 0x6a, 0xd3, 0xa1, 0xa9, 0x52,
	0x9b, 0xe2, 0xb6, 0x70, 0x49, 0x7b, 0x9a, 0x9c, 0x5e, 0x1a, 0xf6, 0x17, 0xb8, 0x7b, 0xdb, 0x49,
	0xbc, 0x73, 0xda, 0x76, 0xdd, 0x2c, 0x70, 0xb4, 0xae, 0x19, 0xe7, 0x65, 0x53, 0x03, 0xfa, 0x5c,
	0x07, 0x7f, 0x0b, 0x6a, 0xdc, 0x58, 0x3e, 0x9a, 0x26, 0x0b, 0xce, 0xf8, 0x19, 0xe7, 0x08, 0x9e,
	0xf1, 0xd5, 0x2f, 0xf4, 0x13, 0x84, 0x3e, 0x88, 0xe8, 0x77, 0xdf, 0x51, 0x59, 0xde, 0xbe, 0xa4,
	0x91, 0xfa, 0x14, 0xad, 0xcd, 0xe3, 0xe0, 0xb5, 0x80, 0xb9, 0x65, 0x3c, 0xa4, 0x89, 0x50, 0x6e,
	0xfd, 0x80, 0x3a, 0x12, 0xb5, 0x8b, 0xf1, 0x33, 0xd8, 0xe0, 0x70, 0xd8, 0x86, 0x88, 0x61, 0x9f,
	0x06, 0xb9, 0x58, 0xf7, 0xda, 0x08, 0x8d, 0xa0, 0x8f, 0x26, 0x34, 0x22, 0x09, 0xb5, 0x74, 0xa3,
	0x91, 0x36, 0x37, 0xb6, 0xe6, 0x8c, 0x5b, 0x07, 0xe8, 0x44, 0xd2, 0xc6, 0x49, 0xc3, 0x89, 0x68,
	0x0d, 0x95, 0xad, 0x05, 0x73, 0xd6, 0x03, 0x54, 0x65, 0xa6, 0x2b, 0x47, 0x69, 0x33, 0xa1, 0x65,
	0xe9, 0xcc, 0x2b, 0xb6, 0x26, 0x5a, 0xa7, 0xe2, 0x57, 0xa8, 0xd2, 0xf2, 0x9d, 0x32, 0xc3, 0xa4,
	0xbb, 0x51, 0xd9, 0xdf, 0xd3, 0xca, 0x35, 0x15, 0x15, 0x34, 0x3f, 0x0e, 0xf1, 0x5e, 0x0f, 0x69,
	0xa2, 0xf5, 0x34, 0xde, 0x98, 0x5b, 0xaa, 0x6a, 0x5d, 0xa6, 0x53, 0xa9, 0x2d, 0xdd, 0x8b, 0xd6,
	0xea, 0xa4, 0xdf, 0xdd, 0x2d, 0x13, 0x8f, 0xde, 0xb6, 0xc4, 0x6d, 0x8f, 0x48, 0x69, 0x5f, 0x0b,
	0x7e, 0x9b, 0xbb, 0x7f, 0x7d, 0x78, 0x41, 0xa7, 0x94, 0x2e, 0xb2, 0xef, 0x21, 0xfc, 0x3e, 0xf5,
	0x69, 0x42, 0xe7, 0x91, 0xa0, 0x01, 0x7c, 0x00, 0x57, 0x53, 0x80, 0xee, 0xec, 0x52, 0x20, 0x1f,
	0x73, 0x01, 0xf5, 0x02, 0x57, 0xb6, 0x8c, 0x18, 0x0a, 0xa5, 0x74, 0x3b, 0xeb, 0x90, 0x1f, 0x02,
	0xf0, 0xd3, 0xb1, 0x15, 0xaf, 0x06, 0xb4, 0x4f, 0xfd, 0x57, 0x01, 0xda, 0x47, 0x07, 0xc6, 0x54,
	0xf0, 0x62, 0x12, 0xe7, 0xce, 0x58, 0xf7, 0xa1, 0xce, 0x0c, 0xeb, 0x2c, 0x70, 0x58, 0x9e, 0xa7,
	0xb3, 0xc4, 0x32, 0x44, 0xbe, 0x77, 0xdc, 0xb7, 0x3a, 0x9a, 0xa0, 0x67, 0x5d, 0x16, 0xd7, 0xf2,
	0xcd, 0xb9, 0x2c, 0x30, 0x6f, 0xdd, 0x30, 0x85, 0x21, 0x03, 0x69, 0xcb, 0x03, 0xa4, 0x7d, 0x4b,
	0x73, 0xb4, 0xa5, 0x69, 0xe2, 0x48, 0x01, 0xfa, 0x52, 0x9c, 0xf5, 0x56, 0x23, 0x5d, 0x96, 0xb4,
	0xb9, 0xbc, 0x74, 0xea, 0xa0, 0xef, 0x73, 0xd7, 0xee, 0x53, 0x12, 0x31, 0xf5, 0xf1, 0xf3, 0x5c,
	0x59, 0xe7, 0x3f, 0x7a, 0x21, 0x6f, 0x80, 0xb1, 0x7a, 0xa8, 0x0f, 0x03, 0xea, 0x60, 0xd7, 0x19,
	0x9e, 0xdc, 0x5a, 0xd4, 0x90, 0xd2, 0xba, 0x35, 0x67, 0x92, 0x27, 0x3c, 0x22, 0x02, 0x6c, 0xbb,
	0x6e, 0xf6, 0xec, 0xc5, 0x08, 0x2b, 0x48, 0x27, 0x67, 0xca, 0xdb, 0x97, 0xe9, 0x8c, 0x98, 0xed,
	0x90, 0xed, 0x4f, 0x32, 0xd0, 0xd2, 0xef, 0x42, 0x6d, 0x8e, 0xd2, 0xa1, 0xfb, 0xa8, 0x30, 0x6a,
	0xdf, 0x91, 0xfb, 0x6b, 0xe2, 0x7b, 0x0b, 0xbd, 0xb5, 0x5e, 0x7b, 0x34, 0x7b, 0x96, 0x8e, 0x78,
	0xc4, 0xe3, 0x45, 0x71, 0x82, 0xa9, 0xc4, 0x50, 0x70, 0xdb, 0x08, 0x15, 0x65, 0x23, 0x93, 0x81,
	0xcd, 0x6c, 0x37, 0xfa, 0x10, 0x3d, 0x72, 0xdb, 0xf7, 0xfa, 0x64, 0x66, 0xe5, 0xb2, 0x25, 0x1c,
	0x66, 0x39, 0xa6, 0x19, 0x58, 0x33, 0x4f, 0x97, 0x35, 0xc0, 0x58, 0x57, 0x0c, 0x61, 0x43, 0x9b,
	0xd0, 0xba, 0x69, 0x8e, 0xaa, 0xfd, 0x32, 0x3c, 0x8e, 0x51, 0xbb, 0x74, 0x44, 0x1f, 0x89, 0x2e,
	0x21, 0x3a, 0x9b, 0xb4, 0xe6, 0x93, 0x7e, 0x11, 0x86, 0x02, 0xc3, 0xae, 0x4e, 0x1b, 0x34, 0x19,
	0x8d, 0x48, 0xbf, 0x42, 0x81, 0x45, 0x71, 0xc9, 0x06, 0x17, 0x34, 0x22, 0xb5, 0x16, 0xcc, 0x59,
	0xdd, 0xd4, 0x1b, 0x2a, 0x83, 0xfa, 0xf6, 0xfa, 0xe4, 0x62, 0xda, 0x78, 0x9c, 0x6c, 0xb4, 0x3d,
	0xdd, 0x34, 0xbd, 0xb1, 0x8a, 0x4e, 0xbb, 0xb2, 0xa1, 0x12, 0xf2, 0xab, 0x18, 0x6e, 0x6b, 0x18,
	0x72, 0xf3, 0x8b, 0x69, 0xda, 0x41, 0x83, 0x87, 0x02, 0x1a, 0x4e, 0x13, 0xcb, 0x7c, 0x5f, 0xe2,
	0x6a, 0xba, 0x6f, 0x86, 0xdb, 0xd2, 0x52, 0x49, 0x49, 0x30, 0xfa, 0x29, 0xc5, 0x70, 0xab, 0x78,
	0xd8, 0xea, 0xf1, 0x84, 0x90, 0xed, 0x99, 0x35, 0x33, 0x19, 0x8c, 0xd0, 0xbb, 0x9c, 0x5a, 0x8b,
	0x26, 0xad, 0x77, 0xd1, 0x3d, 0xed, 0x4d, 0x93, 0x5d, 0xe2, 0x9c, 0xc5, 0x09, 0xb3, 0xe3, 0xf3,
	0x7d, 0xd9, 0x3d, 0x8c, 0x94, 0xb8, 0xfa, 0xb4, 0x27, 0x93, 0x85, 0x5e, 0x8f, 0xaf, 0x7c, 0x2e,
	0x1a, 0xa1, 0x16, 0x5a, 0x31, 0x0d, 0xf2, 0x23, 0x09, 0x39, 0xec, 0x0e, 0x99, 0x52, 0x5e, 0xcf,
	0xf9, 0x1b, 0x8e, 0xd2, 0x0c, 0xcc, 0xb7, 0xb9, 0xe5, 0x4c, 0x1f, 0xd2, 0x0a, 0xcc, 0x94, 0xda,
	0x5d, 0xa5, 0x83, 0x7f, 0x8d, 0x66, 0xea, 0x20, 0xa2, 0xf1, 0x69, 0xba, 0x08, 0xd9, 0xf3, 0x46,
	0x31, 0x02, 0xa5, 0xf7, 0x2a, 0x17, 0xcd, 0xe9, 0x08, 0x78, 0x02, 0x2f, 0xe8, 0xd9, 0x23, 0xbc,
	0x6b, 0x55, 0x67, 0x9c, 0x59, 0xd8, 0x4a, 0x57, 0x7d, 0x89, 0x42, 0x8b, 0x77, 0x2d, 0xa2, 0xee,
	0x5f, 0x13, 0xcf, 0x57, 0x4a, 0x0e, 0x69, 0x8d, 0x84, 0x8a, 0x10, 0x77, 0xee, 0x8c, 0xb5, 0x8b,
	0xae, 0x85, 0x7f, 0x65, 0x57, 0x78, 0x7d, 0x6f, 0x98, 0x09, 0xcc, 0x0b, 0x4a, 0x93, 0x58, 0xbe,
	0x12, 0xe1, 0x6b, 0x3d, 0xcf, 0xba, 0x45, 0x98, 0xcd, 0x22, 0x1a, 0xde, 0x28, 0x66, 0x5c, 0x51,
	0xd6, 0x3d, 0x66, 0x26, 0x17, 0xdb, 0x3a, 0x34, 0x76, 0x95, 0x5c, 0x12, 0xf8, 0x33, 0x19, 0xa3,
	0x73, 0xb2, 0x72, 0x65, 0x22, 0x3e, 0xdc, 0x71, 0xe3, 0xc2, 0x1c, 0x95, 0x27, 0x09, 0xfc, 0xe0,
	0x02, 0xc1, 0xab, 0x9e, 0xfd, 0x97, 0x68, 0x7f, 0x78, 0xb5, 0xea, 0xc1, 0x38, 0x4c, 0x3c, 0x27,
	0x0c, 0xac, 0x5b, 0x85, 0x8e, 0x54, 0x4e, 0x9b, 0x27, 0x58, 0xe7, 0x27, 0x78, 0x2d, 0xe8, 0x0f,
	0xd1, 0xe5, 0x74, 0x49, 0x24, 0xb2, 0x5e, 0xcb, 0xac, 0x1d, 0xf2, 0x1e, 0x3b, 0x33, 0x57, 0x66,
	0x34, 0x0f, 0xa7, 0xe3, 0x3d, 0xdf, 0x73, 0xce, 0xb0, 0x48, 0x18, 0x1b, 0x16, 0x2f, 0xd7, 0x70,
	0x67, 0xaa, 0x15, 0x63, 0x1c, 0xef, 0xaf, 0xe3, 0x48, 0x2c, 0x3d, 0xe8, 0x31, 0x5b, 0xef, 0x4c,
	0xb5, 0xda, 0xe2, 0x57, 0xae, 0xb4, 0x0a, 0x59, 0x6f, 0xea, 0x3d, 0xed, 0xc5, 0x7d, 0x44, 0x2d,
	0xb3, 0x04, 0x91, 0xad, 0x41, 0x71, 0xfe, 0x03, 0xb8, 0x9e, 0xc3, 0x2c, 0x3e, 0xbe, 0xf8, 0x3f,
	0xc1, 0x7f, 0x04, 0x37, 0x44, 0x6c, 0x3a, 0x3b, 0x20, 0x41, 0x9c, 0x36, 0x16, 0x15, 0x58, 0x6c,
	0xd9, 0x4f, 0x98, 0x8f, 0x2d, 0xd3, 0x86, 0xbd, 0x8e, 0xf4, 0x85, 0xc3, 0x70, 0x4c, 0x45, 0x39,
	0xdc, 0x4c, 0x33, 0xd5, 0x3e, 0x3d, 0x03, 0x95, 0xda, 0x83, 0xd7, 0x46, 0x4b, 0x75, 0x48, 0x13,
	0x2e, 0x07, 0x8f, 0x92, 0x53, 0x1a, 0xf1, 0xd6, 0x38, 0x55, 0xa0, 0x6f, 0xce, 0xcb, 0x99, 0x79,
	0x15, 0x4e, 0x50, 0xa3, 0xf6, 0xe6, 0x35, 0x73, 0xaf, 0x4f, 0x62, 0xa6, 0x35, 0x77, 0x46, 0xb8,
	0x78, 0xa3, 0x07, 0xef, 0x66, 0x3e, 0x7a, 0x4b, 0x27, 0x5b, 0x8b, 0x26, 0xad, 0x07, 0x59, 0xac,
	0xa8, 0x37, 0xe7, 0x69, 0x47, 0xbb, 0x93, 0x47, 0xa1, 0xaf, 0x7e, 0x80, 0x71, 0xd1, 0x70, 0xfa,
	0x74, 0xec, 0x25, 0xfa, 0xcc, 0x6d, 0xe3, 0xcb, 0x05, 0xa3, 0xb5, 0xce, 0x2c, 0x13, 0x61, 0x30,
	0x24, 0x2e, 0x5e, 0x68, 0x9d, 0x69, 0x5f, 0x71, 0xba, 0xa8, 0x2a, 0xc7, 0xa4, 0xf3, 0xc1, 0x70,
	0x12, 0x46, 0xc9, 0xeb, 0x61, 0x68, 0x43, 0x6b, 0x30, 0x71, 0xbe, 0x25, 0x81, 0xb0, 0x97, 0xc3,
	0xe7, 0x53, 0x12, 0xa5, 0xa2, 0x63, 0x16, 0x9b, 0xbe, 0x25, 0x05, 0x28, 0x1e, 0x20, 0x0a, 0x1e,
	0xfc, 0x8f, 0x69, 0x90, 0xe8, 0x28, 0xf2, 0xa1, 0x1b, 0x2e, 0xca, 0xf3, 0xe1, 0x0b, 0x44, 0x83,
	0xb1, 0x55, 0x01, 0x9a, 0xab, 0x06, 0x25, 0x45, 0x45, 0xb3, 0x7d, 0x5e, 0x34, 0x73, 0x5d, 0x0e,
	0x2a, 0xf0, 0x7c, 0x4b, 0xf2, 0x16, 0x50, 0x21, 0xe2, 0x5b, 0x12, 0x98, 0x81, 0x93, 0xc8, 0xd5,
	0xcd, 0x73, 0x98, 0xde, 0x17, 0xed, 0x50, 0x9e, 0x0a, 0x02, 0x37, 0x99, 0x58, 0xcc, 0xe9, 0xf4,
	0x33, 0xe4, 0x5f, 0xe9, 0x1a, 0x6c, 0xdd, 0xd3, 0x43, 0xc4, 0x05, 0xad, 0x82, 0x7d, 0x59, 0x01,
	0x6b, 0xbb, 0xe7, 0xa8, 0x93, 0x86, 0xad, 0x35, 0xdb, 0xe4, 0x0c, 0x59, 0x2e, 0xe8, 0x8f, 0x3b,
	0x92, 0xaa, 0x9a, 0x95, 0x1a, 0x76, 0x16, 0xd5, 0x6d, 0xbe, 0x57, 0x50, 0xf9, 0xc8, 0xbe, 0x90,
	0xfb, 0x7f, 0x32, 0xe1, 0x66, 0x13, 0xca, 0x17, 0xa6, 0x77, 0xe6, 0x22, 0xe4, 0x0b, 0x8c, 0x72,
	0x50, 0xf1, 0x37, 0x6f, 0x3f, 0x91, 0x4f, 0x31, 0x6d, 0xf7, 0xfc, 0x28, 0x1c, 0x59, 0xcd, 0xfc,
	0xd3, 0xd3, 0x51, 0x38, 0xca, 0x95, 0x44, 0xf7, 0xe5, 0xb5, 0x6a, 0xbd, 0x7d, 0xd6, 0x5d, 0x33,
	0xb2, 0x37, 0x5b, 0xff, 0xcc, 0xf0, 0x7e, 0x8b, 0x3f, 0x2c, 0x28, 0x6d, 0x78, 0x06, 0xf7, 0x73,
	0x3d, 0x7a, 0xad, 0xdb, 0x39, 0xc3, 0xa6, 0x37, 0x0d, 0x3e, 0xc1, 0xd0, 0xcd, 0x6c, 0xe1, 0xba,
	0xb3, 0xa8, 0xc1, 0x8b, 0xa1, 0xbd, 0xbb, 0x78, 0x41, 0x3c, 0xb1, 0xbe, 0xc2, 0x58, 0x4c, 0xef,
	0xab, 0xba, 0x35, 0xbf, 0x29, 0x2b, 0x4f, 0x6b, 0xbe, 0xd5, 0xeb, 0x0b, 0xc1, 0x00, 0x12, 0x65,
	0xbd, 0x4a, 0xb9, 0x3c, 0xdf, 0xe8, 0xc0, 0xd1, 0x59, 0xc8, 0x4f, 0x6b, 0x36, 0xe9, 0xdc, 0x59,
	0xd4, 0x07, 0x94, 0x3f, 0x6d, 0x51, 0x7f, 0x91, 0x03, 0x4d, 0x4c, 0xbd, 0x0a, 0x1a, 0x63, 0xac,
	0xb7, 0x8c, 0xf4, 0xab, 0xb8, 0x79, 0xe6, 0x12, 0x9b, 0x3c, 0x91, 0x15, 0x4e, 0xb5, 0x39, 0xc6,
	0xa0, 0x3e, 0xdf, 0x3a, 0x73, 0x09, 0xc4, 0x5f, 0xc8, 0xbc, 0x53, 0xe9, 0x8b, 0x31, 0x24, 0x2b,
	0xd7, 0x34, 0x63, 0x3e, 0x90, 0x60, 0x51, 0xdd, 0x68, 0x97, 0xd1, 0x35, 0xd5, 0x98, 0x2d, 0xb2,
	0x7c, 0x43, 0x9a, 0xe8, 0x7d, 0x32, 0x7a, 0xfc, 0xa0, 0xcd, 0x15, 0x3d, 0x08, 0x30, 0x12, 0x5f,
	0x43, 0x3b, 0x9b, 0x85, 0xd1, 0x06, 0x53, 0x84, 0xcb, 0x07, 0x1c, 0xbf, 0x94, 0xa5, 0x35, 0x3e,
	0x24, 0x7b, 0x58, 0x2e, 0x8f, 0xe0, 0x91, 0x2c, 0x75, 0xf0, 0x21, 0xa5, 0x0f, 0xa6, 0x95, 0xbf,
	0x61, 0x39, 0x97, 0xd5, 0x4e, 0x64, 0xcd, 0x31, 0x03, 0xfb, 0x5a, 0x22, 0xcc, 0xc2, 0x19, 0xd1,
	0xf9, 0x73, 0x7b, 0x5e, 0xb4, 0xc3, 0xe7, 0x5b, 0x17, 0xcc, 0x5b, 0x43, 0x19, 0x9f, 0x99, 0x8d,
	0x36, 0xfa, 0x85, 0x1b, 0xb3, 0xad, 0x85, 0xb3, 0xd6, 0x4f, 0xe5, 0x13, 0x89, 0xd2, 0xe3, 0x32,
	0xff, 0x99, 0x34, 0x5b, 0xf4, 0x71, 0x5a, 0x61, 0x8d, 0x47, 0xcc, 0x48, 0xb3, 0x5b, 0xce, 0x95,
	0x98, 0xf4, 0xd7, 0x7e, 0xd1, 0x2b, 0xf3, 0xb1, 0x74, 0x65, 0xb2, 0xa9, 0x45, 0x03, 0xd1, 0xb9,
	0xae, 0x77, 0xbf, 0x74, 0x31, 0xf6, 0xc9, 0x18, 0x90, 0xf5, 0xb9, 0x18, 0x3e, 0x56, 0x69, 0x80,
	0x69, 0xcd, 0x9d, 0xb1, 0x3e, 0x91, 0x1e, 0xb0, 0xed, 0xfb, 0xf8, 0xf9, 0x21, 0x93, 0x07, 0x23,
	0x7d, 0xd6, 0xaf, 0x39, 0x5d, 0xf5, 0x31, 0x4f, 0x7f, 0xa4, 0xd4, 0xe0, 0xf8, 0xdc, 0x32, 0xa1,
	0x26, 0xf6, 0x3c, 0xbb, 0x30, 0xdb, 0x60, 0x0a, 0x1c, 0x53, 0x41, 0xd7, 0x4d, 0xeb, 0x8d, 0x0b,
	0x56, 0xc4, 0x13, 0x6b, 0x5f, 0xbe, 0x7b, 0x28, 0xcd, 0x2f, 0xd7, 0x8b, 0xc1, 0xe2, 0xd6, 0xbc,
	0x09, 0x51, 0xb5, 0x57, 0x5b, 0x5f, 0x8c, 0xb4, 0x21, 0x9b, 0x69, 0xcd, 0x9d, 0x11, 0x71, 0x2e,
	0x67, 0x70, 0xda, 0xa8, 0xb2, 0xe0, 0xe9, 0x4e, 0x5d, 0xf6, 0x33, 0x79, 0x8e, 0xb4, 0x93, 0x24,
	0x5e, 0x24, 0x98, 0x59, 0xbf, 0xc9, 0xcf, 0xa5, 0xfe, 0xe1, 0x17, 0xab, 0xaf, 0x24, 0x9a, 0x3b,
	0x7f, 0xb9, 0x95, 0x36, 0xa2, 0x3c, 0x24, 0xbe, 0xbf, 0xc3, 0x9f, 0xae, 0x45, 0xd8, 0x2f, 0xae,
	0x3a, 0x1c, 0x79, 0x41, 0x1a, 0x44, 0x2d, 0x32, 0x2d, 0xb9, 0x12, 0x3c, 0x17, 0x7c, 0xe5, 0xff,
	0x14, 0xba, 0x5e, 0x60, 0xa8, 0xd9, 0x44, 0x0e, 0xf2, 0x1d, 0x7c, 0x79, 0x19, 0x50, 0xde, 0x0b,
	0xb3, 0xb0, 0xce, 0xcf, 0x97, 0xfe, 0xca, 0x73, 0xce, 0x72, 0x0f, 0xc1, 0xe6, 0xd2, 0x7d, 0xee,
	0x96, 0x31, 0xcd, 0xce, 0xfa, 0x5c, 0x2e, 0x68, 0xb4, 0xc8, 0x61, 0x79, 0x88, 0x56, 0xc9, 0xc0,
	0xc2, 0xa3, 0x99, 0xdc, 0x7f, 0x3c, 0xc4, 0xb1, 0xc8, 0x10, 0xd5, 0xc4, 0xc4, 0x1b, 0x0e, 0x04,
	0xa6, 0xa2, 0xf6, 0x19, 0xf9, 0x3e, 0x3d, 0x97, 0x16, 0x5e, 0xaa, 0xcb, 0x9a, 0x56, 0xc4, 0x5b,
	0x45, 0xd1, 0x03, 0x7a, 0x11, 0x38, 0x7f, 0xbe, 0x17, 0x8f, 0xef, 0xaf, 0x08, 0xcb, 0x93, 0xe7,
	0xac, 0x79, 0x27, 0x15, 0x91, 0xcb, 0x53, 0xbf, 0xcb, 0x93, 0x99, 0xec, 0xe4, 0xaf, 0x81, 0x63,
	0x07, 0x39, 0xc0, 0x79, 0x38, 0xef, 0x0d, 0xd1, 0x84, 0x39, 0xc2, 0x7d, 0xb5, 0xa7, 0x21, 0x71,
	0x78, 0x3b, 0xf7, 0xed, 0x3b, 0x5f, 0xa3, 0x3c, 0x04, 0xe5, 0xb0, 0x1d, 0xe6, 0xb1, 0x1d, 0x78,
	0x81, 0x17, 0x9f, 0xe6, 0x52, 0x32, 0xb9, 0x86, 0x4f, 0x17, 0x70, 0x94, 0x89, 0x67, 0xfa, 0xda,
	0x2c, 0x22, 0xe7, 0x9b, 0xf3, 0x1e, 0xb8, 0x8b, 0xb8, 0xf1, 0x09, 0x3a, 0x37, 0xfe, 0xd6, 0x22,
	0x8e, 0x74, 0xd9, 0x87, 0x98, 0x1e, 0x0f, 0x2d, 0x4f, 0xc3, 0x49, 0x27, 0xa1, 0x63, 0x11, 0x80,
	0x09, 0x1a, 0x4c, 0xb6, 0x18, 0xab, 0xd0, 0xe8, 0x9b, 0xa4, 0x7c, 0xca, 0x2d, 0x2a, 0xf1, 0x0e,
	0xa6, 0x29, 0x25, 0x73, 0xdf, 0xb9, 0x4c, 0xe0, 0x8f, 0x64, 0x0d, 0x99, 0x7e, 0x47, 0x53, 0x33,
	0x74, 0xa1, 0x7e, 0x73, 0x91, 0x54, 0x9f, 0x87, 0xc5, 0xce, 0xf3, 0x5f, 0x60, 0xf3, 0x0a, 0x65,
	0xa9, 0xb5, 0x76, 0x01, 0x3f, 0xb7, 0x6e, 0x6e, 0x82, 0x1f, 0x08, 0x59, 0x60, 0x3f, 0xf4, 0xda,
	0xf5, 0xc2, 0xca, 0x76, 0x0e, 0xcf, 0x23, 0x2c, 0x99, 0x19, 0xa2, 0x20, 0xea, 0x8b, 0x96, 0x6d,
	0x4a, 0x04, 0x1f, 0x57, 0x4b, 0xac, 0x05, 0xa6, 0x8f, 0x57, 0x6d, 0x47, 0x5e, 0x9c, 0xd0, 0xa8,
	0x3f, 0x8d, 0x4f, 0xad, 0x8b, 0x0b, 0xb5, 0x39, 0x2c, 0xbc, 0x99, 0x26, 0x35, 0x7d, 0x68, 0xd3,
	0x73, 0x8d, 0x5e, 0xf2, 0x5b, 0xe9, 0x02, 0x1a, 0xae, 0xe2, 0x9b, 0x76, 0xdc, 0x27, 0x11, 0x19,
	0xd3, 0x24, 0x8d, 0x13, 0xcd, 0x07, 0x0d, 0x75, 0x49, 0x81, 0xd1, 0xd8, 0xe6, 0x0f, 0x86, 0x22,
	0xac, 0x49, 0x71, 0xbc, 0x82, 0x63, 0xe2, 0x8f, 0x8e, 0x3d, 0xfa, 0x42, 0x26, 0x21, 0x6f, 0x98,
	0xe9, 0x6d, 0xee, 0x13, 0xca, 0x1c, 0x8e, 0xfb, 0xa2, 0x9c, 0xab, 0x60, 0x59, 0x28, 0x9c, 0x0f,
	0x51, 0xb2, 0xd2, 0x92, 0xc7, 0x02, 0xcd, 0x52, 0xe6, 0x0b, 0xf9, 0x78, 0x80, 0x6e, 0x23, 0x9f,
	0x63, 0x5f, 0x90, 0x83, 0xe7, 0xf0, 0x74, 0x51, 0x58, 0x0b, 0x3e, 0xcc, 0xb1, 0xbe, 0x9f, 0xab,
	0x4b, 0xe7, 0x3f, 0xdd, 0x29, 0x60, 0x2a, 0x13, 0x0e, 0xed, 0xb3, 0x04, 0x83, 0xa4, 0xdc, 0x77,
	0x0c, 0x26, 0x8e, 0xdd, 0xc6, 0xbf, 0xff, 0xf6, 0x76, 0xe9, 0x3f, 0x7e, 0x7b, 0xbb, 0xf4, 0x9f,
	0xbf, 0xbd, 0x5d, 0xfa, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc9, 0x03, 0xda, 0x61, 0xb3, 0x52,
	0x00, 0x00,
}

func (m *LoginMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account == nil {
		return 0, github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("Account")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Account)))
		i += copy(dAtA[i:], *m.Account)
	}
	if m.Token != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Token)))
		i += copy(dAtA[i:], *m.Token)
	}
	if m.RegistrationId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.RegistrationId)))
		i += copy(dAtA[i:], *m.RegistrationId)
	}
	if m.Channel != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Channel)))
		i += copy(dAtA[i:], *m.Channel)
	}
	if m.LoginType != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.LoginType))
	}
	if m.DeviceType != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.DeviceType))
	}
	if m.Type != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.VersionNumber != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.VersionNumber)))
		i += copy(dAtA[i:], *m.VersionNumber)
	}
	if m.Brand != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Brand)))
		i += copy(dAtA[i:], *m.Brand)
	}
	if m.IsAppAct != nil {
		dAtA[i] = 0x58
		i++
		if *m.IsAppAct {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsUserReg != nil {
		dAtA[i] = 0x60
		i++
		if *m.IsUserReg {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsLoginMan != nil {
		dAtA[i] = 0x68
		i++
		if *m.IsLoginMan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsLoginFreq != nil {
		dAtA[i] = 0x70
		i++
		if *m.IsLoginFreq {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateGold) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGold) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gold != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Gold))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddPlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account == nil {
		return 0, github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("Account")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Account)))
		i += copy(dAtA[i:], *m.Account)
	}
	if m.Type != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.Text != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Text)))
		i += copy(dAtA[i:], *m.Text)
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Mark != nil {
		dAtA[i] = 0x28
		i++
		if *m.Mark {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AccountInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Account)))
		i += copy(dAtA[i:], *m.Account)
	}
	if m.Type != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddBookInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddBookInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhoneList) > 0 {
		for _, s := range m.PhoneList {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateTeam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTeam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mark != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Mark))
	}
	if len(m.PlayerList) > 0 {
		for _, num := range m.PlayerList {
			dAtA[i] = 0x10
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(num))
		}
	}
	if m.TeamName != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.TeamName)))
		i += copy(dAtA[i:], *m.TeamName)
	}
	if m.AdminId != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.AdminId))
	}
	if m.HeadUrl != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.HeadUrl)))
		i += copy(dAtA[i:], *m.HeadUrl)
	}
	if m.Topic != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Topic)))
		i += copy(dAtA[i:], *m.Topic)
	}
	if m.TopicDesc != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.TopicDesc)))
		i += copy(dAtA[i:], *m.TopicDesc)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PeopleIdInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeopleIdInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.PeopleId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.PeopleId)))
		i += copy(dAtA[i:], *m.PeopleId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BankMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BankMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserName != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.UserName)))
		i += copy(dAtA[i:], *m.UserName)
	}
	if m.IdType != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.IdType)))
		i += copy(dAtA[i:], *m.IdType)
	}
	if m.IdNo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.IdNo)))
		i += copy(dAtA[i:], *m.IdNo)
	}
	if m.BankCardNo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.BankCardNo)))
		i += copy(dAtA[i:], *m.BankCardNo)
	}
	if m.MobileNo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.MobileNo)))
		i += copy(dAtA[i:], *m.MobileNo)
	}
	if m.ExpireDate != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.ExpireDate)))
		i += copy(dAtA[i:], *m.ExpireDate)
	}
	if m.Cvv != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Cvv)))
		i += copy(dAtA[i:], *m.Cvv)
	}
	if m.BankCode != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.BankCode)))
		i += copy(dAtA[i:], *m.BankCode)
	}
	if m.JPOrderNo != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.JPOrderNo)))
		i += copy(dAtA[i:], *m.JPOrderNo)
	}
	if m.OrderNo != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.OrderNo)))
		i += copy(dAtA[i:], *m.OrderNo)
	}
	if m.MsgCode != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.MsgCode)))
		i += copy(dAtA[i:], *m.MsgCode)
	}
	if m.SignNo != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.SignNo)))
		i += copy(dAtA[i:], *m.SignNo)
	}
	if m.Provice != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Provice)))
		i += copy(dAtA[i:], *m.Provice)
	}
	if m.City != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.City)))
		i += copy(dAtA[i:], *m.City)
	}
	if m.Area != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Area)))
		i += copy(dAtA[i:], *m.Area)
	}
	if m.IsModify != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if *m.IsModify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VersionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Version)))
		i += copy(dAtA[i:], *m.Version)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DelFriendInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelFriendInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.IsBlack != nil {
		dAtA[i] = 0x10
		i++
		if *m.IsBlack {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlackInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlackInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MoneyAssistantInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoneyAssistantInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LogId == nil {
		return 0, github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("LogId")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.LogId))
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.ChangeGold != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.ChangeGold))
	}
	if m.SourceType != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.SourceType))
	}
	if m.Note != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Note)))
		i += copy(dAtA[i:], *m.Note)
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.CreateTime))
	}
	if m.Gold != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Gold))
	}
	if m.OrderId != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.OrderId)))
		i += copy(dAtA[i:], *m.OrderId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllMoneyAssistantInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllMoneyAssistantInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, msg := range m.Info {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != nil {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.X))))
		i += 8
	}
	if m.Y != nil {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Y))))
		i += 8
	}
	if m.Province != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Province)))
		i += copy(dAtA[i:], *m.Province)
	}
	if m.City != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.City)))
		i += copy(dAtA[i:], *m.City)
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Type != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.Area != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Area)))
		i += copy(dAtA[i:], *m.Area)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocationInfoByPage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationInfoByPage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != nil {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.X))))
		i += 8
	}
	if m.Y != nil {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Y))))
		i += 8
	}
	if m.Province != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Province)))
		i += copy(dAtA[i:], *m.Province)
	}
	if m.City != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.City)))
		i += copy(dAtA[i:], *m.City)
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Type != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.Area != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Area)))
		i += copy(dAtA[i:], *m.Area)
	}
	if m.Page != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.PageSize != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PageSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllLocationPlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllLocationPlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlayerInfo) > 0 {
		for _, msg := range m.PlayerInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocationPlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationPlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Sex != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Sex))
	}
	if m.Distance != nil {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Distance))))
		i += 8
	}
	if m.Signature != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Signature)))
		i += copy(dAtA[i:], *m.Signature)
	}
	if m.IsFriend != nil {
		dAtA[i] = 0x28
		i++
		if *m.IsFriend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HeadIcon != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.HeadIcon)))
		i += copy(dAtA[i:], *m.HeadIcon)
	}
	if m.Name != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Province != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Province)))
		i += copy(dAtA[i:], *m.Province)
	}
	if m.City != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.City)))
		i += copy(dAtA[i:], *m.City)
	}
	if m.Account != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Account)))
		i += copy(dAtA[i:], *m.Account)
	}
	if m.Photo != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Photo)))
		i += copy(dAtA[i:], *m.Photo)
	}
	if m.Area != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Area)))
		i += copy(dAtA[i:], *m.Area)
	}
	if m.Types != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Types))
	}
	if len(m.LabelInfo) > 0 {
		for _, msg := range m.LabelInfo {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NearByMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NearByMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId == nil {
		return 0, github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("PlayerId")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Content != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Content)))
		i += copy(dAtA[i:], *m.Content)
	}
	if m.NickName != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.NickName)))
		i += copy(dAtA[i:], *m.NickName)
	}
	if m.HeadIcon != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.HeadIcon)))
		i += copy(dAtA[i:], *m.HeadIcon)
	}
	if m.Sex != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Sex))
	}
	if m.Provice != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Provice)))
		i += copy(dAtA[i:], *m.Provice)
	}
	if m.City != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.City)))
		i += copy(dAtA[i:], *m.City)
	}
	if m.Photo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Photo)))
		i += copy(dAtA[i:], *m.Photo)
	}
	if m.Account != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Account)))
		i += copy(dAtA[i:], *m.Account)
	}
	if m.Time != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Time))
	}
	if m.IsAdd != nil {
		dAtA[i] = 0x58
		i++
		if *m.IsAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Signature != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Signature)))
		i += copy(dAtA[i:], *m.Signature)
	}
	if m.Types != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Types))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllNearByMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllNearByMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NearByMessage) > 0 {
		for _, msg := range m.NearByMessage {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NearByInfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NearByInfoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllNearByInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(m.AllNearByInfo.Size()))
		n1, err := m.AllNearByInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.AllNewNearByInfo) > 0 {
		for _, msg := range m.AllNewNearByInfo {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NearByInfoReplyByPage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NearByInfoReplyByPage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllNearByInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(m.AllNearByInfo.Size()))
		n2, err := m.AllNearByInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.AllNewNearByInfo) > 0 {
		for _, msg := range m.AllNewNearByInfo {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PageInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Page != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.Num != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MoneyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoneyType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.Year != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Year))
	}
	if m.Month != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Month))
	}
	if m.Page != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.Num != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Time != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Time))
	}
	if m.Money != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Money))
	}
	if m.HeadIcon != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.HeadIcon)))
		i += copy(dAtA[i:], *m.HeadIcon)
	}
	if m.Type != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.Statue != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Statue))
	}
	if m.Text != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Text)))
		i += copy(dAtA[i:], *m.Text)
	}
	if m.OrderId != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.OrderId)))
		i += copy(dAtA[i:], *m.OrderId)
	}
	if m.RedPacket != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(m.RedPacket.Size()))
		n3, err := m.RedPacket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.PayName != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.PayName)))
		i += copy(dAtA[i:], *m.PayName)
	}
	if m.ServiceCharge != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.ServiceCharge))
	}
	if m.ReceiveTime != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.ReceiveTime))
	}
	if m.TransferText != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.TransferText)))
		i += copy(dAtA[i:], *m.TransferText)
	}
	if m.ShopName != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.ShopName)))
		i += copy(dAtA[i:], *m.ShopName)
	}
	if m.BankName != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.BankName)))
		i += copy(dAtA[i:], *m.BankName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllOrderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllOrderInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderInfo) > 0 {
		for _, msg := range m.OrderInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CashInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CashInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrderId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.OrderId)))
		i += copy(dAtA[i:], *m.OrderId)
	}
	if m.Time != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Time))
	}
	if m.ChangeGold != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.ChangeGold))
	}
	if m.Gold != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Gold))
	}
	if m.Type != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllCashInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllCashInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CashInfo) > 0 {
		for _, msg := range m.CashInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RedPacketInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedPacketInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.Year != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Year))
	}
	if m.Month != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Month))
	}
	if m.Page != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.Num != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllRedPacketInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllRedPacketInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllInfo) > 0 {
		for _, msg := range m.AllInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LuckCnt != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.LuckCnt))
	}
	if m.TotalCnt != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.TotalCnt))
	}
	if m.TotalGold != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.TotalGold))
	}
	if m.Type != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WithdrawInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BankCode != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.BankCode)))
		i += copy(dAtA[i:], *m.BankCode)
	}
	if m.AccountType != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.AccountType)))
		i += copy(dAtA[i:], *m.AccountType)
	}
	if m.AccountNo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.AccountNo)))
		i += copy(dAtA[i:], *m.AccountNo)
	}
	if m.AccountName != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.AccountName)))
		i += copy(dAtA[i:], *m.AccountName)
	}
	if m.AccountProp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.AccountProp)))
		i += copy(dAtA[i:], *m.AccountProp)
	}
	if m.Amount != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Amount))
	}
	if m.Result != nil {
		dAtA[i] = 0x38
		i++
		if *m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OrderId != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.OrderId)))
		i += copy(dAtA[i:], *m.OrderId)
	}
	if m.StartTime != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.StartTime))
	}
	if m.Tax != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Tax))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckPeopleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckPeopleInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirstInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirstInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Password != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Password)))
		i += copy(dAtA[i:], *m.Password)
	}
	if len(m.Label) > 0 {
		for _, num := range m.Label {
			dAtA[i] = 0x10
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(num))
		}
	}
	if m.Sex != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Sex))
	}
	if m.NickName != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.NickName)))
		i += copy(dAtA[i:], *m.NickName)
	}
	if m.Signature != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Signature)))
		i += copy(dAtA[i:], *m.Signature)
	}
	if m.HeadIcon != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.HeadIcon)))
		i += copy(dAtA[i:], *m.HeadIcon)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirstReturnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirstReturnInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.Content != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Content)))
		i += copy(dAtA[i:], *m.Content)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PayInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Gold != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Gold))
	}
	if m.Type != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.Content != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Content)))
		i += copy(dAtA[i:], *m.Content)
	}
	if m.PayOrderInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(m.PayOrderInfo.Size()))
		n4, err := m.PayOrderInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.IsWay != nil {
		dAtA[i] = 0x30
		i++
		if *m.IsWay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Password != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Password)))
		i += copy(dAtA[i:], *m.Password)
	}
	if m.BankInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.BankInfo)))
		i += copy(dAtA[i:], *m.BankInfo)
	}
	if m.OrderId != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.OrderId)))
		i += copy(dAtA[i:], *m.OrderId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllCollectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllCollectInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CollectInfo) > 0 {
		for _, msg := range m.CollectInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DelCollectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelCollectInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Index))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetCollectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCollectInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Page != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.Num != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Num))
	}
	if m.Type != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SearchCollectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchCollectInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Content)))
		i += copy(dAtA[i:], *m.Content)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PayForCodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayForCodeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Gold != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Gold))
	}
	if m.Name != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.HeadIcon != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.HeadIcon)))
		i += copy(dAtA[i:], *m.HeadIcon)
	}
	if m.TeamId != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.TeamId))
	}
	if m.FailReason != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.FailReason)))
		i += copy(dAtA[i:], *m.FailReason)
	}
	if m.Code != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Code)))
		i += copy(dAtA[i:], *m.Code)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("type")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UnGetMoneyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnGetMoneyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TargetId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.TargetId))
	}
	if m.IsHave != nil {
		dAtA[i] = 0x10
		i++
		if *m.IsHave {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Type != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CollectIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IndexList) > 0 {
		for _, num := range m.IndexList {
			dAtA[i] = 0x8
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BankPaySMS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BankPaySMS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrderNo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.OrderNo)))
		i += copy(dAtA[i:], *m.OrderNo)
	}
	if m.SMS != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.SMS)))
		i += copy(dAtA[i:], *m.SMS)
	}
	if m.PayId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PayId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RecommendMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlayerIds) > 0 {
		for _, num := range m.PlayerIds {
			dAtA[i] = 0x8
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RecommendRefreshInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendRefreshInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddGoldInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddGoldInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gold != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Gold))
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WechatInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WechatInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Code)))
		i += copy(dAtA[i:], *m.Code)
	}
	if m.Type != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.PhoneCode != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.PhoneCode)))
		i += copy(dAtA[i:], *m.PhoneCode)
	}
	if m.ApkCode != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.ApkCode))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MarkName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ArticleOptRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArticleOptRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ArticleId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.ArticleId))
	}
	if m.Type != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NoticeOptRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoticeOptRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Id))
	}
	if m.Type != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MainInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Page != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.Count != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FansInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FansInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Sex != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Sex))
	}
	if m.Signature != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Signature)))
		i += copy(dAtA[i:], *m.Signature)
	}
	if m.Name != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.HeadIcon != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.HeadIcon)))
		i += copy(dAtA[i:], *m.HeadIcon)
	}
	if m.Types != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Types))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllFansInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllFansInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FansInfo) > 0 {
		for _, msg := range m.FansInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DynamicIdInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicIdInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.LogId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.LogId))
	}
	if m.Type != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DynamicInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DynamicData) > 0 {
		for _, msg := range m.DynamicData {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TeamMembers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamMembers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.TeamId))
	}
	if len(m.Members) > 0 {
		for _, msg := range m.Members {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Way != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Way))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckDirtyWord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckDirtyWord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Words) > 0 {
		for _, s := range m.Words {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DirtyWords) > 0 {
		for _, s := range m.DirtyWords {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckCancelAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckCancelAccount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ThirtyDays != nil {
		dAtA[i] = 0x8
		i++
		if *m.ThirtyDays {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PhoneState != nil {
		dAtA[i] = 0x10
		i++
		if *m.PhoneState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PeopleIdState != nil {
		dAtA[i] = 0x18
		i++
		if *m.PeopleIdState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AccountState != nil {
		dAtA[i] = 0x20
		i++
		if *m.AccountState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TradeState != nil {
		dAtA[i] = 0x28
		i++
		if *m.TradeState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BalanceState != nil {
		dAtA[i] = 0x30
		i++
		if *m.BalanceState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FriendState != nil {
		dAtA[i] = 0x38
		i++
		if *m.FriendState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CancelAccountData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelAccountData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RealName != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.RealName)))
		i += copy(dAtA[i:], *m.RealName)
	}
	if m.PeopleId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.PeopleId)))
		i += copy(dAtA[i:], *m.PeopleId)
	}
	if m.PeopleIdBeforeUrl != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.PeopleIdBeforeUrl)))
		i += copy(dAtA[i:], *m.PeopleIdBeforeUrl)
	}
	if m.PeopleIdBackUrl != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.PeopleIdBackUrl)))
		i += copy(dAtA[i:], *m.PeopleIdBackUrl)
	}
	if m.PeopleIdHandUrl != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.PeopleIdHandUrl)))
		i += copy(dAtA[i:], *m.PeopleIdHandUrl)
	}
	if m.PhoneCode != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.PhoneCode)))
		i += copy(dAtA[i:], *m.PhoneCode)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OpenMyMainPageByPageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenMyMainPageByPageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Page != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.PageSize != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PageSize))
	}
	if m.PlayerId == nil {
		return 0, github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("PlayerId")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NewUnReadMessageResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewUnReadMessageResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UnreadComment != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.UnreadComment))
	}
	if m.UnreadZan != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.UnreadZan))
	}
	if m.UnreadAttention != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.UnreadAttention))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ComplaintID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplaintID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ComplaintId == nil {
		return 0, github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("ComplaintId")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.ComplaintId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShopOrderComplaintDetailRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopOrderComplaintDetailRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SponsorNickname != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.SponsorNickname)))
		i += copy(dAtA[i:], *m.SponsorNickname)
	}
	if m.SponsorAvatar != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.SponsorAvatar)))
		i += copy(dAtA[i:], *m.SponsorAvatar)
	}
	if m.ItemFile != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(m.ItemFile.Size()))
		n5, err := m.ItemFile.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.ItemName != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.ItemName)))
		i += copy(dAtA[i:], *m.ItemName)
	}
	if m.ItemTitle != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.ItemTitle)))
		i += copy(dAtA[i:], *m.ItemTitle)
	}
	if m.OrderCreateTime != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.OrderCreateTime))
	}
	if m.OrderId != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.OrderId))
	}
	if m.ComplaintAvatar != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.ComplaintAvatar)))
		i += copy(dAtA[i:], *m.ComplaintAvatar)
	}
	if m.ComplaintNickname != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.ComplaintNickname)))
		i += copy(dAtA[i:], *m.ComplaintNickname)
	}
	if m.ComplaintContent != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.ComplaintContent)))
		i += copy(dAtA[i:], *m.ComplaintContent)
	}
	if m.ComplaintReContent != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.ComplaintReContent)))
		i += copy(dAtA[i:], *m.ComplaintReContent)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AdvSettingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvSettingRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Location))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AdvSettingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvSettingResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DelNewFriendListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelNewFriendListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlayerIds) > 0 {
		for _, num := range m.PlayerIds {
			dAtA[i] = 0x8
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TeamSettingNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamSettingNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.TeamId))
	}
	if m.WelcomeWord != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.WelcomeWord)))
		i += copy(dAtA[i:], *m.WelcomeWord)
	}
	if m.MessageSetting != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(m.MessageSetting.Size()))
		n6, err := m.MessageSetting.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NewTeamSettingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewTeamSettingReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.TeamId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocationInfoNewReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationInfoNewReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != nil {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.X))))
		i += 8
	}
	if m.Y != nil {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Y))))
		i += 8
	}
	if m.Sex != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Sex))
	}
	if m.Sort != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Sort))
	}
	if m.Page != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.PageSize != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PageSize))
	}
	if m.IsNewFlush != nil {
		dAtA[i] = 0x38
		i++
		if *m.IsNewFlush {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocationInfoNew) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationInfoNew) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.HeadIcon != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.HeadIcon)))
		i += copy(dAtA[i:], *m.HeadIcon)
	}
	if m.NickName != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.NickName)))
		i += copy(dAtA[i:], *m.NickName)
	}
	if m.Sex != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Sex))
	}
	if m.OnlineStatus != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.OnlineStatus))
	}
	if m.Signature != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Signature)))
		i += copy(dAtA[i:], *m.Signature)
	}
	if m.Distance != nil {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Distance))))
		i += 8
	}
	if m.IsFriend != nil {
		dAtA[i] = 0x40
		i++
		if *m.IsFriend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DynamicList) > 0 {
		for _, msg := range m.DynamicList {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DataType != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.DataType))
	}
	if m.IsRobot != nil {
		dAtA[i] = 0x58
		i++
		if *m.IsRobot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NearSet != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(m.NearSet.Size()))
		n7, err := m.NearSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Account != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Account)))
		i += copy(dAtA[i:], *m.Account)
	}
	if m.Types != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Types))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocationInfoNewResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationInfoNewResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LocationInfo) > 0 {
		for _, msg := range m.LocationInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NearRecommendReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NearRecommendReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != nil {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.X))))
		i += 8
	}
	if m.Y != nil {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Y))))
		i += 8
	}
	if m.Page != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.PageSize != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PageSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NearRecommendResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NearRecommendResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RecommendList) > 0 {
		for _, msg := range m.RecommendList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NearRecommend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NearRecommend) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.NickName != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.NickName)))
		i += copy(dAtA[i:], *m.NickName)
	}
	if m.HeadIcon != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.HeadIcon)))
		i += copy(dAtA[i:], *m.HeadIcon)
	}
	if m.Sex != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Sex))
	}
	if m.Signature != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Signature)))
		i += copy(dAtA[i:], *m.Signature)
	}
	if m.OnlineStatus != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.OnlineStatus))
	}
	if m.GJId != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.GJId))
	}
	if m.QPId != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.QPId))
	}
	if m.MPId != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.MPId))
	}
	if m.QTXId != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.QTXId))
	}
	if m.MZBSId != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.MZBSId))
	}
	if m.IsFriend != nil {
		dAtA[i] = 0x60
		i++
		if *m.IsFriend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Distance != nil {
		dAtA[i] = 0x69
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Distance))))
		i += 8
	}
	if m.Types != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Types))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NotifyNewSayMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotifyNewSayMessageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Id))
	}
	if m.SendPlayerId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.SendPlayerId))
	}
	if m.Content != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Content)))
		i += copy(dAtA[i:], *m.Content)
	}
	if m.ClientUnique != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.ClientUnique)))
		i += copy(dAtA[i:], *m.ClientUnique)
	}
	if m.ContentType != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.ContentType))
	}
	if m.PropsId != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PropsId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NearSessionListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NearSessionListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Page != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.PageSize != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PageSize))
	}
	if m.QueryTime != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.QueryTime))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NearSessionListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NearSessionListResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SessionList) > 0 {
		for _, msg := range m.SessionList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Count))
	}
	if m.QueryTime != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.QueryTime))
	}
	if m.MaxId != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.MaxId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NearSessionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NearSessionList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Id))
	}
	if m.SendPlayerId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.SendPlayerId))
	}
	if m.NickName != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.NickName)))
		i += copy(dAtA[i:], *m.NickName)
	}
	if m.HeadIcon != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.HeadIcon)))
		i += copy(dAtA[i:], *m.HeadIcon)
	}
	if m.Sex != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Sex))
	}
	if m.Content != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Content)))
		i += copy(dAtA[i:], *m.Content)
	}
	if m.IsRead != nil {
		dAtA[i] = 0x38
		i++
		if *m.IsRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ContentType != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.ContentType))
	}
	if m.Distance != nil {
		dAtA[i] = 0x49
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Distance))))
		i += 8
	}
	if m.IsFriend != nil {
		dAtA[i] = 0x50
		i++
		if *m.IsFriend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PropsId != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PropsId))
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.CreateTime))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SendPlayerMessageListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPlayerMessageListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendPlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.SendPlayerId))
	}
	if m.Page != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.PageSize != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PageSize))
	}
	if m.MaxId != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.MaxId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetNearChatListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNearChatListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReceivePlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.ReceivePlayerId))
	}
	if m.Page != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.PageSize != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PageSize))
	}
	if m.MaxId != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.MaxId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DelNearMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelNearMessageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SendPlayerId) > 0 {
		for _, num := range m.SendPlayerId {
			dAtA[i] = 0x8
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateIsReadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateIsReadReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HasUnReadNearResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasUnReadNearResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HasUnReadNear != nil {
		dAtA[i] = 0x8
		i++
		if *m.HasUnReadNear {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *YoungPassWord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *YoungPassWord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Opt != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Opt))
	}
	if m.PassWord != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.PassWord)))
		i += copy(dAtA[i:], *m.PassWord)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FriendNum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FriendNum) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Num != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TeamChangePos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamChangePos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Position != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Position))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TeamMembersChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamMembersChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.TeamId))
	}
	if len(m.DelList) > 0 {
		for _, num := range m.DelList {
			dAtA[i] = 0x10
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(num))
		}
	}
	if len(m.AddList) > 0 {
		for _, msg := range m.AddList {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Time != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Time))
	}
	if len(m.PosChange) > 0 {
		for _, msg := range m.PosChange {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetNewFriends) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNewFriends) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Time))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BankData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BankData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Code)))
		i += copy(dAtA[i:], *m.Code)
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SupportBankList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportBankList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PayId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PayId))
	}
	if len(m.Banks) > 0 {
		for _, msg := range m.Banks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BuryingPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuryingPoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.EventType))
	}
	if m.Time != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Time))
	}
	if m.LastTime != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.LastTime))
	}
	if m.TargetId != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.TargetId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BuryingPointList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuryingPointList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OnLineNum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnLineNum) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Num != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MsgAdv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAdv) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Advs) > 0 {
		for _, msg := range m.Advs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RightList) > 0 {
		for _, msg := range m.RightList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PlayerDiamond) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerDiamond) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Diamond != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Diamond))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PayChannels) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayChannels) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if len(m.Channels) > 0 {
		for _, msg := range m.Channels {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicTeamDynamicReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicTeamDynamicReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicTeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.TopicTeamId))
	}
	if m.Page != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.PageSize != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.PageSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicTeamDynamicResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicTeamDynamicResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicTeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.TopicTeamId))
	}
	if len(m.DynamicList) > 0 {
		for _, msg := range m.DynamicList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicTeams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicTeams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Topic != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(len(*m.Topic)))
		i += copy(dAtA[i:], *m.Topic)
	}
	if len(m.Teams) > 0 {
		for _, msg := range m.Teams {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DefunctTeam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefunctTeam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.TeamId))
	}
	if m.Result != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Result))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MainMenu) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainMenu) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Id))
	}
	if m.Type != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Type))
	}
	if m.IsOpen != nil {
		dAtA[i] = 0x18
		i++
		if *m.IsOpen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Adv != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(m.Adv.Size()))
		n8, err := m.Adv.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Slot != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Slot))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllMainMenu) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllMainMenu) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Menus) > 0 {
		for _, msg := range m.Menus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TipAdv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TipAdv) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Page != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(*m.Page))
	}
	if m.Issuspension != nil {
		dAtA[i] = 0x10
		i++
		if *m.Issuspension {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsJump != nil {
		dAtA[i] = 0x18
		i++
		if *m.IsJump {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Adv != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMainlogic(dAtA, i, uint64(m.Adv.Size()))
		n9, err := m.Adv.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllTipAdv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllTipAdv) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Advs) > 0 {
		for _, msg := range m.Advs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMainlogic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMainlogic(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LoginMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Account != nil {
		l = len(*m.Account)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Token != nil {
		l = len(*m.Token)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.RegistrationId != nil {
		l = len(*m.RegistrationId)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Channel != nil {
		l = len(*m.Channel)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.LoginType != nil {
		n += 1 + sovMainlogic(uint64(*m.LoginType))
	}
	if m.DeviceType != nil {
		n += 1 + sovMainlogic(uint64(*m.DeviceType))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.VersionNumber != nil {
		l = len(*m.VersionNumber)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Brand != nil {
		l = len(*m.Brand)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.IsAppAct != nil {
		n += 2
	}
	if m.IsUserReg != nil {
		n += 2
	}
	if m.IsLoginMan != nil {
		n += 2
	}
	if m.IsLoginFreq != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateGold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gold != nil {
		n += 1 + sovMainlogic(uint64(*m.Gold))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddPlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Account != nil {
		l = len(*m.Account)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.Text != nil {
		l = len(*m.Text)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.Mark != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccountInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Account != nil {
		l = len(*m.Account)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddBookInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PhoneList) > 0 {
		for _, s := range m.PhoneList {
			l = len(s)
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateTeam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mark != nil {
		n += 1 + sovMainlogic(uint64(*m.Mark))
	}
	if len(m.PlayerList) > 0 {
		for _, e := range m.PlayerList {
			n += 1 + sovMainlogic(uint64(e))
		}
	}
	if m.TeamName != nil {
		l = len(*m.TeamName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.AdminId != nil {
		n += 1 + sovMainlogic(uint64(*m.AdminId))
	}
	if m.HeadUrl != nil {
		l = len(*m.HeadUrl)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Topic != nil {
		l = len(*m.Topic)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.TopicDesc != nil {
		l = len(*m.TopicDesc)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeopleIdInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PeopleId != nil {
		l = len(*m.PeopleId)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BankMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserName != nil {
		l = len(*m.UserName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.IdType != nil {
		l = len(*m.IdType)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.IdNo != nil {
		l = len(*m.IdNo)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.BankCardNo != nil {
		l = len(*m.BankCardNo)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.MobileNo != nil {
		l = len(*m.MobileNo)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.ExpireDate != nil {
		l = len(*m.ExpireDate)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Cvv != nil {
		l = len(*m.Cvv)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.BankCode != nil {
		l = len(*m.BankCode)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.JPOrderNo != nil {
		l = len(*m.JPOrderNo)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.OrderNo != nil {
		l = len(*m.OrderNo)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.MsgCode != nil {
		l = len(*m.MsgCode)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.SignNo != nil {
		l = len(*m.SignNo)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Provice != nil {
		l = len(*m.Provice)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.City != nil {
		l = len(*m.City)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Area != nil {
		l = len(*m.Area)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.IsModify != nil {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DelFriendInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.IsBlack != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlackInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MoneyAssistantInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogId != nil {
		n += 1 + sovMainlogic(uint64(*m.LogId))
	}
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.ChangeGold != nil {
		n += 1 + sovMainlogic(uint64(*m.ChangeGold))
	}
	if m.SourceType != nil {
		n += 1 + sovMainlogic(uint64(*m.SourceType))
	}
	if m.Note != nil {
		l = len(*m.Note)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.CreateTime != nil {
		n += 1 + sovMainlogic(uint64(*m.CreateTime))
	}
	if m.Gold != nil {
		n += 1 + sovMainlogic(uint64(*m.Gold))
	}
	if m.OrderId != nil {
		l = len(*m.OrderId)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllMoneyAssistantInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != nil {
		n += 9
	}
	if m.Y != nil {
		n += 9
	}
	if m.Province != nil {
		l = len(*m.Province)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.City != nil {
		l = len(*m.City)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.Area != nil {
		l = len(*m.Area)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationInfoByPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != nil {
		n += 9
	}
	if m.Y != nil {
		n += 9
	}
	if m.Province != nil {
		l = len(*m.Province)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.City != nil {
		l = len(*m.City)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.Area != nil {
		l = len(*m.Area)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.PageSize != nil {
		n += 1 + sovMainlogic(uint64(*m.PageSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllLocationPlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PlayerInfo) > 0 {
		for _, e := range m.PlayerInfo {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationPlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.Sex != nil {
		n += 1 + sovMainlogic(uint64(*m.Sex))
	}
	if m.Distance != nil {
		n += 9
	}
	if m.Signature != nil {
		l = len(*m.Signature)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.IsFriend != nil {
		n += 2
	}
	if m.HeadIcon != nil {
		l = len(*m.HeadIcon)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Province != nil {
		l = len(*m.Province)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.City != nil {
		l = len(*m.City)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Account != nil {
		l = len(*m.Account)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Photo != nil {
		l = len(*m.Photo)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Area != nil {
		l = len(*m.Area)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Types != nil {
		n += 1 + sovMainlogic(uint64(*m.Types))
	}
	if len(m.LabelInfo) > 0 {
		for _, e := range m.LabelInfo {
			l = e.Size()
			n += 2 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NearByMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.Content != nil {
		l = len(*m.Content)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.NickName != nil {
		l = len(*m.NickName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.HeadIcon != nil {
		l = len(*m.HeadIcon)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Sex != nil {
		n += 1 + sovMainlogic(uint64(*m.Sex))
	}
	if m.Provice != nil {
		l = len(*m.Provice)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.City != nil {
		l = len(*m.City)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Photo != nil {
		l = len(*m.Photo)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Account != nil {
		l = len(*m.Account)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Time != nil {
		n += 1 + sovMainlogic(uint64(*m.Time))
	}
	if m.IsAdd != nil {
		n += 2
	}
	if m.Signature != nil {
		l = len(*m.Signature)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Types != nil {
		n += 1 + sovMainlogic(uint64(*m.Types))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllNearByMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NearByMessage) > 0 {
		for _, e := range m.NearByMessage {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NearByInfoReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllNearByInfo != nil {
		l = m.AllNearByInfo.Size()
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if len(m.AllNewNearByInfo) > 0 {
		for _, e := range m.AllNewNearByInfo {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NearByInfoReplyByPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllNearByInfo != nil {
		l = m.AllNearByInfo.Size()
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if len(m.AllNewNearByInfo) > 0 {
		for _, e := range m.AllNewNearByInfo {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.Count != nil {
		n += 1 + sovMainlogic(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PageInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.Num != nil {
		n += 1 + sovMainlogic(uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MoneyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.Year != nil {
		n += 1 + sovMainlogic(uint64(*m.Year))
	}
	if m.Month != nil {
		n += 1 + sovMainlogic(uint64(*m.Month))
	}
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.Num != nil {
		n += 1 + sovMainlogic(uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Time != nil {
		n += 1 + sovMainlogic(uint64(*m.Time))
	}
	if m.Money != nil {
		n += 1 + sovMainlogic(uint64(*m.Money))
	}
	if m.HeadIcon != nil {
		l = len(*m.HeadIcon)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.Statue != nil {
		n += 1 + sovMainlogic(uint64(*m.Statue))
	}
	if m.Text != nil {
		l = len(*m.Text)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.OrderId != nil {
		l = len(*m.OrderId)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.RedPacket != nil {
		l = m.RedPacket.Size()
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PayName != nil {
		l = len(*m.PayName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.ServiceCharge != nil {
		n += 1 + sovMainlogic(uint64(*m.ServiceCharge))
	}
	if m.ReceiveTime != nil {
		n += 1 + sovMainlogic(uint64(*m.ReceiveTime))
	}
	if m.TransferText != nil {
		l = len(*m.TransferText)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.ShopName != nil {
		l = len(*m.ShopName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.BankName != nil {
		l = len(*m.BankName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllOrderInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderInfo) > 0 {
		for _, e := range m.OrderInfo {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CashInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != nil {
		l = len(*m.OrderId)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Time != nil {
		n += 1 + sovMainlogic(uint64(*m.Time))
	}
	if m.ChangeGold != nil {
		n += 1 + sovMainlogic(uint64(*m.ChangeGold))
	}
	if m.Gold != nil {
		n += 1 + sovMainlogic(uint64(*m.Gold))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllCashInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CashInfo) > 0 {
		for _, e := range m.CashInfo {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RedPacketInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.Year != nil {
		n += 1 + sovMainlogic(uint64(*m.Year))
	}
	if m.Month != nil {
		n += 1 + sovMainlogic(uint64(*m.Month))
	}
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.Num != nil {
		n += 1 + sovMainlogic(uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllRedPacketInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllInfo) > 0 {
		for _, e := range m.AllInfo {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.LuckCnt != nil {
		n += 1 + sovMainlogic(uint64(*m.LuckCnt))
	}
	if m.TotalCnt != nil {
		n += 1 + sovMainlogic(uint64(*m.TotalCnt))
	}
	if m.TotalGold != nil {
		n += 1 + sovMainlogic(uint64(*m.TotalGold))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WithdrawInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BankCode != nil {
		l = len(*m.BankCode)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.AccountType != nil {
		l = len(*m.AccountType)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.AccountNo != nil {
		l = len(*m.AccountNo)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.AccountName != nil {
		l = len(*m.AccountName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.AccountProp != nil {
		l = len(*m.AccountProp)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Amount != nil {
		n += 1 + sovMainlogic(uint64(*m.Amount))
	}
	if m.Result != nil {
		n += 2
	}
	if m.OrderId != nil {
		l = len(*m.OrderId)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.StartTime != nil {
		n += 1 + sovMainlogic(uint64(*m.StartTime))
	}
	if m.Tax != nil {
		n += 1 + sovMainlogic(uint64(*m.Tax))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckPeopleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirstInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Password != nil {
		l = len(*m.Password)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if len(m.Label) > 0 {
		for _, e := range m.Label {
			n += 1 + sovMainlogic(uint64(e))
		}
	}
	if m.Sex != nil {
		n += 1 + sovMainlogic(uint64(*m.Sex))
	}
	if m.NickName != nil {
		l = len(*m.NickName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Signature != nil {
		l = len(*m.Signature)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.HeadIcon != nil {
		l = len(*m.HeadIcon)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirstReturnInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.Content != nil {
		l = len(*m.Content)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PayInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.Gold != nil {
		n += 1 + sovMainlogic(uint64(*m.Gold))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.Content != nil {
		l = len(*m.Content)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PayOrderInfo != nil {
		l = m.PayOrderInfo.Size()
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.IsWay != nil {
		n += 2
	}
	if m.Password != nil {
		l = len(*m.Password)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.BankInfo != nil {
		l = len(*m.BankInfo)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.OrderId != nil {
		l = len(*m.OrderId)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllCollectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CollectInfo) > 0 {
		for _, e := range m.CollectInfo {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DelCollectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != nil {
		n += 1 + sovMainlogic(uint64(*m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCollectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.Num != nil {
		n += 1 + sovMainlogic(uint64(*m.Num))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchCollectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Content != nil {
		l = len(*m.Content)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PayForCodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.Gold != nil {
		n += 1 + sovMainlogic(uint64(*m.Gold))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.HeadIcon != nil {
		l = len(*m.HeadIcon)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.TeamId != nil {
		n += 1 + sovMainlogic(uint64(*m.TeamId))
	}
	if m.FailReason != nil {
		l = len(*m.FailReason)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Code != nil {
		l = len(*m.Code)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnGetMoneyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetId != nil {
		n += 1 + sovMainlogic(uint64(*m.TargetId))
	}
	if m.IsHave != nil {
		n += 2
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CollectIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IndexList) > 0 {
		for _, e := range m.IndexList {
			n += 1 + sovMainlogic(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BankPaySMS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderNo != nil {
		l = len(*m.OrderNo)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.SMS != nil {
		l = len(*m.SMS)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PayId != nil {
		n += 1 + sovMainlogic(uint64(*m.PayId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecommendMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PlayerIds) > 0 {
		for _, e := range m.PlayerIds {
			n += 1 + sovMainlogic(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecommendRefreshInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddGoldInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gold != nil {
		n += 1 + sovMainlogic(uint64(*m.Gold))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WechatInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		l = len(*m.Code)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.PhoneCode != nil {
		l = len(*m.PhoneCode)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.ApkCode != nil {
		n += 1 + sovMainlogic(uint64(*m.ApkCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarkName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArticleOptRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ArticleId != nil {
		n += 1 + sovMainlogic(uint64(*m.ArticleId))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoticeOptRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovMainlogic(uint64(*m.Id))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MainInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.Count != nil {
		n += 1 + sovMainlogic(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FansInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.Sex != nil {
		n += 1 + sovMainlogic(uint64(*m.Sex))
	}
	if m.Signature != nil {
		l = len(*m.Signature)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.HeadIcon != nil {
		l = len(*m.HeadIcon)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Types != nil {
		n += 1 + sovMainlogic(uint64(*m.Types))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllFansInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FansInfo) > 0 {
		for _, e := range m.FansInfo {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynamicIdInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.LogId != nil {
		n += 1 + sovMainlogic(uint64(*m.LogId))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DynamicInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DynamicData) > 0 {
		for _, e := range m.DynamicData {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TeamMembers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamId != nil {
		n += 1 + sovMainlogic(uint64(*m.TeamId))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.Way != nil {
		n += 1 + sovMainlogic(uint64(*m.Way))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckDirtyWord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Words) > 0 {
		for _, s := range m.Words {
			l = len(s)
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if len(m.DirtyWords) > 0 {
		for _, s := range m.DirtyWords {
			l = len(s)
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckCancelAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ThirtyDays != nil {
		n += 2
	}
	if m.PhoneState != nil {
		n += 2
	}
	if m.PeopleIdState != nil {
		n += 2
	}
	if m.AccountState != nil {
		n += 2
	}
	if m.TradeState != nil {
		n += 2
	}
	if m.BalanceState != nil {
		n += 2
	}
	if m.FriendState != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelAccountData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RealName != nil {
		l = len(*m.RealName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PeopleId != nil {
		l = len(*m.PeopleId)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PeopleIdBeforeUrl != nil {
		l = len(*m.PeopleIdBeforeUrl)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PeopleIdBackUrl != nil {
		l = len(*m.PeopleIdBackUrl)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PeopleIdHandUrl != nil {
		l = len(*m.PeopleIdHandUrl)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.PhoneCode != nil {
		l = len(*m.PhoneCode)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenMyMainPageByPageReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.PageSize != nil {
		n += 1 + sovMainlogic(uint64(*m.PageSize))
	}
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewUnReadMessageResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnreadComment != nil {
		n += 1 + sovMainlogic(uint64(*m.UnreadComment))
	}
	if m.UnreadZan != nil {
		n += 1 + sovMainlogic(uint64(*m.UnreadZan))
	}
	if m.UnreadAttention != nil {
		n += 1 + sovMainlogic(uint64(*m.UnreadAttention))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplaintID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ComplaintId != nil {
		n += 1 + sovMainlogic(uint64(*m.ComplaintId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShopOrderComplaintDetailRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SponsorNickname != nil {
		l = len(*m.SponsorNickname)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.SponsorAvatar != nil {
		l = len(*m.SponsorAvatar)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.ItemFile != nil {
		l = m.ItemFile.Size()
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.ItemName != nil {
		l = len(*m.ItemName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.ItemTitle != nil {
		l = len(*m.ItemTitle)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.OrderCreateTime != nil {
		n += 1 + sovMainlogic(uint64(*m.OrderCreateTime))
	}
	if m.OrderId != nil {
		n += 1 + sovMainlogic(uint64(*m.OrderId))
	}
	if m.ComplaintAvatar != nil {
		l = len(*m.ComplaintAvatar)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.ComplaintNickname != nil {
		l = len(*m.ComplaintNickname)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.ComplaintContent != nil {
		l = len(*m.ComplaintContent)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.ComplaintReContent != nil {
		l = len(*m.ComplaintReContent)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdvSettingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		n += 1 + sovMainlogic(uint64(*m.Location))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdvSettingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DelNewFriendListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PlayerIds) > 0 {
		for _, e := range m.PlayerIds {
			n += 1 + sovMainlogic(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TeamSettingNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamId != nil {
		n += 1 + sovMainlogic(uint64(*m.TeamId))
	}
	if m.WelcomeWord != nil {
		l = len(*m.WelcomeWord)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.MessageSetting != nil {
		l = m.MessageSetting.Size()
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewTeamSettingReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamId != nil {
		n += 1 + sovMainlogic(uint64(*m.TeamId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationInfoNewReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != nil {
		n += 9
	}
	if m.Y != nil {
		n += 9
	}
	if m.Sex != nil {
		n += 1 + sovMainlogic(uint64(*m.Sex))
	}
	if m.Sort != nil {
		n += 1 + sovMainlogic(uint64(*m.Sort))
	}
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.PageSize != nil {
		n += 1 + sovMainlogic(uint64(*m.PageSize))
	}
	if m.IsNewFlush != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationInfoNew) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.HeadIcon != nil {
		l = len(*m.HeadIcon)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.NickName != nil {
		l = len(*m.NickName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Sex != nil {
		n += 1 + sovMainlogic(uint64(*m.Sex))
	}
	if m.OnlineStatus != nil {
		n += 1 + sovMainlogic(uint64(*m.OnlineStatus))
	}
	if m.Signature != nil {
		l = len(*m.Signature)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Distance != nil {
		n += 9
	}
	if m.IsFriend != nil {
		n += 2
	}
	if len(m.DynamicList) > 0 {
		for _, e := range m.DynamicList {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.DataType != nil {
		n += 1 + sovMainlogic(uint64(*m.DataType))
	}
	if m.IsRobot != nil {
		n += 2
	}
	if m.NearSet != nil {
		l = m.NearSet.Size()
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Account != nil {
		l = len(*m.Account)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Types != nil {
		n += 1 + sovMainlogic(uint64(*m.Types))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationInfoNewResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LocationInfo) > 0 {
		for _, e := range m.LocationInfo {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.Count != nil {
		n += 1 + sovMainlogic(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NearRecommendReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != nil {
		n += 9
	}
	if m.Y != nil {
		n += 9
	}
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.PageSize != nil {
		n += 1 + sovMainlogic(uint64(*m.PageSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NearRecommendResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RecommendList) > 0 {
		for _, e := range m.RecommendList {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.Count != nil {
		n += 1 + sovMainlogic(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NearRecommend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.NickName != nil {
		l = len(*m.NickName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.HeadIcon != nil {
		l = len(*m.HeadIcon)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Sex != nil {
		n += 1 + sovMainlogic(uint64(*m.Sex))
	}
	if m.Signature != nil {
		l = len(*m.Signature)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.OnlineStatus != nil {
		n += 1 + sovMainlogic(uint64(*m.OnlineStatus))
	}
	if m.GJId != nil {
		n += 1 + sovMainlogic(uint64(*m.GJId))
	}
	if m.QPId != nil {
		n += 1 + sovMainlogic(uint64(*m.QPId))
	}
	if m.MPId != nil {
		n += 1 + sovMainlogic(uint64(*m.MPId))
	}
	if m.QTXId != nil {
		n += 1 + sovMainlogic(uint64(*m.QTXId))
	}
	if m.MZBSId != nil {
		n += 1 + sovMainlogic(uint64(*m.MZBSId))
	}
	if m.IsFriend != nil {
		n += 2
	}
	if m.Distance != nil {
		n += 9
	}
	if m.Types != nil {
		n += 1 + sovMainlogic(uint64(*m.Types))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NotifyNewSayMessageReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovMainlogic(uint64(*m.Id))
	}
	if m.SendPlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.SendPlayerId))
	}
	if m.Content != nil {
		l = len(*m.Content)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.ClientUnique != nil {
		l = len(*m.ClientUnique)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.ContentType != nil {
		n += 1 + sovMainlogic(uint64(*m.ContentType))
	}
	if m.PropsId != nil {
		n += 1 + sovMainlogic(uint64(*m.PropsId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NearSessionListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.PageSize != nil {
		n += 1 + sovMainlogic(uint64(*m.PageSize))
	}
	if m.QueryTime != nil {
		n += 1 + sovMainlogic(uint64(*m.QueryTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NearSessionListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SessionList) > 0 {
		for _, e := range m.SessionList {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.Count != nil {
		n += 1 + sovMainlogic(uint64(*m.Count))
	}
	if m.QueryTime != nil {
		n += 1 + sovMainlogic(uint64(*m.QueryTime))
	}
	if m.MaxId != nil {
		n += 1 + sovMainlogic(uint64(*m.MaxId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NearSessionList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovMainlogic(uint64(*m.Id))
	}
	if m.SendPlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.SendPlayerId))
	}
	if m.NickName != nil {
		l = len(*m.NickName)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.HeadIcon != nil {
		l = len(*m.HeadIcon)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Sex != nil {
		n += 1 + sovMainlogic(uint64(*m.Sex))
	}
	if m.Content != nil {
		l = len(*m.Content)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.IsRead != nil {
		n += 2
	}
	if m.ContentType != nil {
		n += 1 + sovMainlogic(uint64(*m.ContentType))
	}
	if m.Distance != nil {
		n += 9
	}
	if m.IsFriend != nil {
		n += 2
	}
	if m.PropsId != nil {
		n += 1 + sovMainlogic(uint64(*m.PropsId))
	}
	if m.CreateTime != nil {
		n += 1 + sovMainlogic(uint64(*m.CreateTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendPlayerMessageListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SendPlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.SendPlayerId))
	}
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.PageSize != nil {
		n += 1 + sovMainlogic(uint64(*m.PageSize))
	}
	if m.MaxId != nil {
		n += 1 + sovMainlogic(uint64(*m.MaxId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetNearChatListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReceivePlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.ReceivePlayerId))
	}
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.PageSize != nil {
		n += 1 + sovMainlogic(uint64(*m.PageSize))
	}
	if m.MaxId != nil {
		n += 1 + sovMainlogic(uint64(*m.MaxId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DelNearMessageReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SendPlayerId) > 0 {
		for _, e := range m.SendPlayerId {
			n += 1 + sovMainlogic(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateIsReadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovMainlogic(uint64(*m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HasUnReadNearResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HasUnReadNear != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *YoungPassWord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opt != nil {
		n += 1 + sovMainlogic(uint64(*m.Opt))
	}
	if m.PassWord != nil {
		l = len(*m.PassWord)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FriendNum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != nil {
		n += 1 + sovMainlogic(uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TeamChangePos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.Position != nil {
		n += 1 + sovMainlogic(uint64(*m.Position))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TeamMembersChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamId != nil {
		n += 1 + sovMainlogic(uint64(*m.TeamId))
	}
	if len(m.DelList) > 0 {
		for _, e := range m.DelList {
			n += 1 + sovMainlogic(uint64(e))
		}
	}
	if len(m.AddList) > 0 {
		for _, e := range m.AddList {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.Time != nil {
		n += 1 + sovMainlogic(uint64(*m.Time))
	}
	if len(m.PosChange) > 0 {
		for _, e := range m.PosChange {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetNewFriends) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != nil {
		n += 1 + sovMainlogic(uint64(*m.Time))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BankData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		l = len(*m.Code)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SupportBankList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PayId != nil {
		n += 1 + sovMainlogic(uint64(*m.PayId))
	}
	if len(m.Banks) > 0 {
		for _, e := range m.Banks {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuryingPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventType != nil {
		n += 1 + sovMainlogic(uint64(*m.EventType))
	}
	if m.Time != nil {
		n += 1 + sovMainlogic(uint64(*m.Time))
	}
	if m.LastTime != nil {
		n += 1 + sovMainlogic(uint64(*m.LastTime))
	}
	if m.TargetId != nil {
		n += 1 + sovMainlogic(uint64(*m.TargetId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuryingPointList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnLineNum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != nil {
		n += 1 + sovMainlogic(uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgAdv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Advs) > 0 {
		for _, e := range m.Advs {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if len(m.RightList) > 0 {
		for _, e := range m.RightList {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayerDiamond) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovMainlogic(uint64(*m.PlayerId))
	}
	if m.Diamond != nil {
		n += 1 + sovMainlogic(uint64(*m.Diamond))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PayChannels) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if len(m.Channels) > 0 {
		for _, e := range m.Channels {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicTeamDynamicReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicTeamId != nil {
		n += 1 + sovMainlogic(uint64(*m.TopicTeamId))
	}
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.PageSize != nil {
		n += 1 + sovMainlogic(uint64(*m.PageSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicTeamDynamicResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicTeamId != nil {
		n += 1 + sovMainlogic(uint64(*m.TopicTeamId))
	}
	if len(m.DynamicList) > 0 {
		for _, e := range m.DynamicList {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.Count != nil {
		n += 1 + sovMainlogic(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicTeams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Topic != nil {
		l = len(*m.Topic)
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if len(m.Teams) > 0 {
		for _, e := range m.Teams {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DefunctTeam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamId != nil {
		n += 1 + sovMainlogic(uint64(*m.TeamId))
	}
	if m.Result != nil {
		n += 1 + sovMainlogic(uint64(*m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MainMenu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovMainlogic(uint64(*m.Id))
	}
	if m.Type != nil {
		n += 1 + sovMainlogic(uint64(*m.Type))
	}
	if m.IsOpen != nil {
		n += 2
	}
	if m.Adv != nil {
		l = m.Adv.Size()
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.Slot != nil {
		n += 1 + sovMainlogic(uint64(*m.Slot))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllMainMenu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Menus) > 0 {
		for _, e := range m.Menus {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TipAdv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != nil {
		n += 1 + sovMainlogic(uint64(*m.Page))
	}
	if m.Issuspension != nil {
		n += 2
	}
	if m.IsJump != nil {
		n += 2
	}
	if m.Adv != nil {
		l = m.Adv.Size()
		n += 1 + l + sovMainlogic(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllTipAdv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Advs) > 0 {
		for _, e := range m.Advs {
			l = e.Size()
			n += 1 + l + sovMainlogic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMainlogic(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMainlogic(x uint64) (n int) {
	return sovMainlogic(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LoginMsg) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Account = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Token = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RegistrationId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Channel = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoginType = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeviceType = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VersionNumber = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Brand = &s
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAppAct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsAppAct = &b
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUserReg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsUserReg = &b
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLoginMan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsLoginMan = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLoginFreq", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsLoginFreq = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("Account")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGold) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGold: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGold: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gold = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPlayerInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Account = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v share_message.AddFriend_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= share_message.AddFriend_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Text = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Mark = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("Account")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Account = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v share_message.AddFriend_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= share_message.AddFriend_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddBookInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddBookInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddBookInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneList = append(m.PhoneList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTeam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTeam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTeam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mark = &v
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PlayerList = append(m.PlayerList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMainlogic
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMainlogic
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PlayerList) == 0 {
					m.PlayerList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMainlogic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PlayerList = append(m.PlayerList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TeamName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminId = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadUrl = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Topic = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TopicDesc = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeopleIdInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeopleIdInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeopleIdInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeopleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PeopleId = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BankMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BankMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BankMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UserName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IdType = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IdNo = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankCardNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BankCardNo = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MobileNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MobileNo = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ExpireDate = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cvv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Cvv = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BankCode = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JPOrderNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.JPOrderNo = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderNo = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MsgCode = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SignNo = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Provice = &s
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.City = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Area = &s
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsModify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsModify = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelFriendInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelFriendInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelFriendInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBlack", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsBlack = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlackInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlackInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlackInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoneyAssistantInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoneyAssistantInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoneyAssistantInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeGold", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChangeGold = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourceType = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Note = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateTime = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gold = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderId = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("LogId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllMoneyAssistantInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllMoneyAssistantInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllMoneyAssistantInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &MoneyAssistantInfo{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.X = &v2
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Y = &v2
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Province", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Province = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.City = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Area = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationInfoByPage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationInfoByPage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationInfoByPage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.X = &v2
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Y = &v2
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Province", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Province = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.City = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Area = &s
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PageSize = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllLocationPlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllLocationPlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllLocationPlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerInfo = append(m.PlayerInfo, &LocationPlayerInfo{})
			if err := m.PlayerInfo[len(m.PlayerInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationPlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationPlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationPlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sex = &v
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Distance = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Signature = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFriend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsFriend = &b
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadIcon = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Province", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Province = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.City = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Account = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Photo = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Area = &s
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Types = &v
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelInfo = append(m.LabelInfo, &share_message.LabelInfo{})
			if err := m.LabelInfo[len(m.LabelInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NearByMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NearByMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NearByMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Content = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NickName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadIcon = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sex = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Provice = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.City = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Photo = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Account = &s
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Time = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsAdd = &b
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Signature = &s
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Types = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("PlayerId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllNearByMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllNearByMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllNearByMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NearByMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NearByMessage = append(m.NearByMessage, &NearByMessage{})
			if err := m.NearByMessage[len(m.NearByMessage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NearByInfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NearByInfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NearByInfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllNearByInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllNearByInfo == nil {
				m.AllNearByInfo = &AllLocationPlayerInfo{}
			}
			if err := m.AllNearByInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllNewNearByInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllNewNearByInfo = append(m.AllNewNearByInfo, &NearByMessage{})
			if err := m.AllNewNearByInfo[len(m.AllNewNearByInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NearByInfoReplyByPage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NearByInfoReplyByPage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NearByInfoReplyByPage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllNearByInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllNearByInfo == nil {
				m.AllNearByInfo = &AllLocationPlayerInfo{}
			}
			if err := m.AllNearByInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllNewNearByInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllNewNearByInfo = append(m.AllNewNearByInfo, &NearByMessage{})
			if err := m.AllNewNearByInfo[len(m.AllNewNearByInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Num = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoneyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoneyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoneyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Year", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Year = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Month", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Month = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Num = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Time = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Money = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadIcon = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Statue = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Text = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderId = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPacket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedPacket == nil {
				m.RedPacket = &share_message.RedPacket{}
			}
			if err := m.RedPacket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PayName = &s
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceCharge", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServiceCharge = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReceiveTime = &v
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TransferText = &s
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ShopName = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BankName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllOrderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllOrderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllOrderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderInfo = append(m.OrderInfo, &OrderInfo{})
			if err := m.OrderInfo[len(m.OrderInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CashInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CashInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CashInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderId = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Time = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeGold", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChangeGold = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gold = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllCashInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllCashInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllCashInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CashInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CashInfo = append(m.CashInfo, &CashInfo{})
			if err := m.CashInfo[len(m.CashInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedPacketInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedPacketInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedPacketInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Year", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Year = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Month", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Month = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Num = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllRedPacketInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllRedPacketInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllRedPacketInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllInfo = append(m.AllInfo, &share_message.RedPacket{})
			if err := m.AllInfo[len(m.AllInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LuckCnt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LuckCnt = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCnt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalCnt = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalGold", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalGold = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BankCode = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AccountType = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AccountNo = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AccountName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountProp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AccountProp = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Amount = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Result = &b
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderId = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartTime = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tax = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckPeopleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckPeopleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckPeopleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirstInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirstInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirstInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Password = &s
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Label = append(m.Label, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMainlogic
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMainlogic
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Label) == 0 {
					m.Label = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMainlogic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Label = append(m.Label, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sex = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NickName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Signature = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadIcon = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirstReturnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirstReturnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirstReturnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Content = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gold = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Content = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayOrderInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PayOrderInfo == nil {
				m.PayOrderInfo = &share_message.PayOrderInfo{}
			}
			if err := m.PayOrderInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsWay = &b
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Password = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BankInfo = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderId = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllCollectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllCollectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllCollectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectInfo = append(m.CollectInfo, &share_message.CollectInfo{})
			if err := m.CollectInfo[len(m.CollectInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelCollectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelCollectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelCollectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCollectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCollectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCollectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Num = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchCollectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchCollectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchCollectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Content = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayForCodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayForCodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayForCodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gold = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadIcon = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FailReason = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Code = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnGetMoneyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnGetMoneyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnGetMoneyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHave", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsHave = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IndexList = append(m.IndexList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMainlogic
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMainlogic
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IndexList) == 0 {
					m.IndexList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMainlogic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IndexList = append(m.IndexList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BankPaySMS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BankPaySMS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BankPaySMS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderNo = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SMS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SMS = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PayId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PlayerIds = append(m.PlayerIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMainlogic
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMainlogic
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PlayerIds) == 0 {
					m.PlayerIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMainlogic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PlayerIds = append(m.PlayerIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendRefreshInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendRefreshInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendRefreshInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddGoldInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddGoldInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddGoldInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gold = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WechatInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WechatInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WechatInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Code = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PhoneCode = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApkCode", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ApkCode = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArticleOptRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArticleOptRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArticleOptRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArticleId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ArticleId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoticeOptRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoticeOptRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoticeOptRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FansInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FansInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FansInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sex = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Signature = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadIcon = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Types = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllFansInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllFansInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllFansInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FansInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FansInfo = append(m.FansInfo, &FansInfo{})
			if err := m.FansInfo[len(m.FansInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicIdInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicIdInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicIdInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicData = append(m.DynamicData, &share_message.DynamicData{})
			if err := m.DynamicData[len(m.DynamicData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamMembers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamMembers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamMembers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &share_message.PersonalTeamData{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Way", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Way = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckDirtyWord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckDirtyWord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckDirtyWord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Words", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Words = append(m.Words, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirtyWords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirtyWords = append(m.DirtyWords, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckCancelAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckCancelAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckCancelAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThirtyDays", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ThirtyDays = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PhoneState = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeopleIdState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PeopleIdState = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AccountState = &b
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TradeState = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BalanceState = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FriendState = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelAccountData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelAccountData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelAccountData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RealName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeopleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PeopleId = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeopleIdBeforeUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PeopleIdBeforeUrl = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeopleIdBackUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PeopleIdBackUrl = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeopleIdHandUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PeopleIdHandUrl = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PhoneCode = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenMyMainPageByPageReq) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenMyMainPageByPageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenMyMainPageByPageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PageSize = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("PlayerId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewUnReadMessageResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewUnReadMessageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewUnReadMessageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadComment", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnreadComment = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadZan", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnreadZan = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadAttention", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnreadAttention = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplaintID) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplaintID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplaintID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplaintId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ComplaintId = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("ComplaintId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopOrderComplaintDetailRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShopOrderComplaintDetailRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShopOrderComplaintDetailRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SponsorNickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SponsorNickname = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SponsorAvatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SponsorAvatar = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemFile == nil {
				m.ItemFile = &share_message.ItemFile{}
			}
			if err := m.ItemFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ItemName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ItemTitle = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderCreateTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OrderCreateTime = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OrderId = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplaintAvatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ComplaintAvatar = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplaintNickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ComplaintNickname = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplaintContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ComplaintContent = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplaintReContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ComplaintReContent = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvSettingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvSettingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvSettingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Location = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvSettingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvSettingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvSettingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &share_message.AdvSetting{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelNewFriendListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelNewFriendListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelNewFriendListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PlayerIds = append(m.PlayerIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMainlogic
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMainlogic
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PlayerIds) == 0 {
					m.PlayerIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMainlogic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PlayerIds = append(m.PlayerIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamSettingNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamSettingNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamSettingNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WelcomeWord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WelcomeWord = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageSetting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageSetting == nil {
				m.MessageSetting = &share_message.MessageSetting{}
			}
			if err := m.MessageSetting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewTeamSettingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewTeamSettingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewTeamSettingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationInfoNewReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationInfoNewReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationInfoNewReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.X = &v2
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Y = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sex = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sort = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PageSize = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNewFlush", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsNewFlush = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationInfoNew) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationInfoNew: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationInfoNew: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadIcon = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NickName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sex = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineStatus", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlineStatus = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Signature = &s
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Distance = &v2
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFriend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsFriend = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicList = append(m.DynamicList, &share_message.DynamicData{})
			if err := m.DynamicList[len(m.DynamicList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DataType = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRobot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsRobot = &b
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NearSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NearSet == nil {
				m.NearSet = &share_message.NearSet{}
			}
			if err := m.NearSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Account = &s
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Types = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationInfoNewResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationInfoNewResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationInfoNewResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocationInfo = append(m.LocationInfo, &LocationInfoNew{})
			if err := m.LocationInfo[len(m.LocationInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NearRecommendReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NearRecommendReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NearRecommendReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.X = &v2
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Y = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PageSize = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NearRecommendResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NearRecommendResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NearRecommendResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecommendList = append(m.RecommendList, &NearRecommend{})
			if err := m.RecommendList[len(m.RecommendList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NearRecommend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NearRecommend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NearRecommend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NickName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadIcon = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sex = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Signature = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineStatus", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlineStatus = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GJId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GJId = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QPId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QPId = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MPId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MPId = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QTXId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QTXId = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MZBSId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MZBSId = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFriend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsFriend = &b
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Distance = &v2
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Types = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotifyNewSayMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotifyNewSayMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotifyNewSayMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendPlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendPlayerId = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Content = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientUnique", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ClientUnique = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContentType = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropsId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PropsId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NearSessionListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NearSessionListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NearSessionListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PageSize = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryTime = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NearSessionListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NearSessionListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NearSessionListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionList = append(m.SessionList, &NearSessionList{})
			if err := m.SessionList[len(m.SessionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryTime = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NearSessionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NearSessionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NearSessionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendPlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendPlayerId = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NickName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadIcon = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sex = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Content = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsRead = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContentType = &v
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Distance = &v2
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFriend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsFriend = &b
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropsId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PropsId = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateTime = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPlayerMessageListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendPlayerMessageListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendPlayerMessageListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendPlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendPlayerId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PageSize = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNearChatListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNearChatListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNearChatListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivePlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReceivePlayerId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PageSize = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelNearMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelNearMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelNearMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SendPlayerId = append(m.SendPlayerId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMainlogic
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMainlogic
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SendPlayerId) == 0 {
					m.SendPlayerId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMainlogic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SendPlayerId = append(m.SendPlayerId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SendPlayerId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateIsReadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateIsReadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateIsReadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HasUnReadNearResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasUnReadNearResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasUnReadNearResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasUnReadNear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HasUnReadNear = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *YoungPassWord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: YoungPassWord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: YoungPassWord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Opt = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassWord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PassWord = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FriendNum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FriendNum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FriendNum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Num = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamChangePos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamChangePos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamChangePos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Position = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamMembersChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamMembersChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamMembersChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DelList = append(m.DelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMainlogic
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMainlogic
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DelList) == 0 {
					m.DelList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMainlogic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DelList = append(m.DelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DelList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddList = append(m.AddList, &share_message.PersonalTeamData{})
			if err := m.AddList[len(m.AddList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Time = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PosChange = append(m.PosChange, &TeamChangePos{})
			if err := m.PosChange[len(m.PosChange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNewFriends) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNewFriends: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNewFriends: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Time = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BankData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BankData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BankData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Code = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportBankList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportBankList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportBankList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PayId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Banks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Banks = append(m.Banks, &BankData{})
			if err := m.Banks[len(m.Banks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuryingPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuryingPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuryingPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EventType = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Time = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastTime = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuryingPointList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuryingPointList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuryingPointList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &BuryingPoint{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnLineNum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnLineNum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnLineNum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Num = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAdv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAdv: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAdv: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Advs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Advs = append(m.Advs, &share_message.AdvSetting{})
			if err := m.Advs[len(m.Advs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightList = append(m.RightList, &share_message.AdvSetting{})
			if err := m.RightList[len(m.RightList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerDiamond) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerDiamond: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerDiamond: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Diamond = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayChannels) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayChannels: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayChannels: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, &share_message.PlatformChannel{})
			if err := m.Channels[len(m.Channels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicTeamDynamicReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicTeamDynamicReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicTeamDynamicReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicTeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TopicTeamId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PageSize = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicTeamDynamicResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicTeamDynamicResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicTeamDynamicResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicTeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TopicTeamId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicList = append(m.DynamicList, &share_message.DynamicData{})
			if err := m.DynamicList[len(m.DynamicList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicTeams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicTeams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicTeams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Topic = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Teams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Teams = append(m.Teams, &share_message.TeamData{})
			if err := m.Teams[len(m.Teams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefunctTeam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefunctTeam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefunctTeam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainMenu) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainMenu: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainMenu: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOpen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsOpen = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Adv == nil {
				m.Adv = &share_message.AdvSetting{}
			}
			if err := m.Adv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Slot = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllMainMenu) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllMainMenu: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllMainMenu: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Menus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Menus = append(m.Menus, &MainMenu{})
			if err := m.Menus[len(m.Menus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TipAdv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TipAdv: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TipAdv: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuspension", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Issuspension = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsJump", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsJump = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Adv == nil {
				m.Adv = &share_message.AdvSetting{}
			}
			if err := m.Adv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllTipAdv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllTipAdv: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllTipAdv: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Advs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMainlogic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMainlogic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Advs = append(m.Advs, &TipAdv{})
			if err := m.Advs[len(m.Advs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMainlogic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMainlogic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMainlogic(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMainlogic
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMainlogic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMainlogic
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMainlogic
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMainlogic
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMainlogic(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMainlogic
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMainlogic = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMainlogic   = fmt.Errorf("proto: integer overflow")
)
