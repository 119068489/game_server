// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: chat.proto

package client_hall

import (
	fmt "fmt"
	share_message "game_server/pb/share_message"
	proto "github.com/akqp2019/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

//群管理设置
type CgTeamPerSetting struct {
	TeamId               *int64   `protobuf:"varint,1,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	Type                 *int32   `protobuf:"varint,2,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Value                *bool    `protobuf:"varint,3,opt,name=Value" json:"Value,omitempty" bson:"Value,omitempty"`
	Name                 *string  `protobuf:"bytes,4,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	OptPlayerId          *int64   `protobuf:"varint,5,opt,name=OptPlayerId" json:"OptPlayerId,omitempty" bson:"OptPlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *CgTeamPerSetting) Reset()         { *m = CgTeamPerSetting{} }
func (m *CgTeamPerSetting) String() string { return proto.CompactTextString(m) }
func (*CgTeamPerSetting) ProtoMessage()    {}
func (*CgTeamPerSetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{0}
}
func (m *CgTeamPerSetting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CgTeamPerSetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CgTeamPerSetting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CgTeamPerSetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CgTeamPerSetting.Merge(m, src)
}
func (m *CgTeamPerSetting) XXX_Size() int {
	return m.Size()
}
func (m *CgTeamPerSetting) XXX_DiscardUnknown() {
	xxx_messageInfo_CgTeamPerSetting.DiscardUnknown(m)
}

var xxx_messageInfo_CgTeamPerSetting proto.InternalMessageInfo

func (m *CgTeamPerSetting) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *CgTeamPerSetting) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *CgTeamPerSetting) GetValue() bool {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return false
}

func (m *CgTeamPerSetting) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CgTeamPerSetting) GetOptPlayerId() int64 {
	if m != nil && m.OptPlayerId != nil {
		return *m.OptPlayerId
	}
	return 0
}

type CgTeamManageSetting struct {
	TeamId               *int64   `protobuf:"varint,1,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	Type                 *int32   `protobuf:"varint,2,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Value                *bool    `protobuf:"varint,3,opt,name=Value" json:"Value,omitempty" bson:"Value,omitempty"`
	Value1               *int32   `protobuf:"varint,4,opt,name=Value1" json:"Value1,omitempty" bson:"Value1,omitempty"`
	Value2               *string  `protobuf:"bytes,5,opt,name=Value2" json:"Value2,omitempty" bson:"Value2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *CgTeamManageSetting) Reset()         { *m = CgTeamManageSetting{} }
func (m *CgTeamManageSetting) String() string { return proto.CompactTextString(m) }
func (*CgTeamManageSetting) ProtoMessage()    {}
func (*CgTeamManageSetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{1}
}
func (m *CgTeamManageSetting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CgTeamManageSetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CgTeamManageSetting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CgTeamManageSetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CgTeamManageSetting.Merge(m, src)
}
func (m *CgTeamManageSetting) XXX_Size() int {
	return m.Size()
}
func (m *CgTeamManageSetting) XXX_DiscardUnknown() {
	xxx_messageInfo_CgTeamManageSetting.DiscardUnknown(m)
}

var xxx_messageInfo_CgTeamManageSetting proto.InternalMessageInfo

func (m *CgTeamManageSetting) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *CgTeamManageSetting) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *CgTeamManageSetting) GetValue() bool {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return false
}

func (m *CgTeamManageSetting) GetValue1() int32 {
	if m != nil && m.Value1 != nil {
		return *m.Value1
	}
	return 0
}

func (m *CgTeamManageSetting) GetValue2() string {
	if m != nil && m.Value2 != nil {
		return *m.Value2
	}
	return ""
}

type OpenRedPacket struct {
	Id                   *int64   `protobuf:"varint,1,opt,name=Id" json:"Id,omitempty" bson:"Id,omitempty"`
	PlayerId             *int64   `protobuf:"varint,2,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	NickName             *string  `protobuf:"bytes,3,opt,name=NickName" json:"NickName,omitempty" bson:"NickName,omitempty"`
	Gold                 *int64   `protobuf:"varint,4,opt,name=Gold" json:"Gold,omitempty" bson:"Gold,omitempty"`
	Type                 *int32   `protobuf:"varint,5,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	SenderId             *int64   `protobuf:"varint,6,opt,name=SenderId" json:"SenderId,omitempty" bson:"SenderId,omitempty"`
	SendName             *string  `protobuf:"bytes,7,opt,name=SendName" json:"SendName,omitempty" bson:"SendName,omitempty"`
	TeamId               *int64   `protobuf:"varint,8,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	Time                 *int64   `protobuf:"varint,9,opt,name=Time" json:"Time,omitempty" bson:"Time,omitempty"`
	State                *int32   `protobuf:"varint,10,opt,name=State" json:"State,omitempty" bson:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *OpenRedPacket) Reset()         { *m = OpenRedPacket{} }
func (m *OpenRedPacket) String() string { return proto.CompactTextString(m) }
func (*OpenRedPacket) ProtoMessage()    {}
func (*OpenRedPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{2}
}
func (m *OpenRedPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenRedPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenRedPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenRedPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenRedPacket.Merge(m, src)
}
func (m *OpenRedPacket) XXX_Size() int {
	return m.Size()
}
func (m *OpenRedPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenRedPacket.DiscardUnknown(m)
}

var xxx_messageInfo_OpenRedPacket proto.InternalMessageInfo

func (m *OpenRedPacket) GetId() int64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *OpenRedPacket) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *OpenRedPacket) GetNickName() string {
	if m != nil && m.NickName != nil {
		return *m.NickName
	}
	return ""
}

func (m *OpenRedPacket) GetGold() int64 {
	if m != nil && m.Gold != nil {
		return *m.Gold
	}
	return 0
}

func (m *OpenRedPacket) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *OpenRedPacket) GetSenderId() int64 {
	if m != nil && m.SenderId != nil {
		return *m.SenderId
	}
	return 0
}

func (m *OpenRedPacket) GetSendName() string {
	if m != nil && m.SendName != nil {
		return *m.SendName
	}
	return ""
}

func (m *OpenRedPacket) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *OpenRedPacket) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *OpenRedPacket) GetState() int32 {
	if m != nil && m.State != nil {
		return *m.State
	}
	return 0
}

type OpenTransfer struct {
	Id                   *int64   `protobuf:"varint,1,opt,name=Id" json:"Id,omitempty" bson:"Id,omitempty"`
	SendName             *string  `protobuf:"bytes,2,opt,name=SendName" json:"SendName,omitempty" bson:"SendName,omitempty"`
	NickName             *string  `protobuf:"bytes,3,opt,name=NickName" json:"NickName,omitempty" bson:"NickName,omitempty"`
	State                *int32   `protobuf:"varint,4,opt,name=State" json:"State,omitempty" bson:"State,omitempty"`
	SendId               *int64   `protobuf:"varint,5,opt,name=SendId" json:"SendId,omitempty" bson:"SendId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *OpenTransfer) Reset()         { *m = OpenTransfer{} }
func (m *OpenTransfer) String() string { return proto.CompactTextString(m) }
func (*OpenTransfer) ProtoMessage()    {}
func (*OpenTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{3}
}
func (m *OpenTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenTransfer.Merge(m, src)
}
func (m *OpenTransfer) XXX_Size() int {
	return m.Size()
}
func (m *OpenTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_OpenTransfer proto.InternalMessageInfo

func (m *OpenTransfer) GetId() int64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *OpenTransfer) GetSendName() string {
	if m != nil && m.SendName != nil {
		return *m.SendName
	}
	return ""
}

func (m *OpenTransfer) GetNickName() string {
	if m != nil && m.NickName != nil {
		return *m.NickName
	}
	return ""
}

func (m *OpenTransfer) GetState() int32 {
	if m != nil && m.State != nil {
		return *m.State
	}
	return 0
}

func (m *OpenTransfer) GetSendId() int64 {
	if m != nil && m.SendId != nil {
		return *m.SendId
	}
	return 0
}

type FriendSetting struct {
	Type                 *int32   `protobuf:"varint,1,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Value                *bool    `protobuf:"varint,2,opt,name=Value" json:"Value,omitempty" bson:"Value,omitempty"`
	PlayerId             *int64   `protobuf:"varint,3,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *FriendSetting) Reset()         { *m = FriendSetting{} }
func (m *FriendSetting) String() string { return proto.CompactTextString(m) }
func (*FriendSetting) ProtoMessage()    {}
func (*FriendSetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{4}
}
func (m *FriendSetting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FriendSetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FriendSetting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FriendSetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FriendSetting.Merge(m, src)
}
func (m *FriendSetting) XXX_Size() int {
	return m.Size()
}
func (m *FriendSetting) XXX_DiscardUnknown() {
	xxx_messageInfo_FriendSetting.DiscardUnknown(m)
}

var xxx_messageInfo_FriendSetting proto.InternalMessageInfo

func (m *FriendSetting) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *FriendSetting) GetValue() bool {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return false
}

func (m *FriendSetting) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

type TeamDataInfo struct {
	Team                 *share_message.TeamData           `protobuf:"bytes,1,opt,name=Team" json:"Team,omitempty" bson:"Team,omitempty"`
	Members              []*share_message.PersonalTeamData `protobuf:"bytes,3,rep,name=Members" json:"Members,omitempty" bson:"Members,omitempty"`
	PlayerId             *int64                            `protobuf:"varint,2,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Type                 *int32                            `protobuf:"varint,4,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Name                 *string                           `protobuf:"bytes,5,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	HeadUrl              *string                           `protobuf:"bytes,6,opt,name=HeadUrl" json:"HeadUrl,omitempty" bson:"HeadUrl,omitempty"`
	Sex                  *int32                            `protobuf:"varint,7,opt,name=Sex" json:"Sex,omitempty" bson:"Sex,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-" bson:"-"`
	XXX_unrecognized     []byte                            `json:"-" bson:"-"`
	XXX_sizecache        int32                             `json:"-" bson:"-"`
}

func (m *TeamDataInfo) Reset()         { *m = TeamDataInfo{} }
func (m *TeamDataInfo) String() string { return proto.CompactTextString(m) }
func (*TeamDataInfo) ProtoMessage()    {}
func (*TeamDataInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{5}
}
func (m *TeamDataInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TeamDataInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TeamDataInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TeamDataInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TeamDataInfo.Merge(m, src)
}
func (m *TeamDataInfo) XXX_Size() int {
	return m.Size()
}
func (m *TeamDataInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TeamDataInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TeamDataInfo proto.InternalMessageInfo

func (m *TeamDataInfo) GetTeam() *share_message.TeamData {
	if m != nil {
		return m.Team
	}
	return nil
}

func (m *TeamDataInfo) GetMembers() []*share_message.PersonalTeamData {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *TeamDataInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *TeamDataInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *TeamDataInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TeamDataInfo) GetHeadUrl() string {
	if m != nil && m.HeadUrl != nil {
		return *m.HeadUrl
	}
	return ""
}

func (m *TeamDataInfo) GetSex() int32 {
	if m != nil && m.Sex != nil {
		return *m.Sex
	}
	return 0
}

type AllInviteInfo struct {
	AllInfo              []*share_message.InviteInfo `protobuf:"bytes,1,rep,name=AllInfo" json:"AllInfo,omitempty" bson:"AllInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-" bson:"-"`
	XXX_unrecognized     []byte                      `json:"-" bson:"-"`
	XXX_sizecache        int32                       `json:"-" bson:"-"`
}

func (m *AllInviteInfo) Reset()         { *m = AllInviteInfo{} }
func (m *AllInviteInfo) String() string { return proto.CompactTextString(m) }
func (*AllInviteInfo) ProtoMessage()    {}
func (*AllInviteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{6}
}
func (m *AllInviteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllInviteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllInviteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllInviteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllInviteInfo.Merge(m, src)
}
func (m *AllInviteInfo) XXX_Size() int {
	return m.Size()
}
func (m *AllInviteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AllInviteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AllInviteInfo proto.InternalMessageInfo

func (m *AllInviteInfo) GetAllInfo() []*share_message.InviteInfo {
	if m != nil {
		return m.AllInfo
	}
	return nil
}

type DealInviteInfo struct {
	LogId                *int64   `protobuf:"varint,1,opt,name=LogId" json:"LogId,omitempty" bson:"LogId,omitempty"`
	State                *int32   `protobuf:"varint,2,opt,name=State" json:"State,omitempty" bson:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *DealInviteInfo) Reset()         { *m = DealInviteInfo{} }
func (m *DealInviteInfo) String() string { return proto.CompactTextString(m) }
func (*DealInviteInfo) ProtoMessage()    {}
func (*DealInviteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{7}
}
func (m *DealInviteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DealInviteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DealInviteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DealInviteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DealInviteInfo.Merge(m, src)
}
func (m *DealInviteInfo) XXX_Size() int {
	return m.Size()
}
func (m *DealInviteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DealInviteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DealInviteInfo proto.InternalMessageInfo

func (m *DealInviteInfo) GetLogId() int64 {
	if m != nil && m.LogId != nil {
		return *m.LogId
	}
	return 0
}

func (m *DealInviteInfo) GetState() int32 {
	if m != nil && m.State != nil {
		return *m.State
	}
	return 0
}

type ChangeNameInfo struct {
	TeamId               *int64   `protobuf:"varint,1,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	PlayerId             *int64   `protobuf:"varint,2,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Name                 *string  `protobuf:"bytes,3,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *ChangeNameInfo) Reset()         { *m = ChangeNameInfo{} }
func (m *ChangeNameInfo) String() string { return proto.CompactTextString(m) }
func (*ChangeNameInfo) ProtoMessage()    {}
func (*ChangeNameInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{8}
}
func (m *ChangeNameInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeNameInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeNameInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeNameInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeNameInfo.Merge(m, src)
}
func (m *ChangeNameInfo) XXX_Size() int {
	return m.Size()
}
func (m *ChangeNameInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeNameInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeNameInfo proto.InternalMessageInfo

func (m *ChangeNameInfo) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *ChangeNameInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *ChangeNameInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type LogInfo struct {
	LogId                *int64   `protobuf:"varint,1,opt,name=LogId" json:"LogId,omitempty" bson:"LogId,omitempty"`
	PlayerId             *int64   `protobuf:"varint,2,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Time                 *int64   `protobuf:"varint,3,opt,name=Time" json:"Time,omitempty" bson:"Time,omitempty"`
	TargetId             *int64   `protobuf:"varint,4,opt,name=TargetId" json:"TargetId,omitempty" bson:"TargetId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *LogInfo) Reset()         { *m = LogInfo{} }
func (m *LogInfo) String() string { return proto.CompactTextString(m) }
func (*LogInfo) ProtoMessage()    {}
func (*LogInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{9}
}
func (m *LogInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogInfo.Merge(m, src)
}
func (m *LogInfo) XXX_Size() int {
	return m.Size()
}
func (m *LogInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LogInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LogInfo proto.InternalMessageInfo

func (m *LogInfo) GetLogId() int64 {
	if m != nil && m.LogId != nil {
		return *m.LogId
	}
	return 0
}

func (m *LogInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *LogInfo) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *LogInfo) GetTargetId() int64 {
	if m != nil && m.TargetId != nil {
		return *m.TargetId
	}
	return 0
}

type SpecialChatInfo struct {
	Type                 *int32   `protobuf:"varint,1,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	SendId               *int64   `protobuf:"varint,2,opt,name=SendId" json:"SendId,omitempty" bson:"SendId,omitempty"`
	TargetId             *int64   `protobuf:"varint,3,opt,name=TargetId" json:"TargetId,omitempty" bson:"TargetId,omitempty"`
	Name                 *string  `protobuf:"bytes,4,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	ChatType             *int32   `protobuf:"varint,5,opt,name=ChatType" json:"ChatType,omitempty" bson:"ChatType,omitempty"`
	Operate              *int32   `protobuf:"varint,6,opt,name=Operate" json:"Operate,omitempty" bson:"Operate,omitempty"`
	Time                 *int64   `protobuf:"varint,7,opt,name=Time" json:"Time,omitempty" bson:"Time,omitempty"`
	TargetIds            []int64  `protobuf:"varint,8,rep,name=TargetIds" json:"TargetIds,omitempty" bson:"TargetIds,omitempty"`
	OperateId            *int64   `protobuf:"varint,9,opt,name=OperateId" json:"OperateId,omitempty" bson:"OperateId,omitempty"`
	OnLineId             []int64  `protobuf:"varint,10,rep,name=OnLineId" json:"OnLineId,omitempty" bson:"OnLineId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *SpecialChatInfo) Reset()         { *m = SpecialChatInfo{} }
func (m *SpecialChatInfo) String() string { return proto.CompactTextString(m) }
func (*SpecialChatInfo) ProtoMessage()    {}
func (*SpecialChatInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{10}
}
func (m *SpecialChatInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecialChatInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecialChatInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecialChatInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecialChatInfo.Merge(m, src)
}
func (m *SpecialChatInfo) XXX_Size() int {
	return m.Size()
}
func (m *SpecialChatInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecialChatInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SpecialChatInfo proto.InternalMessageInfo

func (m *SpecialChatInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *SpecialChatInfo) GetSendId() int64 {
	if m != nil && m.SendId != nil {
		return *m.SendId
	}
	return 0
}

func (m *SpecialChatInfo) GetTargetId() int64 {
	if m != nil && m.TargetId != nil {
		return *m.TargetId
	}
	return 0
}

func (m *SpecialChatInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *SpecialChatInfo) GetChatType() int32 {
	if m != nil && m.ChatType != nil {
		return *m.ChatType
	}
	return 0
}

func (m *SpecialChatInfo) GetOperate() int32 {
	if m != nil && m.Operate != nil {
		return *m.Operate
	}
	return 0
}

func (m *SpecialChatInfo) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *SpecialChatInfo) GetTargetIds() []int64 {
	if m != nil {
		return m.TargetIds
	}
	return nil
}

func (m *SpecialChatInfo) GetOperateId() int64 {
	if m != nil && m.OperateId != nil {
		return *m.OperateId
	}
	return 0
}

func (m *SpecialChatInfo) GetOnLineId() []int64 {
	if m != nil {
		return m.OnLineId
	}
	return nil
}

type ChatInfo struct {
	StartId              *int64   `protobuf:"varint,1,opt,name=StartId" json:"StartId,omitempty" bson:"StartId,omitempty"`
	OverId               *int64   `protobuf:"varint,2,opt,name=OverId" json:"OverId,omitempty" bson:"OverId,omitempty"`
	TeamId               *int64   `protobuf:"varint,3,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	Count                *int32   `protobuf:"varint,4,opt,name=Count" json:"Count,omitempty" bson:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *ChatInfo) Reset()         { *m = ChatInfo{} }
func (m *ChatInfo) String() string { return proto.CompactTextString(m) }
func (*ChatInfo) ProtoMessage()    {}
func (*ChatInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{11}
}
func (m *ChatInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatInfo.Merge(m, src)
}
func (m *ChatInfo) XXX_Size() int {
	return m.Size()
}
func (m *ChatInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ChatInfo proto.InternalMessageInfo

func (m *ChatInfo) GetStartId() int64 {
	if m != nil && m.StartId != nil {
		return *m.StartId
	}
	return 0
}

func (m *ChatInfo) GetOverId() int64 {
	if m != nil && m.OverId != nil {
		return *m.OverId
	}
	return 0
}

func (m *ChatInfo) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *ChatInfo) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

type ReturnChatInfo struct {
	ChatList             []*share_message.TeamChatLog `protobuf:"bytes,1,rep,name=ChatList" json:"ChatList,omitempty" bson:"ChatList,omitempty"`
	Count                *int32                       `protobuf:"varint,2,opt,name=Count" json:"Count,omitempty" bson:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-" bson:"-"`
	XXX_unrecognized     []byte                       `json:"-" bson:"-"`
	XXX_sizecache        int32                        `json:"-" bson:"-"`
}

func (m *ReturnChatInfo) Reset()         { *m = ReturnChatInfo{} }
func (m *ReturnChatInfo) String() string { return proto.CompactTextString(m) }
func (*ReturnChatInfo) ProtoMessage()    {}
func (*ReturnChatInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{12}
}
func (m *ReturnChatInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReturnChatInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReturnChatInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReturnChatInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReturnChatInfo.Merge(m, src)
}
func (m *ReturnChatInfo) XXX_Size() int {
	return m.Size()
}
func (m *ReturnChatInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ReturnChatInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ReturnChatInfo proto.InternalMessageInfo

func (m *ReturnChatInfo) GetChatList() []*share_message.TeamChatLog {
	if m != nil {
		return m.ChatList
	}
	return nil
}

func (m *ReturnChatInfo) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

//群封禁信息
type OperatorMessage struct {
	Name                 *string  `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	Members              []string `protobuf:"bytes,2,rep,name=Members" json:"Members,omitempty" bson:"Members,omitempty"`
	TeamId               *int64   `protobuf:"varint,3,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	Flag                 *int64   `protobuf:"varint,4,opt,name=Flag" json:"Flag,omitempty" bson:"Flag,omitempty"`
	SendTime             *int64   `protobuf:"varint,5,opt,name=SendTime" json:"SendTime,omitempty" bson:"SendTime,omitempty"`
	LogId                *int64   `protobuf:"varint,6,opt,name=LogId" json:"LogId,omitempty" bson:"LogId,omitempty"`
	PlayerId             []int64  `protobuf:"varint,7,rep,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	CloseTime            *int64   `protobuf:"varint,8,opt,name=CloseTime" json:"CloseTime,omitempty" bson:"CloseTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *OperatorMessage) Reset()         { *m = OperatorMessage{} }
func (m *OperatorMessage) String() string { return proto.CompactTextString(m) }
func (*OperatorMessage) ProtoMessage()    {}
func (*OperatorMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{13}
}
func (m *OperatorMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorMessage.Merge(m, src)
}
func (m *OperatorMessage) XXX_Size() int {
	return m.Size()
}
func (m *OperatorMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorMessage.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorMessage proto.InternalMessageInfo

func (m *OperatorMessage) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *OperatorMessage) GetMembers() []string {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *OperatorMessage) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *OperatorMessage) GetFlag() int64 {
	if m != nil && m.Flag != nil {
		return *m.Flag
	}
	return 0
}

func (m *OperatorMessage) GetSendTime() int64 {
	if m != nil && m.SendTime != nil {
		return *m.SendTime
	}
	return 0
}

func (m *OperatorMessage) GetLogId() int64 {
	if m != nil && m.LogId != nil {
		return *m.LogId
	}
	return 0
}

func (m *OperatorMessage) GetPlayerId() []int64 {
	if m != nil {
		return m.PlayerId
	}
	return nil
}

func (m *OperatorMessage) GetCloseTime() int64 {
	if m != nil && m.CloseTime != nil {
		return *m.CloseTime
	}
	return 0
}

type PlayerInfo struct {
	TeamId               *int64   `protobuf:"varint,1,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	Flag                 *int32   `protobuf:"varint,2,opt,name=Flag" json:"Flag,omitempty" bson:"Flag,omitempty"`
	Time                 *int64   `protobuf:"varint,3,opt,name=Time" json:"Time,omitempty" bson:"Time,omitempty"`
	PlayerId             *int64   `protobuf:"varint,4,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *PlayerInfo) Reset()         { *m = PlayerInfo{} }
func (m *PlayerInfo) String() string { return proto.CompactTextString(m) }
func (*PlayerInfo) ProtoMessage()    {}
func (*PlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{14}
}
func (m *PlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerInfo.Merge(m, src)
}
func (m *PlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *PlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerInfo proto.InternalMessageInfo

func (m *PlayerInfo) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *PlayerInfo) GetFlag() int32 {
	if m != nil && m.Flag != nil {
		return *m.Flag
	}
	return 0
}

func (m *PlayerInfo) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *PlayerInfo) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

type WaiterMsgRequest struct {
	Mid                  *int64   `protobuf:"varint,1,opt,name=Mid" json:"Mid,omitempty" bson:"Mid,omitempty"`
	Type                 *int32   `protobuf:"varint,2,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *WaiterMsgRequest) Reset()         { *m = WaiterMsgRequest{} }
func (m *WaiterMsgRequest) String() string { return proto.CompactTextString(m) }
func (*WaiterMsgRequest) ProtoMessage()    {}
func (*WaiterMsgRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{15}
}
func (m *WaiterMsgRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WaiterMsgRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WaiterMsgRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WaiterMsgRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WaiterMsgRequest.Merge(m, src)
}
func (m *WaiterMsgRequest) XXX_Size() int {
	return m.Size()
}
func (m *WaiterMsgRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WaiterMsgRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WaiterMsgRequest proto.InternalMessageInfo

func (m *WaiterMsgRequest) GetMid() int64 {
	if m != nil && m.Mid != nil {
		return *m.Mid
	}
	return 0
}

func (m *WaiterMsgRequest) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type WaiterMsgResponse struct {
	WaiterId             *int64   `protobuf:"varint,1,opt,name=WaiterId" json:"WaiterId,omitempty" bson:"WaiterId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *WaiterMsgResponse) Reset()         { *m = WaiterMsgResponse{} }
func (m *WaiterMsgResponse) String() string { return proto.CompactTextString(m) }
func (*WaiterMsgResponse) ProtoMessage()    {}
func (*WaiterMsgResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{16}
}
func (m *WaiterMsgResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WaiterMsgResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WaiterMsgResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WaiterMsgResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WaiterMsgResponse.Merge(m, src)
}
func (m *WaiterMsgResponse) XXX_Size() int {
	return m.Size()
}
func (m *WaiterMsgResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WaiterMsgResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WaiterMsgResponse proto.InternalMessageInfo

func (m *WaiterMsgResponse) GetWaiterId() int64 {
	if m != nil && m.WaiterId != nil {
		return *m.WaiterId
	}
	return 0
}

type WaiterTypesResponse struct {
	List                 []*share_message.ManagerTypes `protobuf:"bytes,1,rep,name=List" json:"List,omitempty" bson:"List,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-" bson:"-"`
	XXX_unrecognized     []byte                        `json:"-" bson:"-"`
	XXX_sizecache        int32                         `json:"-" bson:"-"`
}

func (m *WaiterTypesResponse) Reset()         { *m = WaiterTypesResponse{} }
func (m *WaiterTypesResponse) String() string { return proto.CompactTextString(m) }
func (*WaiterTypesResponse) ProtoMessage()    {}
func (*WaiterTypesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{17}
}
func (m *WaiterTypesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WaiterTypesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WaiterTypesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WaiterTypesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WaiterTypesResponse.Merge(m, src)
}
func (m *WaiterTypesResponse) XXX_Size() int {
	return m.Size()
}
func (m *WaiterTypesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WaiterTypesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WaiterTypesResponse proto.InternalMessageInfo

func (m *WaiterTypesResponse) GetList() []*share_message.ManagerTypes {
	if m != nil {
		return m.List
	}
	return nil
}

type SearchFaqRequest struct {
	Key                  *string  `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty" bson:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *SearchFaqRequest) Reset()         { *m = SearchFaqRequest{} }
func (m *SearchFaqRequest) String() string { return proto.CompactTextString(m) }
func (*SearchFaqRequest) ProtoMessage()    {}
func (*SearchFaqRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{18}
}
func (m *SearchFaqRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchFaqRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchFaqRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchFaqRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchFaqRequest.Merge(m, src)
}
func (m *SearchFaqRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchFaqRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchFaqRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchFaqRequest proto.InternalMessageInfo

func (m *SearchFaqRequest) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

type SearchFaqResponse struct {
	List                 []*share_message.WaiterFAQ `protobuf:"bytes,1,rep,name=List" json:"List,omitempty" bson:"List,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-" bson:"-"`
	XXX_unrecognized     []byte                     `json:"-" bson:"-"`
	XXX_sizecache        int32                      `json:"-" bson:"-"`
}

func (m *SearchFaqResponse) Reset()         { *m = SearchFaqResponse{} }
func (m *SearchFaqResponse) String() string { return proto.CompactTextString(m) }
func (*SearchFaqResponse) ProtoMessage()    {}
func (*SearchFaqResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{19}
}
func (m *SearchFaqResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchFaqResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchFaqResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchFaqResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchFaqResponse.Merge(m, src)
}
func (m *SearchFaqResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchFaqResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchFaqResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchFaqResponse proto.InternalMessageInfo

func (m *SearchFaqResponse) GetList() []*share_message.WaiterFAQ {
	if m != nil {
		return m.List
	}
	return nil
}

type OpenFaqRequest struct {
	Id                   *int32   `protobuf:"varint,1,opt,name=id" json:"id,omitempty" bson:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *OpenFaqRequest) Reset()         { *m = OpenFaqRequest{} }
func (m *OpenFaqRequest) String() string { return proto.CompactTextString(m) }
func (*OpenFaqRequest) ProtoMessage()    {}
func (*OpenFaqRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{20}
}
func (m *OpenFaqRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenFaqRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenFaqRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenFaqRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenFaqRequest.Merge(m, src)
}
func (m *OpenFaqRequest) XXX_Size() int {
	return m.Size()
}
func (m *OpenFaqRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenFaqRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OpenFaqRequest proto.InternalMessageInfo

func (m *OpenFaqRequest) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

type BroadCastQTX struct {
	PlayerId             *int64   `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	TeamId               *int64   `protobuf:"varint,2,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	PropsId              *int64   `protobuf:"varint,3,opt,name=PropsId" json:"PropsId,omitempty" bson:"PropsId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *BroadCastQTX) Reset()         { *m = BroadCastQTX{} }
func (m *BroadCastQTX) String() string { return proto.CompactTextString(m) }
func (*BroadCastQTX) ProtoMessage()    {}
func (*BroadCastQTX) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{21}
}
func (m *BroadCastQTX) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadCastQTX) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadCastQTX.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BroadCastQTX) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadCastQTX.Merge(m, src)
}
func (m *BroadCastQTX) XXX_Size() int {
	return m.Size()
}
func (m *BroadCastQTX) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadCastQTX.DiscardUnknown(m)
}

var xxx_messageInfo_BroadCastQTX proto.InternalMessageInfo

func (m *BroadCastQTX) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *BroadCastQTX) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *BroadCastQTX) GetPropsId() int64 {
	if m != nil && m.PropsId != nil {
		return *m.PropsId
	}
	return 0
}

//前端会话数据
type SessionData struct {
	Id                   *string                        `protobuf:"bytes,1,opt,name=Id" json:"Id,omitempty" bson:"Id,omitempty"`
	Type                 *int32                         `protobuf:"varint,2,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	TargetId             *int64                         `protobuf:"varint,3,opt,name=TargetId" json:"TargetId,omitempty" bson:"TargetId,omitempty"`
	PlayerNum            *int32                         `protobuf:"varint,4,opt,name=PlayerNum" json:"PlayerNum,omitempty" bson:"PlayerNum,omitempty"`
	SessionName          *string                        `protobuf:"bytes,5,opt,name=SessionName" json:"SessionName,omitempty" bson:"SessionName,omitempty"`
	SessionHeadUrl       *string                        `protobuf:"bytes,6,opt,name=SessionHeadUrl" json:"SessionHeadUrl,omitempty" bson:"SessionHeadUrl,omitempty"`
	PersonalChat         *share_message.PersonalChatLog `protobuf:"bytes,7,opt,name=PersonalChat" json:"PersonalChat,omitempty" bson:"PersonalChat,omitempty"`
	TeamChat             *share_message.TeamChatLog     `protobuf:"bytes,8,opt,name=TeamChat" json:"TeamChat,omitempty" bson:"TeamChat,omitempty"`
	IsNotice             *bool                          `protobuf:"varint,9,opt,name=IsNotice" json:"IsNotice,omitempty" bson:"IsNotice,omitempty"`
	MaxLogId             *int64                         `protobuf:"varint,10,opt,name=MaxLogId" json:"MaxLogId,omitempty" bson:"MaxLogId,omitempty"`
	ReadId               *int64                         `protobuf:"varint,11,opt,name=ReadId" json:"ReadId,omitempty" bson:"ReadId,omitempty"`
	NewNum               *int64                         `protobuf:"varint,12,opt,name=NewNum" json:"NewNum,omitempty" bson:"NewNum,omitempty"`
	IsTopChat            *bool                          `protobuf:"varint,13,opt,name=IsTopChat" json:"IsTopChat,omitempty" bson:"IsTopChat,omitempty"`
	IsNoDisturb          *bool                          `protobuf:"varint,14,opt,name=IsNoDisturb" json:"IsNoDisturb,omitempty" bson:"IsNoDisturb,omitempty"`
	IsSaveAdd            *bool                          `protobuf:"varint,15,opt,name=IsSaveAdd" json:"IsSaveAdd,omitempty" bson:"IsSaveAdd,omitempty"`
	IsAfterReadClear     *bool                          `protobuf:"varint,16,opt,name=IsAfterReadClear" json:"IsAfterReadClear,omitempty" bson:"IsAfterReadClear,omitempty"`
	IsScreenShotNotify   *bool                          `protobuf:"varint,17,opt,name=IsScreenShotNotify" json:"IsScreenShotNotify,omitempty" bson:"IsScreenShotNotify,omitempty"`
	TeamName             *string                        `protobuf:"bytes,18,opt,name=TeamName" json:"TeamName,omitempty" bson:"TeamName,omitempty"`
	WithdrawList         []int64                        `protobuf:"varint,19,rep,name=WithdrawList" json:"WithdrawList,omitempty" bson:"WithdrawList,omitempty"`
	TeamOptLog           []*share_message.TeamChatLog   `protobuf:"bytes,20,rep,name=TeamOptLog" json:"TeamOptLog,omitempty" bson:"TeamOptLog,omitempty"`
	Topic                *string                        `protobuf:"bytes,21,opt,name=Topic" json:"Topic,omitempty" bson:"Topic,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-" bson:"-"`
	XXX_unrecognized     []byte                         `json:"-" bson:"-"`
	XXX_sizecache        int32                          `json:"-" bson:"-"`
}

func (m *SessionData) Reset()         { *m = SessionData{} }
func (m *SessionData) String() string { return proto.CompactTextString(m) }
func (*SessionData) ProtoMessage()    {}
func (*SessionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{22}
}
func (m *SessionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionData.Merge(m, src)
}
func (m *SessionData) XXX_Size() int {
	return m.Size()
}
func (m *SessionData) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionData.DiscardUnknown(m)
}

var xxx_messageInfo_SessionData proto.InternalMessageInfo

func (m *SessionData) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *SessionData) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *SessionData) GetTargetId() int64 {
	if m != nil && m.TargetId != nil {
		return *m.TargetId
	}
	return 0
}

func (m *SessionData) GetPlayerNum() int32 {
	if m != nil && m.PlayerNum != nil {
		return *m.PlayerNum
	}
	return 0
}

func (m *SessionData) GetSessionName() string {
	if m != nil && m.SessionName != nil {
		return *m.SessionName
	}
	return ""
}

func (m *SessionData) GetSessionHeadUrl() string {
	if m != nil && m.SessionHeadUrl != nil {
		return *m.SessionHeadUrl
	}
	return ""
}

func (m *SessionData) GetPersonalChat() *share_message.PersonalChatLog {
	if m != nil {
		return m.PersonalChat
	}
	return nil
}

func (m *SessionData) GetTeamChat() *share_message.TeamChatLog {
	if m != nil {
		return m.TeamChat
	}
	return nil
}

func (m *SessionData) GetIsNotice() bool {
	if m != nil && m.IsNotice != nil {
		return *m.IsNotice
	}
	return false
}

func (m *SessionData) GetMaxLogId() int64 {
	if m != nil && m.MaxLogId != nil {
		return *m.MaxLogId
	}
	return 0
}

func (m *SessionData) GetReadId() int64 {
	if m != nil && m.ReadId != nil {
		return *m.ReadId
	}
	return 0
}

func (m *SessionData) GetNewNum() int64 {
	if m != nil && m.NewNum != nil {
		return *m.NewNum
	}
	return 0
}

func (m *SessionData) GetIsTopChat() bool {
	if m != nil && m.IsTopChat != nil {
		return *m.IsTopChat
	}
	return false
}

func (m *SessionData) GetIsNoDisturb() bool {
	if m != nil && m.IsNoDisturb != nil {
		return *m.IsNoDisturb
	}
	return false
}

func (m *SessionData) GetIsSaveAdd() bool {
	if m != nil && m.IsSaveAdd != nil {
		return *m.IsSaveAdd
	}
	return false
}

func (m *SessionData) GetIsAfterReadClear() bool {
	if m != nil && m.IsAfterReadClear != nil {
		return *m.IsAfterReadClear
	}
	return false
}

func (m *SessionData) GetIsScreenShotNotify() bool {
	if m != nil && m.IsScreenShotNotify != nil {
		return *m.IsScreenShotNotify
	}
	return false
}

func (m *SessionData) GetTeamName() string {
	if m != nil && m.TeamName != nil {
		return *m.TeamName
	}
	return ""
}

func (m *SessionData) GetWithdrawList() []int64 {
	if m != nil {
		return m.WithdrawList
	}
	return nil
}

func (m *SessionData) GetTeamOptLog() []*share_message.TeamChatLog {
	if m != nil {
		return m.TeamOptLog
	}
	return nil
}

func (m *SessionData) GetTopic() string {
	if m != nil && m.Topic != nil {
		return *m.Topic
	}
	return ""
}

//所有会话
type AllSessionData struct {
	Type                 *int32         `protobuf:"varint,1,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	Sessions             []*SessionData `protobuf:"bytes,2,rep,name=Sessions" json:"Sessions,omitempty" bson:"Sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-" bson:"-"`
	XXX_unrecognized     []byte         `json:"-" bson:"-"`
	XXX_sizecache        int32          `json:"-" bson:"-"`
}

func (m *AllSessionData) Reset()         { *m = AllSessionData{} }
func (m *AllSessionData) String() string { return proto.CompactTextString(m) }
func (*AllSessionData) ProtoMessage()    {}
func (*AllSessionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{23}
}
func (m *AllSessionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllSessionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllSessionData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllSessionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllSessionData.Merge(m, src)
}
func (m *AllSessionData) XXX_Size() int {
	return m.Size()
}
func (m *AllSessionData) XXX_DiscardUnknown() {
	xxx_messageInfo_AllSessionData.DiscardUnknown(m)
}

var xxx_messageInfo_AllSessionData proto.InternalMessageInfo

func (m *AllSessionData) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *AllSessionData) GetSessions() []*SessionData {
	if m != nil {
		return m.Sessions
	}
	return nil
}

//会话的聊天数据
type SessionChatData struct {
	SessionId            *string                          `protobuf:"bytes,1,opt,name=SessionId" json:"SessionId,omitempty" bson:"SessionId,omitempty"`
	StartId              *int64                           `protobuf:"varint,2,opt,name=StartId" json:"StartId,omitempty" bson:"StartId,omitempty"`
	EndId                *int64                           `protobuf:"varint,3,opt,name=EndId" json:"EndId,omitempty" bson:"EndId,omitempty"`
	PersonalChatLogs     []*share_message.PersonalChatLog `protobuf:"bytes,4,rep,name=PersonalChatLogs" json:"PersonalChatLogs,omitempty" bson:"PersonalChatLogs,omitempty"`
	TeamChatLogs         []*share_message.TeamChatLog     `protobuf:"bytes,5,rep,name=TeamChatLogs" json:"TeamChatLogs,omitempty" bson:"TeamChatLogs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-" bson:"-"`
	XXX_unrecognized     []byte                           `json:"-" bson:"-"`
	XXX_sizecache        int32                            `json:"-" bson:"-"`
}

func (m *SessionChatData) Reset()         { *m = SessionChatData{} }
func (m *SessionChatData) String() string { return proto.CompactTextString(m) }
func (*SessionChatData) ProtoMessage()    {}
func (*SessionChatData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{24}
}
func (m *SessionChatData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionChatData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionChatData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionChatData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionChatData.Merge(m, src)
}
func (m *SessionChatData) XXX_Size() int {
	return m.Size()
}
func (m *SessionChatData) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionChatData.DiscardUnknown(m)
}

var xxx_messageInfo_SessionChatData proto.InternalMessageInfo

func (m *SessionChatData) GetSessionId() string {
	if m != nil && m.SessionId != nil {
		return *m.SessionId
	}
	return ""
}

func (m *SessionChatData) GetStartId() int64 {
	if m != nil && m.StartId != nil {
		return *m.StartId
	}
	return 0
}

func (m *SessionChatData) GetEndId() int64 {
	if m != nil && m.EndId != nil {
		return *m.EndId
	}
	return 0
}

func (m *SessionChatData) GetPersonalChatLogs() []*share_message.PersonalChatLog {
	if m != nil {
		return m.PersonalChatLogs
	}
	return nil
}

func (m *SessionChatData) GetTeamChatLogs() []*share_message.TeamChatLog {
	if m != nil {
		return m.TeamChatLogs
	}
	return nil
}

//获取群成员数据
type TeamMemberData struct {
	TeamId               *int64                            `protobuf:"varint,1,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	Page                 *int32                            `protobuf:"varint,2,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	Data                 []*share_message.PersonalTeamData `protobuf:"bytes,3,rep,name=Data" json:"Data,omitempty" bson:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-" bson:"-"`
	XXX_unrecognized     []byte                            `json:"-" bson:"-"`
	XXX_sizecache        int32                             `json:"-" bson:"-"`
}

func (m *TeamMemberData) Reset()         { *m = TeamMemberData{} }
func (m *TeamMemberData) String() string { return proto.CompactTextString(m) }
func (*TeamMemberData) ProtoMessage()    {}
func (*TeamMemberData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{25}
}
func (m *TeamMemberData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TeamMemberData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TeamMemberData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TeamMemberData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TeamMemberData.Merge(m, src)
}
func (m *TeamMemberData) XXX_Size() int {
	return m.Size()
}
func (m *TeamMemberData) XXX_DiscardUnknown() {
	xxx_messageInfo_TeamMemberData.DiscardUnknown(m)
}

var xxx_messageInfo_TeamMemberData proto.InternalMessageInfo

func (m *TeamMemberData) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *TeamMemberData) GetPage() int32 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

func (m *TeamMemberData) GetData() []*share_message.PersonalTeamData {
	if m != nil {
		return m.Data
	}
	return nil
}

type TeamDetailData struct {
	TeamId               *int64                  `protobuf:"varint,1,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	Team                 *share_message.TeamData `protobuf:"bytes,2,opt,name=Team" json:"Team,omitempty" bson:"Team,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-" bson:"-"`
	XXX_unrecognized     []byte                  `json:"-" bson:"-"`
	XXX_sizecache        int32                   `json:"-" bson:"-"`
}

func (m *TeamDetailData) Reset()         { *m = TeamDetailData{} }
func (m *TeamDetailData) String() string { return proto.CompactTextString(m) }
func (*TeamDetailData) ProtoMessage()    {}
func (*TeamDetailData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{26}
}
func (m *TeamDetailData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TeamDetailData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TeamDetailData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TeamDetailData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TeamDetailData.Merge(m, src)
}
func (m *TeamDetailData) XXX_Size() int {
	return m.Size()
}
func (m *TeamDetailData) XXX_DiscardUnknown() {
	xxx_messageInfo_TeamDetailData.DiscardUnknown(m)
}

var xxx_messageInfo_TeamDetailData proto.InternalMessageInfo

func (m *TeamDetailData) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *TeamDetailData) GetTeam() *share_message.TeamData {
	if m != nil {
		return m.Team
	}
	return nil
}

//群@数据请求
type TeamAtData struct {
	TeamId               *int64    `protobuf:"varint,1,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	Data                 []*AtData `protobuf:"bytes,2,rep,name=Data" json:"Data,omitempty" bson:"Data,omitempty"`
	Page                 *int32    `protobuf:"varint,3,opt,name=Page" json:"Page,omitempty" bson:"Page,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" bson:"-"`
	XXX_unrecognized     []byte    `json:"-" bson:"-"`
	XXX_sizecache        int32     `json:"-" bson:"-"`
}

func (m *TeamAtData) Reset()         { *m = TeamAtData{} }
func (m *TeamAtData) String() string { return proto.CompactTextString(m) }
func (*TeamAtData) ProtoMessage()    {}
func (*TeamAtData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{27}
}
func (m *TeamAtData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TeamAtData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TeamAtData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TeamAtData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TeamAtData.Merge(m, src)
}
func (m *TeamAtData) XXX_Size() int {
	return m.Size()
}
func (m *TeamAtData) XXX_DiscardUnknown() {
	xxx_messageInfo_TeamAtData.DiscardUnknown(m)
}

var xxx_messageInfo_TeamAtData proto.InternalMessageInfo

func (m *TeamAtData) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *TeamAtData) GetData() []*AtData {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *TeamAtData) GetPage() int32 {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return 0
}

type AtData struct {
	PlayerId             *int64   `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	Name                 *string  `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty" bson:"Name,omitempty"`
	HeadUrl              *string  `protobuf:"bytes,3,opt,name=HeadUrl" json:"HeadUrl,omitempty" bson:"HeadUrl,omitempty"`
	Sex                  *int32   `protobuf:"varint,4,opt,name=Sex" json:"Sex,omitempty" bson:"Sex,omitempty"`
	Position             *int32   `protobuf:"varint,5,opt,name=Position" json:"Position,omitempty" bson:"Position,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *AtData) Reset()         { *m = AtData{} }
func (m *AtData) String() string { return proto.CompactTextString(m) }
func (*AtData) ProtoMessage()    {}
func (*AtData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{28}
}
func (m *AtData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtData.Merge(m, src)
}
func (m *AtData) XXX_Size() int {
	return m.Size()
}
func (m *AtData) XXX_DiscardUnknown() {
	xxx_messageInfo_AtData.DiscardUnknown(m)
}

var xxx_messageInfo_AtData proto.InternalMessageInfo

func (m *AtData) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *AtData) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AtData) GetHeadUrl() string {
	if m != nil && m.HeadUrl != nil {
		return *m.HeadUrl
	}
	return ""
}

func (m *AtData) GetSex() int32 {
	if m != nil && m.Sex != nil {
		return *m.Sex
	}
	return 0
}

func (m *AtData) GetPosition() int32 {
	if m != nil && m.Position != nil {
		return *m.Position
	}
	return 0
}

type CheckTeamMember struct {
	PlayerId             *int64       `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	TeamId               *int64       `protobuf:"varint,2,opt,name=TeamId" json:"TeamId,omitempty" bson:"TeamId,omitempty"`
	IsMember             *bool        `protobuf:"varint,3,opt,name=IsMember" json:"IsMember,omitempty" bson:"IsMember,omitempty"`
	Session              *SessionData `protobuf:"bytes,4,opt,name=session" json:"session,omitempty" bson:"session,omitempty"`
	Owner                *AtData      `protobuf:"bytes,5,opt,name=Owner" json:"Owner,omitempty" bson:"Owner,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-" bson:"-"`
	XXX_unrecognized     []byte       `json:"-" bson:"-"`
	XXX_sizecache        int32        `json:"-" bson:"-"`
}

func (m *CheckTeamMember) Reset()         { *m = CheckTeamMember{} }
func (m *CheckTeamMember) String() string { return proto.CompactTextString(m) }
func (*CheckTeamMember) ProtoMessage()    {}
func (*CheckTeamMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{29}
}
func (m *CheckTeamMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckTeamMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckTeamMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckTeamMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckTeamMember.Merge(m, src)
}
func (m *CheckTeamMember) XXX_Size() int {
	return m.Size()
}
func (m *CheckTeamMember) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckTeamMember.DiscardUnknown(m)
}

var xxx_messageInfo_CheckTeamMember proto.InternalMessageInfo

func (m *CheckTeamMember) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *CheckTeamMember) GetTeamId() int64 {
	if m != nil && m.TeamId != nil {
		return *m.TeamId
	}
	return 0
}

func (m *CheckTeamMember) GetIsMember() bool {
	if m != nil && m.IsMember != nil {
		return *m.IsMember
	}
	return false
}

func (m *CheckTeamMember) GetSession() *SessionData {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *CheckTeamMember) GetOwner() *AtData {
	if m != nil {
		return m.Owner
	}
	return nil
}

type CheckIsMySession struct {
	PlayerId             *int64   `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	SessionId            *string  `protobuf:"bytes,2,opt,name=SessionId" json:"SessionId,omitempty" bson:"SessionId,omitempty"`
	Result               *bool    `protobuf:"varint,3,opt,name=Result" json:"Result,omitempty" bson:"Result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *CheckIsMySession) Reset()         { *m = CheckIsMySession{} }
func (m *CheckIsMySession) String() string { return proto.CompactTextString(m) }
func (*CheckIsMySession) ProtoMessage()    {}
func (*CheckIsMySession) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{30}
}
func (m *CheckIsMySession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckIsMySession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckIsMySession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckIsMySession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckIsMySession.Merge(m, src)
}
func (m *CheckIsMySession) XXX_Size() int {
	return m.Size()
}
func (m *CheckIsMySession) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckIsMySession.DiscardUnknown(m)
}

var xxx_messageInfo_CheckIsMySession proto.InternalMessageInfo

func (m *CheckIsMySession) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *CheckIsMySession) GetSessionId() string {
	if m != nil && m.SessionId != nil {
		return *m.SessionId
	}
	return ""
}

func (m *CheckIsMySession) GetResult() bool {
	if m != nil && m.Result != nil {
		return *m.Result
	}
	return false
}

type GetOneShowLog struct {
	LogId                *int64                     `protobuf:"varint,1,opt,name=LogId" json:"LogId,omitempty" bson:"LogId,omitempty"`
	SessionId            *string                    `protobuf:"bytes,2,opt,name=SessionId" json:"SessionId,omitempty" bson:"SessionId,omitempty"`
	Log                  *share_message.TeamChatLog `protobuf:"bytes,3,opt,name=Log" json:"Log,omitempty" bson:"Log,omitempty"`
	ReadId               *int64                     `protobuf:"varint,4,opt,name=ReadId" json:"ReadId,omitempty" bson:"ReadId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-" bson:"-"`
	XXX_unrecognized     []byte                     `json:"-" bson:"-"`
	XXX_sizecache        int32                      `json:"-" bson:"-"`
}

func (m *GetOneShowLog) Reset()         { *m = GetOneShowLog{} }
func (m *GetOneShowLog) String() string { return proto.CompactTextString(m) }
func (*GetOneShowLog) ProtoMessage()    {}
func (*GetOneShowLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{31}
}
func (m *GetOneShowLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOneShowLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOneShowLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOneShowLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOneShowLog.Merge(m, src)
}
func (m *GetOneShowLog) XXX_Size() int {
	return m.Size()
}
func (m *GetOneShowLog) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOneShowLog.DiscardUnknown(m)
}

var xxx_messageInfo_GetOneShowLog proto.InternalMessageInfo

func (m *GetOneShowLog) GetLogId() int64 {
	if m != nil && m.LogId != nil {
		return *m.LogId
	}
	return 0
}

func (m *GetOneShowLog) GetSessionId() string {
	if m != nil && m.SessionId != nil {
		return *m.SessionId
	}
	return ""
}

func (m *GetOneShowLog) GetLog() *share_message.TeamChatLog {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *GetOneShowLog) GetReadId() int64 {
	if m != nil && m.ReadId != nil {
		return *m.ReadId
	}
	return 0
}

//聊天框内动态结构
type ChatDynamic struct {
	LogId                *int64                 `protobuf:"varint,1,opt,name=LogId" json:"LogId,omitempty" bson:"LogId,omitempty"`
	PlayerId             *int64                 `protobuf:"varint,2,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	HeadIcon             *string                `protobuf:"bytes,3,opt,name=HeadIcon" json:"HeadIcon,omitempty" bson:"HeadIcon,omitempty"`
	Sex                  *int32                 `protobuf:"varint,4,opt,name=Sex" json:"Sex,omitempty" bson:"Sex,omitempty"`
	Content              *string                `protobuf:"bytes,5,opt,name=Content" json:"Content,omitempty" bson:"Content,omitempty"`
	Photo                []string               `protobuf:"bytes,6,rep,name=Photo" json:"Photo,omitempty" bson:"Photo,omitempty"`
	Voice                *string                `protobuf:"bytes,7,opt,name=Voice" json:"Voice,omitempty" bson:"Voice,omitempty"`
	Video                *string                `protobuf:"bytes,8,opt,name=Video" json:"Video,omitempty" bson:"Video,omitempty"`
	VoiceTime            *int64                 `protobuf:"varint,9,opt,name=VoiceTime" json:"VoiceTime,omitempty" bson:"VoiceTime,omitempty"`
	NickName             *string                `protobuf:"bytes,10,opt,name=NickName" json:"NickName,omitempty" bson:"NickName,omitempty"`
	VideoThumbnailURL    *string                `protobuf:"bytes,11,opt,name=VideoThumbnailURL" json:"VideoThumbnailURL,omitempty" bson:"VideoThumbnailURL,omitempty"`
	SendTime             *int64                 `protobuf:"varint,12,opt,name=SendTime" json:"SendTime,omitempty" bson:"SendTime,omitempty"`
	TopicId              []int64                `protobuf:"varint,13,rep,name=TopicId" json:"TopicId,omitempty" bson:"TopicId,omitempty"`
	TopicList            []*share_message.Topic `protobuf:"bytes,14,rep,name=TopicList" json:"TopicList,omitempty" bson:"TopicList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-" bson:"-"`
	XXX_unrecognized     []byte                 `json:"-" bson:"-"`
	XXX_sizecache        int32                  `json:"-" bson:"-"`
}

func (m *ChatDynamic) Reset()         { *m = ChatDynamic{} }
func (m *ChatDynamic) String() string { return proto.CompactTextString(m) }
func (*ChatDynamic) ProtoMessage()    {}
func (*ChatDynamic) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{32}
}
func (m *ChatDynamic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatDynamic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatDynamic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatDynamic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatDynamic.Merge(m, src)
}
func (m *ChatDynamic) XXX_Size() int {
	return m.Size()
}
func (m *ChatDynamic) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatDynamic.DiscardUnknown(m)
}

var xxx_messageInfo_ChatDynamic proto.InternalMessageInfo

func (m *ChatDynamic) GetLogId() int64 {
	if m != nil && m.LogId != nil {
		return *m.LogId
	}
	return 0
}

func (m *ChatDynamic) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *ChatDynamic) GetHeadIcon() string {
	if m != nil && m.HeadIcon != nil {
		return *m.HeadIcon
	}
	return ""
}

func (m *ChatDynamic) GetSex() int32 {
	if m != nil && m.Sex != nil {
		return *m.Sex
	}
	return 0
}

func (m *ChatDynamic) GetContent() string {
	if m != nil && m.Content != nil {
		return *m.Content
	}
	return ""
}

func (m *ChatDynamic) GetPhoto() []string {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *ChatDynamic) GetVoice() string {
	if m != nil && m.Voice != nil {
		return *m.Voice
	}
	return ""
}

func (m *ChatDynamic) GetVideo() string {
	if m != nil && m.Video != nil {
		return *m.Video
	}
	return ""
}

func (m *ChatDynamic) GetVoiceTime() int64 {
	if m != nil && m.VoiceTime != nil {
		return *m.VoiceTime
	}
	return 0
}

func (m *ChatDynamic) GetNickName() string {
	if m != nil && m.NickName != nil {
		return *m.NickName
	}
	return ""
}

func (m *ChatDynamic) GetVideoThumbnailURL() string {
	if m != nil && m.VideoThumbnailURL != nil {
		return *m.VideoThumbnailURL
	}
	return ""
}

func (m *ChatDynamic) GetSendTime() int64 {
	if m != nil && m.SendTime != nil {
		return *m.SendTime
	}
	return 0
}

func (m *ChatDynamic) GetTopicId() []int64 {
	if m != nil {
		return m.TopicId
	}
	return nil
}

func (m *ChatDynamic) GetTopicList() []*share_message.Topic {
	if m != nil {
		return m.TopicList
	}
	return nil
}

func init() {
	proto.RegisterType((*CgTeamPerSetting)(nil), "client_hall.CgTeamPerSetting")
	proto.RegisterType((*CgTeamManageSetting)(nil), "client_hall.CgTeamManageSetting")
	proto.RegisterType((*OpenRedPacket)(nil), "client_hall.OpenRedPacket")
	proto.RegisterType((*OpenTransfer)(nil), "client_hall.OpenTransfer")
	proto.RegisterType((*FriendSetting)(nil), "client_hall.FriendSetting")
	proto.RegisterType((*TeamDataInfo)(nil), "client_hall.TeamDataInfo")
	proto.RegisterType((*AllInviteInfo)(nil), "client_hall.AllInviteInfo")
	proto.RegisterType((*DealInviteInfo)(nil), "client_hall.DealInviteInfo")
	proto.RegisterType((*ChangeNameInfo)(nil), "client_hall.ChangeNameInfo")
	proto.RegisterType((*LogInfo)(nil), "client_hall.LogInfo")
	proto.RegisterType((*SpecialChatInfo)(nil), "client_hall.SpecialChatInfo")
	proto.RegisterType((*ChatInfo)(nil), "client_hall.ChatInfo")
	proto.RegisterType((*ReturnChatInfo)(nil), "client_hall.ReturnChatInfo")
	proto.RegisterType((*OperatorMessage)(nil), "client_hall.OperatorMessage")
	proto.RegisterType((*PlayerInfo)(nil), "client_hall.PlayerInfo")
	proto.RegisterType((*WaiterMsgRequest)(nil), "client_hall.WaiterMsgRequest")
	proto.RegisterType((*WaiterMsgResponse)(nil), "client_hall.WaiterMsgResponse")
	proto.RegisterType((*WaiterTypesResponse)(nil), "client_hall.WaiterTypesResponse")
	proto.RegisterType((*SearchFaqRequest)(nil), "client_hall.SearchFaqRequest")
	proto.RegisterType((*SearchFaqResponse)(nil), "client_hall.SearchFaqResponse")
	proto.RegisterType((*OpenFaqRequest)(nil), "client_hall.OpenFaqRequest")
	proto.RegisterType((*BroadCastQTX)(nil), "client_hall.BroadCastQTX")
	proto.RegisterType((*SessionData)(nil), "client_hall.SessionData")
	proto.RegisterType((*AllSessionData)(nil), "client_hall.AllSessionData")
	proto.RegisterType((*SessionChatData)(nil), "client_hall.SessionChatData")
	proto.RegisterType((*TeamMemberData)(nil), "client_hall.TeamMemberData")
	proto.RegisterType((*TeamDetailData)(nil), "client_hall.TeamDetailData")
	proto.RegisterType((*TeamAtData)(nil), "client_hall.TeamAtData")
	proto.RegisterType((*AtData)(nil), "client_hall.AtData")
	proto.RegisterType((*CheckTeamMember)(nil), "client_hall.CheckTeamMember")
	proto.RegisterType((*CheckIsMySession)(nil), "client_hall.CheckIsMySession")
	proto.RegisterType((*GetOneShowLog)(nil), "client_hall.GetOneShowLog")
	proto.RegisterType((*ChatDynamic)(nil), "client_hall.ChatDynamic")
}

func init() { proto.RegisterFile("chat.proto", fileDescriptor_8c585a45e2093e54) }

var fileDescriptor_8c585a45e2093e54 = []byte{
	// 2562 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x59, 0xdf, 0x72, 0xdb, 0xc6,
	0xd5, 0x1f, 0x92, 0xa2, 0x28, 0x1d, 0x52, 0x14, 0x05, 0xd9, 0x31, 0x42, 0x2b, 0x8a, 0x82, 0x99,
	0x7c, 0x71, 0xf2, 0x25, 0x72, 0xaa, 0x76, 0x12, 0xbb, 0x6e, 0x5a, 0x4b, 0x94, 0xa5, 0x50, 0x36,
	0x25, 0x9a, 0x94, 0x63, 0x5f, 0x34, 0xe3, 0xae, 0xc0, 0x15, 0x89, 0x1a, 0x04, 0x68, 0x00, 0x94,
	0xcc, 0xf7, 0xe8, 0x4c, 0x5f, 0xa2, 0x17, 0x9d, 0xe9, 0x4c, 0x27, 0x8f, 0xd0, 0xcb, 0x3e, 0x42,
	0xc7, 0x6f, 0xd1, 0xbb, 0xce, 0x9e, 0xdd, 0x05, 0xb1, 0x0b, 0x90, 0x92, 0x75, 0x27, 0xee, 0xd9,
	0xf3, 0xdb, 0xb3, 0xe7, 0xcf, 0x6f, 0xcf, 0x81, 0x00, 0xec, 0x01, 0x89, 0xb6, 0x47, 0x81, 0x1f,
	0xf9, 0x46, 0xd9, 0x76, 0x1d, 0xea, 0x45, 0xaf, 0x07, 0xc4, 0x75, 0xeb, 0x70, 0x46, 0x42, 0xca,
	0x05, 0xf5, 0x8a, 0xed, 0x0f, 0x87, 0xbe, 0x27, 0x7e, 0xdd, 0xef, 0x93, 0x21, 0x7d, 0x1d, 0xd2,
	0xe0, 0x82, 0x06, 0xf7, 0x71, 0xe9, 0x7e, 0x38, 0x20, 0x01, 0x7d, 0x3d, 0xa4, 0x61, 0x48, 0xfa,
	0xf4, 0x3e, 0x71, 0x5d, 0x45, 0x61, 0xe7, 0x2a, 0x85, 0x88, 0x9c, 0xb9, 0xf4, 0x75, 0x18, 0x05,
	0x63, 0x5b, 0xd8, 0x62, 0x9d, 0x41, 0xad, 0xd1, 0x3f, 0xa5, 0x64, 0xd8, 0xa6, 0x41, 0x97, 0x46,
	0x91, 0xe3, 0xf5, 0x8d, 0x2a, 0x2c, 0xb2, 0x95, 0x66, 0xcf, 0xcc, 0x6d, 0xe5, 0xee, 0x15, 0x8c,
	0x0a, 0x2c, 0x9c, 0x4e, 0x46, 0xd4, 0xcc, 0x6f, 0xe5, 0xee, 0x15, 0x8d, 0x15, 0x28, 0xfe, 0x44,
	0xdc, 0x31, 0x35, 0x0b, 0x5b, 0xb9, 0x7b, 0x4b, 0x4c, 0x78, 0x4c, 0x86, 0xd4, 0x5c, 0xd8, 0xca,
	0xdd, 0x5b, 0x36, 0xd6, 0xa1, 0x7c, 0x32, 0x8a, 0xda, 0x2e, 0x99, 0xd0, 0xa0, 0xd9, 0x33, 0x8b,
	0x4c, 0xdf, 0x3a, 0x83, 0x75, 0x7e, 0x46, 0x8b, 0x78, 0xa4, 0x4f, 0x6f, 0x74, 0x4c, 0x15, 0x16,
	0xf1, 0xe7, 0xaf, 0xf0, 0xa0, 0x62, 0xfc, 0x7b, 0x07, 0xcf, 0x58, 0xb6, 0xfe, 0x96, 0x83, 0x95,
	0x93, 0x11, 0xf5, 0x3a, 0xb4, 0xd7, 0x26, 0xf6, 0x1b, 0x1a, 0x19, 0x00, 0xf9, 0x18, 0xba, 0x06,
	0x4b, 0xb1, 0x4d, 0x79, 0xb9, 0x72, 0xec, 0xd8, 0x6f, 0xd0, 0xf4, 0x02, 0x9a, 0x5e, 0x81, 0x85,
	0x43, 0xdf, 0xed, 0x21, 0xfe, 0xd4, 0x98, 0x22, 0x9e, 0x56, 0x83, 0xa5, 0x2e, 0xf5, 0x7a, 0xa8,
	0xbf, 0x28, 0xf5, 0xd9, 0x0a, 0xea, 0x97, 0x50, 0x7f, 0x7a, 0x9d, 0xa5, 0x18, 0xc1, 0x19, 0x52,
	0x73, 0x19, 0x7f, 0xad, 0x40, 0xb1, 0x1b, 0x91, 0x88, 0x9a, 0xc0, 0x00, 0xad, 0x9f, 0xa1, 0xc2,
	0xac, 0x3d, 0x0d, 0x88, 0x17, 0x9e, 0xd3, 0x40, 0x37, 0x36, 0x86, 0xce, 0x23, 0x74, 0xda, 0xd8,
	0x18, 0x2e, 0xf6, 0x06, 0x53, 0x89, 0x3d, 0xfe, 0x7b, 0x58, 0x39, 0x08, 0x1c, 0xea, 0xf5, 0xa4,
	0xaf, 0xe5, 0x75, 0x72, 0xaa, 0x6f, 0xf3, 0xe8, 0xdb, 0xa4, 0x77, 0x0a, 0xa8, 0xff, 0x8f, 0x1c,
	0x54, 0xd8, 0x65, 0xf6, 0x49, 0x44, 0x9a, 0xde, 0xb9, 0x6f, 0x7c, 0x0e, 0x0b, 0xec, 0x37, 0xea,
	0x97, 0x77, 0xee, 0x6c, 0x2b, 0x79, 0xb5, 0x2d, 0xb7, 0x1a, 0xdf, 0x42, 0xa9, 0x45, 0x87, 0x67,
	0x34, 0x08, 0xcd, 0xc2, 0x56, 0xe1, 0x5e, 0x79, 0xe7, 0x53, 0x6d, 0x67, 0x9b, 0x06, 0xa1, 0xef,
	0x11, 0x37, 0xd6, 0x48, 0x47, 0x46, 0x9a, 0xca, 0x6f, 0x26, 0xd3, 0x0b, 0xa3, 0x6c, 0xac, 0x42,
	0xe9, 0x47, 0x4a, 0x7a, 0x2f, 0x02, 0x17, 0xc3, 0xb0, 0x6c, 0x94, 0xa1, 0xd0, 0xa5, 0xef, 0x30,
	0x02, 0x45, 0xeb, 0x11, 0xac, 0xec, 0xba, 0x6e, 0xd3, 0xbb, 0x70, 0x22, 0x8a, 0x56, 0x7f, 0x05,
	0x25, 0x5c, 0x38, 0xf7, 0xcd, 0x1c, 0x9a, 0xf3, 0xb1, 0x66, 0xce, 0x74, 0xaf, 0xb5, 0x0d, 0xd5,
	0x7d, 0x4a, 0x92, 0xda, 0x2b, 0x50, 0x7c, 0xe6, 0xf7, 0xe3, 0xb0, 0xc4, 0x2e, 0xc7, 0xfc, 0xb4,
	0x1e, 0x43, 0xb5, 0x31, 0x20, 0x5e, 0x9f, 0x32, 0xf3, 0x70, 0xbf, 0x9e, 0xcf, 0x99, 0x57, 0x9b,
	0xc6, 0xd0, 0x3a, 0x82, 0x12, 0xc3, 0xcf, 0x38, 0x2a, 0xdb, 0x29, 0x8e, 0xd0, 0x44, 0xf9, 0x29,
	0x09, 0xfa, 0x34, 0x6a, 0x8a, 0x74, 0xb5, 0x7e, 0xc9, 0xc1, 0x6a, 0x77, 0x44, 0x6d, 0x87, 0xb8,
	0x8d, 0x01, 0x89, 0x10, 0x54, 0x8d, 0xf9, 0x34, 0x45, 0xf2, 0x29, 0x8c, 0x82, 0x62, 0xdd, 0x82,
	0xcc, 0x39, 0x86, 0x94, 0x28, 0x82, 0x55, 0x28, 0x9d, 0x8c, 0x68, 0xc0, 0x5c, 0xb0, 0x28, 0x63,
	0x83, 0x46, 0x95, 0x50, 0x7d, 0x0d, 0x96, 0x25, 0x60, 0x68, 0x2e, 0x6d, 0x15, 0xf8, 0x92, 0xd0,
	0x68, 0xf6, 0x44, 0x1d, 0xd4, 0x60, 0xe9, 0xc4, 0x7b, 0xe6, 0x78, 0x6c, 0x05, 0xd8, 0x26, 0xeb,
	0x88, 0x1f, 0x84, 0x26, 0xaf, 0x42, 0xa9, 0x1b, 0x91, 0x20, 0x8a, 0x3d, 0x51, 0x85, 0xc5, 0x93,
	0x8b, 0x84, 0x1f, 0xa6, 0x3e, 0x2e, 0xc8, 0xa0, 0x34, 0xfc, 0xb1, 0x17, 0xf1, 0x6c, 0xb1, 0x5a,
	0x50, 0xed, 0xd0, 0x68, 0x1c, 0x78, 0x31, 0xe2, 0xd7, 0x1c, 0xfd, 0x99, 0x13, 0x46, 0x22, 0x07,
	0xea, 0x19, 0xc9, 0x8b, 0x5b, 0xfc, 0xfe, 0x14, 0x8e, 0xc7, 0xf8, 0x2f, 0x39, 0x58, 0xe5, 0x17,
	0xf0, 0x83, 0x16, 0xdf, 0x1e, 0x7b, 0x29, 0x27, 0x13, 0x52, 0x26, 0x7c, 0x7e, 0xab, 0xa0, 0xb0,
	0x40, 0xec, 0xd4, 0x03, 0x97, 0xf4, 0x05, 0xab, 0x88, 0xd2, 0x46, 0xaf, 0x15, 0xe5, 0x05, 0x78,
	0xe4, 0x17, 0x53, 0x91, 0x2f, 0x49, 0x1f, 0x36, 0x5c, 0x3f, 0xa4, 0xa8, 0x83, 0xcc, 0x62, 0x1d,
	0x01, 0x88, 0x4d, 0x59, 0x69, 0x27, 0x4f, 0xcc, 0x2b, 0x31, 0x2a, 0xa4, 0xe0, 0x79, 0xe2, 0x7c,
	0x03, 0xb5, 0x97, 0xc4, 0x89, 0x68, 0xd0, 0x0a, 0xfb, 0x1d, 0xfa, 0x76, 0x4c, 0xc3, 0x88, 0x15,
	0x55, 0xcb, 0xc9, 0x64, 0x65, 0xeb, 0x73, 0x58, 0x4b, 0x6c, 0x0f, 0x47, 0xbe, 0x17, 0x52, 0x86,
	0xca, 0x17, 0xa5, 0x0d, 0xd6, 0x63, 0x58, 0xe7, 0x2b, 0x4c, 0x35, 0x8c, 0x37, 0x7e, 0x09, 0x0b,
	0x89, 0x40, 0xdc, 0xd5, 0x02, 0xc1, 0x5f, 0x07, 0xae, 0x62, 0x7d, 0x0a, 0xb5, 0x2e, 0x25, 0x81,
	0x3d, 0x38, 0x20, 0x6f, 0x13, 0x76, 0x3d, 0xa5, 0x13, 0xee, 0x79, 0xeb, 0x11, 0xac, 0x25, 0x36,
	0x88, 0x03, 0xfe, 0x4f, 0x39, 0xc0, 0xd4, 0x0e, 0xe0, 0x26, 0x1d, 0xec, 0x3e, 0xb7, 0x36, 0xa0,
	0xca, 0xe8, 0x37, 0x81, 0x0d, 0x90, 0x17, 0x57, 0x2e, 0x5a, 0xbb, 0x50, 0xd9, 0x0b, 0x7c, 0xd2,
	0x6b, 0x90, 0x30, 0x7a, 0x7e, 0xfa, 0x4a, 0xf1, 0x5a, 0x4e, 0x4b, 0x43, 0x9e, 0x96, 0xab, 0x50,
	0x6a, 0x07, 0xfe, 0x28, 0x8c, 0x09, 0xf4, 0xbf, 0x05, 0x28, 0x77, 0x69, 0x18, 0x3a, 0xbe, 0x87,
	0x34, 0x37, 0xe5, 0xf7, 0x65, 0xed, 0x9d, 0x4b, 0xd7, 0xe1, 0x1a, 0x2c, 0xf3, 0xe3, 0x8e, 0xc7,
	0x43, 0xc1, 0x82, 0xeb, 0x31, 0x5a, 0x82, 0x0c, 0x3f, 0x82, 0xaa, 0x58, 0x54, 0x39, 0xf1, 0x37,
	0x50, 0x91, 0x34, 0xcb, 0xf2, 0x1a, 0xcb, 0xb3, 0xbc, 0xb3, 0x39, 0x83, 0x89, 0x65, 0xea, 0x7f,
	0x0d, 0x4b, 0xb2, 0x12, 0x30, 0xcd, 0xe6, 0x17, 0x4a, 0x0d, 0x96, 0x9a, 0xe1, 0xb1, 0x1f, 0x39,
	0x36, 0x7f, 0xe0, 0xf0, 0x11, 0x69, 0x91, 0x77, 0x3c, 0x97, 0x41, 0x3a, 0xa9, 0x43, 0x09, 0x63,
	0x9c, 0xb2, 0xfc, 0x7d, 0x4c, 0x2f, 0xd9, 0xa5, 0x2a, 0xf2, 0x9e, 0xcd, 0xf0, 0xd4, 0x1f, 0xe1,
	0x91, 0x2b, 0x08, 0xb2, 0x0e, 0x65, 0x06, 0xbb, 0xef, 0x84, 0xd1, 0x38, 0x38, 0x33, 0xab, 0xb8,
	0x88, 0xfb, 0xba, 0xe4, 0x82, 0xee, 0xf6, 0x7a, 0xe6, 0x2a, 0x2e, 0x99, 0x50, 0x6b, 0x86, 0xbb,
	0xe7, 0x11, 0x0d, 0xd8, 0x09, 0x0d, 0x97, 0x92, 0xc0, 0xac, 0xa1, 0xa4, 0x0e, 0x46, 0x33, 0xec,
	0xda, 0x01, 0xa5, 0x5e, 0x77, 0xe0, 0x47, 0xcc, 0xc4, 0xf3, 0x89, 0xb9, 0x26, 0x4d, 0x64, 0x77,
	0x40, 0x17, 0x1a, 0xe8, 0xaa, 0x5b, 0x50, 0x79, 0xe9, 0x44, 0x83, 0x5e, 0x40, 0x2e, 0x31, 0x6f,
	0xd6, 0xb1, 0xe4, 0xb6, 0x01, 0xd8, 0xbe, 0x93, 0x11, 0xbb, 0xaa, 0x79, 0xeb, 0x3a, 0xac, 0x71,
	0xea, 0x8f, 0x1c, 0xdb, 0xbc, 0x2d, 0x78, 0xbd, 0xba, 0xeb, 0xba, 0xc9, 0xe8, 0xab, 0x4c, 0xfc,
	0x15, 0x23, 0x01, 0x14, 0x72, 0xd2, 0x60, 0x89, 0x9a, 0xe8, 0x08, 0xb7, 0x13, 0x9a, 0xd6, 0xdf,
	0x19, 0xaf, 0xf3, 0xdf, 0xec, 0x34, 0x44, 0x5b, 0x83, 0x65, 0xb1, 0x14, 0xa7, 0x54, 0x82, 0x37,
	0xf3, 0x92, 0x56, 0x9e, 0x20, 0xd9, 0xf3, 0x94, 0x7a, 0x00, 0x35, 0x2d, 0xde, 0xa1, 0xb9, 0x80,
	0x47, 0x5f, 0x95, 0x16, 0xdf, 0xf2, 0x46, 0x20, 0xd6, 0x2a, 0x5e, 0xe5, 0x0d, 0xeb, 0x67, 0xa8,
	0x62, 0xaf, 0x87, 0xb4, 0x88, 0x06, 0x67, 0x30, 0x54, 0x9b, 0xf4, 0x65, 0x01, 0x7c, 0x03, 0x0b,
	0x6c, 0xd7, 0x35, 0x1b, 0x06, 0xeb, 0x90, 0xc3, 0xef, 0xd3, 0x88, 0x38, 0x6e, 0x26, 0xbc, 0xec,
	0x55, 0xf2, 0x73, 0x7b, 0x15, 0xab, 0xc5, 0xa3, 0xbc, 0x1b, 0x65, 0x82, 0x7c, 0x26, 0xac, 0xe2,
	0x01, 0x5a, 0x57, 0x02, 0x24, 0x54, 0xe4, 0x35, 0x0a, 0x48, 0x1a, 0xaf, 0x60, 0x51, 0xac, 0xa7,
	0xe9, 0x42, 0xbe, 0x19, 0x79, 0xbd, 0x89, 0x29, 0x24, 0x9b, 0x98, 0x05, 0xc9, 0x07, 0x6d, 0x3f,
	0x74, 0x22, 0xc7, 0xf7, 0xf8, 0xbb, 0x8b, 0xaf, 0x50, 0x63, 0x40, 0xed, 0x37, 0x53, 0xb7, 0x5e,
	0x83, 0x92, 0xb0, 0x42, 0xf9, 0x6e, 0xd1, 0x42, 0x7f, 0x09, 0xa5, 0x90, 0xe7, 0x0d, 0x1e, 0x35,
	0x27, 0xed, 0x0c, 0x0b, 0x8a, 0x27, 0x97, 0x1e, 0x0d, 0xd0, 0x82, 0xec, 0xeb, 0x5b, 0x87, 0x50,
	0x43, 0xab, 0x9a, 0x61, 0x6b, 0x22, 0x74, 0x33, 0xcc, 0x52, 0x92, 0x35, 0x2f, 0x1b, 0xe5, 0x0e,
	0x0d, 0xc7, 0x6e, 0xc4, 0xed, 0xb2, 0xfe, 0x0c, 0x2b, 0x87, 0x34, 0x3a, 0xf1, 0x68, 0x77, 0xe0,
	0x5f, 0x8a, 0x7a, 0x4a, 0x76, 0x43, 0x19, 0x10, 0x5f, 0x40, 0x81, 0x95, 0x66, 0xe1, 0x4a, 0x9e,
	0x9a, 0x72, 0x10, 0x7f, 0xee, 0xfe, 0x9a, 0x87, 0x32, 0x16, 0xd2, 0xc4, 0x23, 0x43, 0xc7, 0xbe,
	0xba, 0xf1, 0xaa, 0xc1, 0x12, 0x0b, 0x56, 0xd3, 0xf6, 0xbd, 0xac, 0x68, 0xad, 0x42, 0xa9, 0xe1,
	0x7b, 0x11, 0xf5, 0x22, 0x41, 0xca, 0x2b, 0x50, 0x6c, 0x0f, 0xfc, 0xc8, 0x37, 0x17, 0xb1, 0x1d,
	0x60, 0x9d, 0xb6, 0xcf, 0x48, 0xb2, 0x24, 0xa5, 0x3f, 0x39, 0x3d, 0xea, 0x23, 0xc3, 0x2e, 0xb3,
	0x9b, 0xa1, 0x34, 0x31, 0x27, 0x24, 0x5b, 0x7d, 0xc0, 0x4d, 0x1f, 0xc3, 0x1a, 0xea, 0x9c, 0x0e,
	0xc6, 0xc3, 0x33, 0x8f, 0x38, 0xee, 0x8b, 0xce, 0x33, 0x64, 0xd4, 0x65, 0xa5, 0x9d, 0xa8, 0xc8,
	0x87, 0x08, 0xa9, 0xa8, 0xd9, 0x33, 0x57, 0x90, 0xcb, 0xbe, 0x80, 0x65, 0x5c, 0x40, 0x7a, 0xab,
	0x62, 0x32, 0xdf, 0xd2, 0xfd, 0xc5, 0xe4, 0x3b, 0xff, 0xbc, 0xcb, 0xb2, 0x8c, 0x44, 0x0d, 0x8c,
	0xf4, 0xce, 0x8f, 0xc4, 0x75, 0x8d, 0xff, 0x87, 0x52, 0x67, 0x64, 0xb3, 0x55, 0x63, 0x5d, 0x53,
	0x62, 0x8b, 0xf5, 0xf2, 0x36, 0x0e, 0xaf, 0x4f, 0x86, 0xa3, 0x68, 0x62, 0x7c, 0x07, 0xd5, 0xce,
	0xc8, 0x66, 0xde, 0x96, 0xad, 0xd2, 0x1d, 0x99, 0x36, 0x7c, 0x24, 0xdd, 0xc6, 0x48, 0x78, 0xe7,
	0xbe, 0xaa, 0xf7, 0x10, 0x6a, 0x9d, 0x91, 0xcd, 0xee, 0x31, 0x9d, 0xdd, 0xf4, 0x97, 0x3b, 0x96,
	0xa8, 0xaa, 0xdf, 0xa3, 0xea, 0x6e, 0xaf, 0x97, 0xa8, 0x8c, 0x8f, 0xb4, 0x43, 0x99, 0xa8, 0x43,
	0xdf, 0xaa, 0x8a, 0xbf, 0x85, 0x75, 0xb4, 0x75, 0xe8, 0x5f, 0xd0, 0x0f, 0xd5, 0x7d, 0x08, 0x6b,
	0x9d, 0x91, 0x7d, 0x48, 0x23, 0x26, 0x95, 0xf3, 0xd5, 0x9d, 0x0c, 0xcd, 0xf4, 0x55, 0xff, 0x00,
	0x77, 0xa6, 0xaa, 0xea, 0x30, 0x7c, 0x3d, 0x80, 0x3f, 0xc2, 0x06, 0x0f, 0x88, 0xd7, 0xa7, 0x62,
	0x68, 0x47, 0x76, 0x94, 0x28, 0x9f, 0x28, 0x85, 0xaa, 0x0f, 0xf6, 0xf5, 0xf9, 0x62, 0xe3, 0x4f,
	0x50, 0x57, 0xd0, 0x55, 0x0b, 0xb7, 0x32, 0x94, 0x95, 0x1d, 0xf5, 0x2b, 0x77, 0x18, 0x0f, 0xd0,
	0x77, 0x32, 0x60, 0xbc, 0xdf, 0xbb, 0x9e, 0xd7, 0xb9, 0xe6, 0x3e, 0x75, 0x3f, 0x58, 0xf3, 0x21,
	0x18, 0xca, 0xad, 0x90, 0xd8, 0xae, 0xa7, 0xfa, 0x08, 0xf3, 0x4b, 0xfd, 0xac, 0x50, 0x57, 0x2e,
	0xa9, 0xc8, 0x54, 0xe5, 0xdf, 0xa1, 0xc5, 0x48, 0x91, 0x37, 0xd0, 0xfe, 0x01, 0x8f, 0x96, 0xdf,
	0x07, 0x5a, 0xbe, 0x47, 0x27, 0xc6, 0x86, 0x5e, 0xb8, 0x49, 0xa9, 0xaa, 0xbe, 0x0b, 0xb7, 0x84,
	0xe5, 0x37, 0x86, 0x78, 0xc0, 0x8b, 0xcb, 0xb6, 0xe9, 0x28, 0x12, 0x11, 0xbb, 0x66, 0x96, 0x72,
	0xcd, 0x0e, 0x3d, 0x1f, 0x87, 0xf4, 0xc3, 0x34, 0xdb, 0xf0, 0x51, 0x1c, 0x2b, 0xf5, 0x03, 0x86,
	0xea, 0x38, 0x45, 0x56, 0x9f, 0x23, 0x33, 0x7e, 0x0d, 0xe5, 0xce, 0xc8, 0x7e, 0xf2, 0xce, 0x89,
	0x3e, 0xc0, 0x8c, 0x63, 0xf4, 0x9e, 0xa8, 0xd3, 0xc4, 0xa8, 0x35, 0x53, 0xfb, 0x93, 0x8c, 0x27,
	0x28, 0xa1, 0x77, 0x88, 0x29, 0x78, 0x48, 0xa3, 0x3d, 0x12, 0x52, 0xa9, 0x34, 0x33, 0x05, 0x3f,
	0x56, 0xae, 0xa3, 0x7c, 0x86, 0x39, 0x91, 0x86, 0x71, 0xf0, 0x06, 0x09, 0x90, 0x50, 0x0d, 0x53,
	0x83, 0xe2, 0x62, 0x06, 0x76, 0x85, 0x65, 0x0d, 0xb4, 0x4c, 0xf6, 0xc0, 0x57, 0x12, 0xf7, 0x2d,
	0xc5, 0x34, 0xf9, 0xf5, 0x62, 0x0f, 0x6e, 0x63, 0xbc, 0x71, 0x92, 0x4a, 0x7c, 0x85, 0x30, 0x36,
	0xd4, 0x06, 0x43, 0xfd, 0x3e, 0xa1, 0xba, 0x9c, 0x63, 0x88, 0xaf, 0x05, 0x37, 0xc4, 0x78, 0x80,
	0x97, 0x11, 0x76, 0xc4, 0x5f, 0x00, 0x6e, 0xab, 0xac, 0x94, 0xa9, 0x79, 0x04, 0xab, 0xdc, 0xaf,
	0xf1, 0x70, 0xab, 0x51, 0xa9, 0x3e, 0x23, 0xd7, 0xf5, 0x17, 0xaa, 0xd9, 0x12, 0x7f, 0x19, 0x07,
	0xf1, 0x7b, 0x36, 0x05, 0x9b, 0xb9, 0x7b, 0x2e, 0x4e, 0xc2, 0xab, 0x89, 0x69, 0xda, 0x48, 0x5a,
	0xae, 0x71, 0x6e, 0xd6, 0xd0, 0xfd, 0x0a, 0x1f, 0x1d, 0x05, 0xa7, 0x4b, 0x83, 0x0b, 0xc7, 0xa6,
	0x57, 0xdd, 0x71, 0x73, 0x96, 0x58, 0x20, 0x7f, 0x8f, 0x2f, 0x3e, 0x5f, 0x3f, 0x0c, 0x48, 0x8f,
	0xce, 0xb9, 0xa7, 0x56, 0xe6, 0xab, 0xe8, 0x22, 0x1c, 0xdf, 0xfd, 0xe0, 0x29, 0x9d, 0x68, 0xa6,
	0xe8, 0xa3, 0xbf, 0x66, 0x4a, 0x7a, 0xf0, 0x3f, 0x44, 0x53, 0xc4, 0x4c, 0xbf, 0x37, 0x69, 0xf6,
	0x8c, 0xbb, 0x29, 0xa6, 0x4d, 0xc0, 0xcd, 0xfc, 0x32, 0x60, 0x3c, 0x44, 0xd3, 0x94, 0xf1, 0x5f,
	0xad, 0xc7, 0xa4, 0x48, 0x6f, 0x80, 0x40, 0x74, 0x4b, 0xc7, 0xf4, 0x32, 0xbb, 0x61, 0xca, 0x5a,
	0x34, 0x5a, 0xb2, 0xa1, 0x48, 0x76, 0xe0, 0xaa, 0xf9, 0xea, 0x3c, 0x59, 0x9f, 0x27, 0x34, 0x9a,
	0xd8, 0xdb, 0x24, 0xe0, 0x70, 0x52, 0x32, 0x66, 0x36, 0xfb, 0xf5, 0xd9, 0x63, 0xc0, 0x89, 0x66,
	0x59, 0x56, 0x41, 0xaa, 0xc3, 0x69, 0x7d, 0xae, 0xd4, 0x68, 0x27, 0x89, 0x35, 0x31, 0x21, 0xde,
	0x4d, 0x51, 0xde, 0x54, 0x58, 0x9f, 0x27, 0x54, 0x11, 0x13, 0x43, 0x61, 0x5a, 0x69, 0x2a, 0xac,
	0xcf, 0x13, 0x1a, 0xfb, 0x58, 0xbf, 0x02, 0x51, 0x8c, 0x74, 0x77, 0x52, 0x0a, 0x5c, 0x50, 0x9f,
	0x25, 0x10, 0x6f, 0xe0, 0x3e, 0x75, 0x69, 0x44, 0x3f, 0xac, 0x1f, 0x7e, 0x9a, 0xbc, 0x91, 0x78,
	0xc6, 0x58, 0x42, 0xcd, 0x7c, 0x7c, 0xb2, 0xe6, 0x1f, 0xf9, 0xfc, 0xbd, 0xc2, 0x96, 0x2e, 0xab,
	0xe3, 0x9c, 0x0b, 0xf9, 0x59, 0x86, 0x40, 0x34, 0x5d, 0x12, 0xf9, 0x48, 0x9a, 0xc9, 0x06, 0xb7,
	0x44, 0xce, 0xdc, 0x24, 0xcf, 0x3a, 0x88, 0x25, 0xa6, 0xc9, 0x44, 0x3f, 0xbe, 0xa1, 0x51, 0xb7,
	0x32, 0x03, 0xd7, 0xe7, 0x4a, 0x8d, 0x3d, 0x6c, 0x25, 0x58, 0xee, 0x12, 0xde, 0xe3, 0xcb, 0x6f,
	0x2e, 0x2a, 0x7f, 0xce, 0x2d, 0xa5, 0x97, 0x48, 0x9d, 0xf1, 0x94, 0x9b, 0x40, 0xd1, 0x3b, 0x6d,
	0x6d, 0x10, 0xae, 0xcf, 0x17, 0x1b, 0x47, 0x32, 0xc7, 0x12, 0x53, 0xaf, 0xda, 0xc5, 0x28, 0xb2,
	0xfa, 0x1c, 0xd9, 0xce, 0x2f, 0x15, 0x3e, 0xb8, 0xb1, 0x89, 0x6d, 0x87, 0x4f, 0x6f, 0xc6, 0x77,
	0xc8, 0x62, 0xf8, 0xfd, 0xde, 0x17, 0x4b, 0x99, 0x7c, 0x54, 0xe5, 0xae, 0x38, 0xf6, 0xf9, 0x57,
	0x73, 0xe3, 0x07, 0xd1, 0xb3, 0x22, 0x85, 0x49, 0x63, 0x67, 0x47, 0x54, 0x57, 0x7f, 0x8c, 0x3e,
	0x4f, 0xe4, 0x5f, 0xcc, 0xcf, 0x59, 0xbd, 0x4e, 0x2b, 0xec, 0xa7, 0x10, 0x9e, 0xe3, 0x80, 0x93,
	0x4a, 0xd6, 0x18, 0xe7, 0xea, 0xc4, 0x4c, 0x41, 0xf2, 0x26, 0x1e, 0x3b, 0xff, 0xb1, 0xe8, 0x9b,
	0x66, 0x27, 0xbe, 0xae, 0xbc, 0x8f, 0x37, 0x52, 0xfa, 0x74, 0xfe, 0xed, 0x62, 0x6e, 0x27, 0xaf,
	0xa3, 0x34, 0xa6, 0x79, 0xa4, 0xc3, 0xcc, 0x9e, 0x74, 0x75, 0x90, 0x23, 0x2c, 0xe5, 0x54, 0x4b,
	0x2f, 0x70, 0xe6, 0x37, 0xf6, 0x3a, 0xd6, 0x1e, 0x16, 0x1c, 0x7e, 0x0c, 0xc5, 0x6f, 0xb8, 0x92,
	0xa1, 0xb2, 0xa8, 0x44, 0xc8, 0x32, 0x72, 0x65, 0x73, 0xda, 0x57, 0xec, 0xee, 0xef, 0x73, 0x1f,
	0x5e, 0x38, 0x11, 0xed, 0x8e, 0x6d, 0x9b, 0x86, 0x5a, 0xa1, 0xe9, 0xea, 0x07, 0x60, 0xf2, 0x21,
	0x21, 0xa0, 0xe1, 0x60, 0xaa, 0x8b, 0x2d, 0x5b, 0x5d, 0x2f, 0xca, 0xa9, 0x2c, 0x23, 0x42, 0xb7,
	0x91, 0x68, 0x89, 0x2b, 0x46, 0x0d, 0xf9, 0x45, 0x5f, 0xad, 0x6c, 0xf5, 0x7f, 0x7b, 0x29, 0x94,
	0x26, 0x3a, 0x37, 0x61, 0x8d, 0x9c, 0xac, 0x8f, 0xc9, 0x90, 0x6a, 0x50, 0xea, 0xbf, 0xfd, 0x32,
	0x8a, 0x80, 0xd5, 0xd0, 0xe9, 0xd8, 0xa3, 0xbd, 0x17, 0xa3, 0x36, 0x99, 0xe0, 0x8d, 0xf4, 0xff,
	0x75, 0xb4, 0xc9, 0xe4, 0x24, 0xe8, 0xf1, 0x26, 0x3c, 0x23, 0x3a, 0xf5, 0x74, 0x53, 0x1e, 0x97,
	0x40, 0x66, 0x0f, 0x9e, 0xc2, 0x68, 0xc1, 0x27, 0x99, 0x3d, 0x79, 0x0c, 0x33, 0xbf, 0xaf, 0xce,
	0x86, 0x4b, 0xb7, 0xe7, 0x37, 0x84, 0xe3, 0x3e, 0xd2, 0xfe, 0x55, 0xa7, 0x7a, 0x59, 0x15, 0xa6,
	0x10, 0x76, 0xb9, 0x97, 0xf9, 0xa7, 0x3e, 0xaf, 0xcf, 0xf3, 0x66, 0x43, 0xaf, 0xc9, 0xe4, 0x7f,
	0xee, 0x32, 0x32, 0x47, 0x16, 0x41, 0x8b, 0xde, 0x1c, 0xe5, 0x11, 0x52, 0xed, 0x31, 0xbd, 0xbc,
	0x4e, 0xb7, 0x9f, 0xad, 0xfc, 0xe4, 0x7a, 0xa3, 0x42, 0xda, 0x89, 0xeb, 0x5a, 0xab, 0xca, 0xa2,
	0x31, 0xaf, 0x5d, 0xd5, 0x10, 0xf6, 0x2a, 0xff, 0x7a, 0xbf, 0x99, 0xfb, 0xf7, 0xfb, 0xcd, 0xdc,
	0x7f, 0xde, 0x6f, 0xe6, 0xfe, 0x17, 0x00, 0x00, 0xff, 0xff, 0x8b, 0xad, 0x08, 0xd1, 0xa3, 0x22,
	0x00, 0x00,
}

func (m *CgTeamPerSetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CgTeamPerSetting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TeamId))
	}
	if m.Type != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Type))
	}
	if m.Value != nil {
		dAtA[i] = 0x18
		i++
		if *m.Value {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Name != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.OptPlayerId != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.OptPlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CgTeamManageSetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CgTeamManageSetting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TeamId))
	}
	if m.Type != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Type))
	}
	if m.Value != nil {
		dAtA[i] = 0x18
		i++
		if *m.Value {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Value1 != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Value1))
	}
	if m.Value2 != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Value2)))
		i += copy(dAtA[i:], *m.Value2)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OpenRedPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenRedPacket) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Id))
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PlayerId))
	}
	if m.NickName != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.NickName)))
		i += copy(dAtA[i:], *m.NickName)
	}
	if m.Gold != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Gold))
	}
	if m.Type != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Type))
	}
	if m.SenderId != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.SenderId))
	}
	if m.SendName != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.SendName)))
		i += copy(dAtA[i:], *m.SendName)
	}
	if m.TeamId != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TeamId))
	}
	if m.Time != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Time))
	}
	if m.State != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.State))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OpenTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenTransfer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Id))
	}
	if m.SendName != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.SendName)))
		i += copy(dAtA[i:], *m.SendName)
	}
	if m.NickName != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.NickName)))
		i += copy(dAtA[i:], *m.NickName)
	}
	if m.State != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.State))
	}
	if m.SendId != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.SendId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FriendSetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FriendSetting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Type))
	}
	if m.Value != nil {
		dAtA[i] = 0x10
		i++
		if *m.Value {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TeamDataInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamDataInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Team != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Team.Size()))
		n1, err := m.Team.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PlayerId))
	}
	if len(m.Members) > 0 {
		for _, msg := range m.Members {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Type != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Type))
	}
	if m.Name != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.HeadUrl != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.HeadUrl)))
		i += copy(dAtA[i:], *m.HeadUrl)
	}
	if m.Sex != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Sex))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllInviteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllInviteInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllInfo) > 0 {
		for _, msg := range m.AllInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DealInviteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DealInviteInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LogId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.LogId))
	}
	if m.State != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.State))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChangeNameInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeNameInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TeamId))
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Name != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LogInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LogId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.LogId))
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Time != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Time))
	}
	if m.TargetId != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TargetId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SpecialChatInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecialChatInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Type))
	}
	if m.SendId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.SendId))
	}
	if m.TargetId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TargetId))
	}
	if m.Name != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.ChatType != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.ChatType))
	}
	if m.Operate != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Operate))
	}
	if m.Time != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Time))
	}
	if len(m.TargetIds) > 0 {
		for _, num := range m.TargetIds {
			dAtA[i] = 0x40
			i++
			i = encodeVarintChat(dAtA, i, uint64(num))
		}
	}
	if m.OperateId != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.OperateId))
	}
	if len(m.OnLineId) > 0 {
		for _, num := range m.OnLineId {
			dAtA[i] = 0x50
			i++
			i = encodeVarintChat(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChatInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.StartId))
	}
	if m.OverId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.OverId))
	}
	if m.TeamId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TeamId))
	}
	if m.Count != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReturnChatInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReturnChatInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatList) > 0 {
		for _, msg := range m.ChatList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OperatorMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.Members) > 0 {
		for _, s := range m.Members {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.TeamId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TeamId))
	}
	if m.Flag != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Flag))
	}
	if m.SendTime != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.SendTime))
	}
	if m.LogId != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.LogId))
	}
	if len(m.PlayerId) > 0 {
		for _, num := range m.PlayerId {
			dAtA[i] = 0x38
			i++
			i = encodeVarintChat(dAtA, i, uint64(num))
		}
	}
	if m.CloseTime != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.CloseTime))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TeamId))
	}
	if m.Flag != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Flag))
	}
	if m.Time != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Time))
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WaiterMsgRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WaiterMsgRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Mid))
	}
	if m.Type != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WaiterMsgResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WaiterMsgResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WaiterId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.WaiterId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WaiterTypesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WaiterTypesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SearchFaqRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchFaqRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SearchFaqResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchFaqResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OpenFaqRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenFaqRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BroadCastQTX) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadCastQTX) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PlayerId))
	}
	if m.TeamId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TeamId))
	}
	if m.PropsId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PropsId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SessionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Type != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Type))
	}
	if m.TargetId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TargetId))
	}
	if m.PlayerNum != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PlayerNum))
	}
	if m.SessionName != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.SessionName)))
		i += copy(dAtA[i:], *m.SessionName)
	}
	if m.SessionHeadUrl != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.SessionHeadUrl)))
		i += copy(dAtA[i:], *m.SessionHeadUrl)
	}
	if m.PersonalChat != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.PersonalChat.Size()))
		n2, err := m.PersonalChat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.TeamChat != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.TeamChat.Size()))
		n3, err := m.TeamChat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.IsNotice != nil {
		dAtA[i] = 0x48
		i++
		if *m.IsNotice {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxLogId != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.MaxLogId))
	}
	if m.ReadId != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.ReadId))
	}
	if m.NewNum != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.NewNum))
	}
	if m.IsTopChat != nil {
		dAtA[i] = 0x68
		i++
		if *m.IsTopChat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsNoDisturb != nil {
		dAtA[i] = 0x70
		i++
		if *m.IsNoDisturb {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsSaveAdd != nil {
		dAtA[i] = 0x78
		i++
		if *m.IsSaveAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsAfterReadClear != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if *m.IsAfterReadClear {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsScreenShotNotify != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if *m.IsScreenShotNotify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TeamName != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.TeamName)))
		i += copy(dAtA[i:], *m.TeamName)
	}
	if len(m.WithdrawList) > 0 {
		for _, num := range m.WithdrawList {
			dAtA[i] = 0x98
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintChat(dAtA, i, uint64(num))
		}
	}
	if len(m.TeamOptLog) > 0 {
		for _, msg := range m.TeamOptLog {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Topic != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Topic)))
		i += copy(dAtA[i:], *m.Topic)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllSessionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllSessionData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Type))
	}
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SessionChatData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionChatData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SessionId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.SessionId)))
		i += copy(dAtA[i:], *m.SessionId)
	}
	if m.StartId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.StartId))
	}
	if m.EndId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.EndId))
	}
	if len(m.PersonalChatLogs) > 0 {
		for _, msg := range m.PersonalChatLogs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TeamChatLogs) > 0 {
		for _, msg := range m.TeamChatLogs {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TeamMemberData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamMemberData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TeamId))
	}
	if m.Page != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Page))
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TeamDetailData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamDetailData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TeamId))
	}
	if m.Team != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Team.Size()))
		n4, err := m.Team.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TeamAtData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamAtData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TeamId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TeamId))
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x12
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Page != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Page))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AtData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PlayerId))
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.HeadUrl != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.HeadUrl)))
		i += copy(dAtA[i:], *m.HeadUrl)
	}
	if m.Sex != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Sex))
	}
	if m.Position != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Position))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckTeamMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckTeamMember) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PlayerId))
	}
	if m.TeamId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.TeamId))
	}
	if m.IsMember != nil {
		dAtA[i] = 0x18
		i++
		if *m.IsMember {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Session != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Session.Size()))
		n5, err := m.Session.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Owner != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Owner.Size()))
		n6, err := m.Owner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckIsMySession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckIsMySession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PlayerId))
	}
	if m.SessionId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.SessionId)))
		i += copy(dAtA[i:], *m.SessionId)
	}
	if m.Result != nil {
		dAtA[i] = 0x18
		i++
		if *m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetOneShowLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOneShowLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LogId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.LogId))
	}
	if m.SessionId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.SessionId)))
		i += copy(dAtA[i:], *m.SessionId)
	}
	if m.Log != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintChat(dAtA, i, uint64(m.Log.Size()))
		n7, err := m.Log.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.ReadId != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.ReadId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChatDynamic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatDynamic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LogId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.LogId))
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.PlayerId))
	}
	if m.HeadIcon != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.HeadIcon)))
		i += copy(dAtA[i:], *m.HeadIcon)
	}
	if m.Sex != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.Sex))
	}
	if m.Content != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Content)))
		i += copy(dAtA[i:], *m.Content)
	}
	if len(m.Photo) > 0 {
		for _, s := range m.Photo {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Voice != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Voice)))
		i += copy(dAtA[i:], *m.Voice)
	}
	if m.Video != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.Video)))
		i += copy(dAtA[i:], *m.Video)
	}
	if m.VoiceTime != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.VoiceTime))
	}
	if m.NickName != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.NickName)))
		i += copy(dAtA[i:], *m.NickName)
	}
	if m.VideoThumbnailURL != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintChat(dAtA, i, uint64(len(*m.VideoThumbnailURL)))
		i += copy(dAtA[i:], *m.VideoThumbnailURL)
	}
	if m.SendTime != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintChat(dAtA, i, uint64(*m.SendTime))
	}
	if len(m.TopicId) > 0 {
		for _, num := range m.TopicId {
			dAtA[i] = 0x68
			i++
			i = encodeVarintChat(dAtA, i, uint64(num))
		}
	}
	if len(m.TopicList) > 0 {
		for _, msg := range m.TopicList {
			dAtA[i] = 0x72
			i++
			i = encodeVarintChat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintChat(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CgTeamPerSetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamId != nil {
		n += 1 + sovChat(uint64(*m.TeamId))
	}
	if m.Type != nil {
		n += 1 + sovChat(uint64(*m.Type))
	}
	if m.Value != nil {
		n += 2
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.OptPlayerId != nil {
		n += 1 + sovChat(uint64(*m.OptPlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CgTeamManageSetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamId != nil {
		n += 1 + sovChat(uint64(*m.TeamId))
	}
	if m.Type != nil {
		n += 1 + sovChat(uint64(*m.Type))
	}
	if m.Value != nil {
		n += 2
	}
	if m.Value1 != nil {
		n += 1 + sovChat(uint64(*m.Value1))
	}
	if m.Value2 != nil {
		l = len(*m.Value2)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenRedPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovChat(uint64(*m.Id))
	}
	if m.PlayerId != nil {
		n += 1 + sovChat(uint64(*m.PlayerId))
	}
	if m.NickName != nil {
		l = len(*m.NickName)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Gold != nil {
		n += 1 + sovChat(uint64(*m.Gold))
	}
	if m.Type != nil {
		n += 1 + sovChat(uint64(*m.Type))
	}
	if m.SenderId != nil {
		n += 1 + sovChat(uint64(*m.SenderId))
	}
	if m.SendName != nil {
		l = len(*m.SendName)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.TeamId != nil {
		n += 1 + sovChat(uint64(*m.TeamId))
	}
	if m.Time != nil {
		n += 1 + sovChat(uint64(*m.Time))
	}
	if m.State != nil {
		n += 1 + sovChat(uint64(*m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovChat(uint64(*m.Id))
	}
	if m.SendName != nil {
		l = len(*m.SendName)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.NickName != nil {
		l = len(*m.NickName)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.State != nil {
		n += 1 + sovChat(uint64(*m.State))
	}
	if m.SendId != nil {
		n += 1 + sovChat(uint64(*m.SendId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FriendSetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovChat(uint64(*m.Type))
	}
	if m.Value != nil {
		n += 2
	}
	if m.PlayerId != nil {
		n += 1 + sovChat(uint64(*m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TeamDataInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Team != nil {
		l = m.Team.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.PlayerId != nil {
		n += 1 + sovChat(uint64(*m.PlayerId))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.Type != nil {
		n += 1 + sovChat(uint64(*m.Type))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.HeadUrl != nil {
		l = len(*m.HeadUrl)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Sex != nil {
		n += 1 + sovChat(uint64(*m.Sex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllInviteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllInfo) > 0 {
		for _, e := range m.AllInfo {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DealInviteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogId != nil {
		n += 1 + sovChat(uint64(*m.LogId))
	}
	if m.State != nil {
		n += 1 + sovChat(uint64(*m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangeNameInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamId != nil {
		n += 1 + sovChat(uint64(*m.TeamId))
	}
	if m.PlayerId != nil {
		n += 1 + sovChat(uint64(*m.PlayerId))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogId != nil {
		n += 1 + sovChat(uint64(*m.LogId))
	}
	if m.PlayerId != nil {
		n += 1 + sovChat(uint64(*m.PlayerId))
	}
	if m.Time != nil {
		n += 1 + sovChat(uint64(*m.Time))
	}
	if m.TargetId != nil {
		n += 1 + sovChat(uint64(*m.TargetId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpecialChatInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovChat(uint64(*m.Type))
	}
	if m.SendId != nil {
		n += 1 + sovChat(uint64(*m.SendId))
	}
	if m.TargetId != nil {
		n += 1 + sovChat(uint64(*m.TargetId))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.ChatType != nil {
		n += 1 + sovChat(uint64(*m.ChatType))
	}
	if m.Operate != nil {
		n += 1 + sovChat(uint64(*m.Operate))
	}
	if m.Time != nil {
		n += 1 + sovChat(uint64(*m.Time))
	}
	if len(m.TargetIds) > 0 {
		for _, e := range m.TargetIds {
			n += 1 + sovChat(uint64(e))
		}
	}
	if m.OperateId != nil {
		n += 1 + sovChat(uint64(*m.OperateId))
	}
	if len(m.OnLineId) > 0 {
		for _, e := range m.OnLineId {
			n += 1 + sovChat(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChatInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartId != nil {
		n += 1 + sovChat(uint64(*m.StartId))
	}
	if m.OverId != nil {
		n += 1 + sovChat(uint64(*m.OverId))
	}
	if m.TeamId != nil {
		n += 1 + sovChat(uint64(*m.TeamId))
	}
	if m.Count != nil {
		n += 1 + sovChat(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReturnChatInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ChatList) > 0 {
		for _, e := range m.ChatList {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.Count != nil {
		n += 1 + sovChat(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OperatorMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovChat(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, s := range m.Members {
			l = len(s)
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.TeamId != nil {
		n += 1 + sovChat(uint64(*m.TeamId))
	}
	if m.Flag != nil {
		n += 1 + sovChat(uint64(*m.Flag))
	}
	if m.SendTime != nil {
		n += 1 + sovChat(uint64(*m.SendTime))
	}
	if m.LogId != nil {
		n += 1 + sovChat(uint64(*m.LogId))
	}
	if len(m.PlayerId) > 0 {
		for _, e := range m.PlayerId {
			n += 1 + sovChat(uint64(e))
		}
	}
	if m.CloseTime != nil {
		n += 1 + sovChat(uint64(*m.CloseTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamId != nil {
		n += 1 + sovChat(uint64(*m.TeamId))
	}
	if m.Flag != nil {
		n += 1 + sovChat(uint64(*m.Flag))
	}
	if m.Time != nil {
		n += 1 + sovChat(uint64(*m.Time))
	}
	if m.PlayerId != nil {
		n += 1 + sovChat(uint64(*m.PlayerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WaiterMsgRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != nil {
		n += 1 + sovChat(uint64(*m.Mid))
	}
	if m.Type != nil {
		n += 1 + sovChat(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WaiterMsgResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WaiterId != nil {
		n += 1 + sovChat(uint64(*m.WaiterId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WaiterTypesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchFaqRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchFaqResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenFaqRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovChat(uint64(*m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BroadCastQTX) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovChat(uint64(*m.PlayerId))
	}
	if m.TeamId != nil {
		n += 1 + sovChat(uint64(*m.TeamId))
	}
	if m.PropsId != nil {
		n += 1 + sovChat(uint64(*m.PropsId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovChat(uint64(*m.Type))
	}
	if m.TargetId != nil {
		n += 1 + sovChat(uint64(*m.TargetId))
	}
	if m.PlayerNum != nil {
		n += 1 + sovChat(uint64(*m.PlayerNum))
	}
	if m.SessionName != nil {
		l = len(*m.SessionName)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.SessionHeadUrl != nil {
		l = len(*m.SessionHeadUrl)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.PersonalChat != nil {
		l = m.PersonalChat.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.TeamChat != nil {
		l = m.TeamChat.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.IsNotice != nil {
		n += 2
	}
	if m.MaxLogId != nil {
		n += 1 + sovChat(uint64(*m.MaxLogId))
	}
	if m.ReadId != nil {
		n += 1 + sovChat(uint64(*m.ReadId))
	}
	if m.NewNum != nil {
		n += 1 + sovChat(uint64(*m.NewNum))
	}
	if m.IsTopChat != nil {
		n += 2
	}
	if m.IsNoDisturb != nil {
		n += 2
	}
	if m.IsSaveAdd != nil {
		n += 2
	}
	if m.IsAfterReadClear != nil {
		n += 3
	}
	if m.IsScreenShotNotify != nil {
		n += 3
	}
	if m.TeamName != nil {
		l = len(*m.TeamName)
		n += 2 + l + sovChat(uint64(l))
	}
	if len(m.WithdrawList) > 0 {
		for _, e := range m.WithdrawList {
			n += 2 + sovChat(uint64(e))
		}
	}
	if len(m.TeamOptLog) > 0 {
		for _, e := range m.TeamOptLog {
			l = e.Size()
			n += 2 + l + sovChat(uint64(l))
		}
	}
	if m.Topic != nil {
		l = len(*m.Topic)
		n += 2 + l + sovChat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllSessionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovChat(uint64(*m.Type))
	}
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionChatData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionId != nil {
		l = len(*m.SessionId)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.StartId != nil {
		n += 1 + sovChat(uint64(*m.StartId))
	}
	if m.EndId != nil {
		n += 1 + sovChat(uint64(*m.EndId))
	}
	if len(m.PersonalChatLogs) > 0 {
		for _, e := range m.PersonalChatLogs {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if len(m.TeamChatLogs) > 0 {
		for _, e := range m.TeamChatLogs {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TeamMemberData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamId != nil {
		n += 1 + sovChat(uint64(*m.TeamId))
	}
	if m.Page != nil {
		n += 1 + sovChat(uint64(*m.Page))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TeamDetailData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamId != nil {
		n += 1 + sovChat(uint64(*m.TeamId))
	}
	if m.Team != nil {
		l = m.Team.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TeamAtData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamId != nil {
		n += 1 + sovChat(uint64(*m.TeamId))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.Page != nil {
		n += 1 + sovChat(uint64(*m.Page))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AtData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovChat(uint64(*m.PlayerId))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.HeadUrl != nil {
		l = len(*m.HeadUrl)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Sex != nil {
		n += 1 + sovChat(uint64(*m.Sex))
	}
	if m.Position != nil {
		n += 1 + sovChat(uint64(*m.Position))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckTeamMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovChat(uint64(*m.PlayerId))
	}
	if m.TeamId != nil {
		n += 1 + sovChat(uint64(*m.TeamId))
	}
	if m.IsMember != nil {
		n += 2
	}
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckIsMySession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovChat(uint64(*m.PlayerId))
	}
	if m.SessionId != nil {
		l = len(*m.SessionId)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Result != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetOneShowLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogId != nil {
		n += 1 + sovChat(uint64(*m.LogId))
	}
	if m.SessionId != nil {
		l = len(*m.SessionId)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Log != nil {
		l = m.Log.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.ReadId != nil {
		n += 1 + sovChat(uint64(*m.ReadId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChatDynamic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogId != nil {
		n += 1 + sovChat(uint64(*m.LogId))
	}
	if m.PlayerId != nil {
		n += 1 + sovChat(uint64(*m.PlayerId))
	}
	if m.HeadIcon != nil {
		l = len(*m.HeadIcon)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Sex != nil {
		n += 1 + sovChat(uint64(*m.Sex))
	}
	if m.Content != nil {
		l = len(*m.Content)
		n += 1 + l + sovChat(uint64(l))
	}
	if len(m.Photo) > 0 {
		for _, s := range m.Photo {
			l = len(s)
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.Voice != nil {
		l = len(*m.Voice)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Video != nil {
		l = len(*m.Video)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.VoiceTime != nil {
		n += 1 + sovChat(uint64(*m.VoiceTime))
	}
	if m.NickName != nil {
		l = len(*m.NickName)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.VideoThumbnailURL != nil {
		l = len(*m.VideoThumbnailURL)
		n += 1 + l + sovChat(uint64(l))
	}
	if m.SendTime != nil {
		n += 1 + sovChat(uint64(*m.SendTime))
	}
	if len(m.TopicId) > 0 {
		for _, e := range m.TopicId {
			n += 1 + sovChat(uint64(e))
		}
	}
	if len(m.TopicList) > 0 {
		for _, e := range m.TopicList {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovChat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozChat(x uint64) (n int) {
	return sovChat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CgTeamPerSetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CgTeamPerSetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CgTeamPerSetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptPlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptPlayerId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CgTeamManageSetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CgTeamManageSetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CgTeamManageSetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value1", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value1 = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value2 = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenRedPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenRedPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenRedPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NickName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gold = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SenderId = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SendName = &s
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Time = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.State = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SendName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NickName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.State = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FriendSetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FriendSetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FriendSetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamDataInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamDataInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamDataInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Team == nil {
				m.Team = &share_message.TeamData{}
			}
			if err := m.Team.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &share_message.PersonalTeamData{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadUrl = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sex = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllInviteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllInviteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllInviteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllInfo = append(m.AllInfo, &share_message.InviteInfo{})
			if err := m.AllInfo[len(m.AllInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DealInviteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DealInviteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DealInviteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.State = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeNameInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeNameInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeNameInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Time = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecialChatInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecialChatInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecialChatInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetId = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChatType = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operate", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Operate = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Time = &v
		case 8:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TargetIds = append(m.TargetIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TargetIds) == 0 {
					m.TargetIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TargetIds = append(m.TargetIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIds", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OperateId = &v
		case 10:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnLineId = append(m.OnLineId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OnLineId) == 0 {
					m.OnLineId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnLineId = append(m.OnLineId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnLineId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReturnChatInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReturnChatInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReturnChatInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatList = append(m.ChatList, &share_message.TeamChatLog{})
			if err := m.ChatList[len(m.ChatList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flag = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendTime = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogId = &v
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PlayerId = append(m.PlayerId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PlayerId) == 0 {
					m.PlayerId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PlayerId = append(m.PlayerId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CloseTime = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flag = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Time = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WaiterMsgRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WaiterMsgRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WaiterMsgRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mid = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WaiterMsgResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WaiterMsgResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WaiterMsgResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaiterId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WaiterId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WaiterTypesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WaiterTypesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WaiterTypesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &share_message.ManagerTypes{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchFaqRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchFaqRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchFaqRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchFaqResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchFaqResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchFaqResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &share_message.WaiterFAQ{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenFaqRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenFaqRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenFaqRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadCastQTX) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadCastQTX: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadCastQTX: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropsId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PropsId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetId = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerNum = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SessionName = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHeadUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SessionHeadUrl = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonalChat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PersonalChat == nil {
				m.PersonalChat = &share_message.PersonalChatLog{}
			}
			if err := m.PersonalChat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamChat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TeamChat == nil {
				m.TeamChat = &share_message.TeamChatLog{}
			}
			if err := m.TeamChat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNotice", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsNotice = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLogId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxLogId = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadId = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNum", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewNum = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTopChat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsTopChat = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNoDisturb", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsNoDisturb = &b
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSaveAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsSaveAdd = &b
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAfterReadClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsAfterReadClear = &b
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsScreenShotNotify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsScreenShotNotify = &b
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TeamName = &s
			iNdEx = postIndex
		case 19:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WithdrawList = append(m.WithdrawList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WithdrawList) == 0 {
					m.WithdrawList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WithdrawList = append(m.WithdrawList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawList", wireType)
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamOptLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeamOptLog = append(m.TeamOptLog, &share_message.TeamChatLog{})
			if err := m.TeamOptLog[len(m.TeamOptLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Topic = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllSessionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllSessionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllSessionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &SessionData{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionChatData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionChatData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionChatData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SessionId = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndId = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonalChatLogs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonalChatLogs = append(m.PersonalChatLogs, &share_message.PersonalChatLog{})
			if err := m.PersonalChatLogs[len(m.PersonalChatLogs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamChatLogs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeamChatLogs = append(m.TeamChatLogs, &share_message.TeamChatLog{})
			if err := m.TeamChatLogs[len(m.TeamChatLogs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamMemberData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamMemberData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamMemberData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &share_message.PersonalTeamData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamDetailData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamDetailData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamDetailData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Team == nil {
				m.Team = &share_message.TeamData{}
			}
			if err := m.Team.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamAtData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamAtData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamAtData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &AtData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Page = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadUrl = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sex = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Position = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckTeamMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckTeamMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckTeamMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TeamId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMember", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsMember = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &SessionData{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owner == nil {
				m.Owner = &AtData{}
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckIsMySession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckIsMySession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckIsMySession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SessionId = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Result = &b
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOneShowLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOneShowLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOneShowLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SessionId = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Log == nil {
				m.Log = &share_message.TeamChatLog{}
			}
			if err := m.Log.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatDynamic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatDynamic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatDynamic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HeadIcon = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sex = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Content = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = append(m.Photo, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Voice = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Video = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VoiceTime = &v
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NickName = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoThumbnailURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VideoThumbnailURL = &s
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendTime = &v
		case 13:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TopicId = append(m.TopicId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TopicId) == 0 {
					m.TopicId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TopicId = append(m.TopicId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicList = append(m.TopicList, &share_message.Topic{})
			if err := m.TopicList[len(m.TopicList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChat
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthChat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowChat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipChat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthChat
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthChat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChat   = fmt.Errorf("proto: integer overflow")
)
