// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: login.proto

package client_login

import (
	fmt "fmt"
	github_com_akqp2019_protobuf_proto "github.com/akqp2019/protobuf/proto"
	proto "github.com/akqp2019/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type LoginMark int32

const (
	LoginMark_LOGIN_SUCCESS                 LoginMark = 1
	LoginMark_LOGIN_ERROR_ACCOUNT           LoginMark = 2
	LoginMark_LOGIN_ERROR_PASSWORD          LoginMark = 3
	LoginMark_LOGIN_ERROR_MESSAGE           LoginMark = 4
	LoginMark_LOGIN_ERROR_FREEZEIP          LoginMark = 5
	LoginMark_LOGIN_ERROR_FREEZEACCOUT      LoginMark = 6
	LoginMark_LOGIN_ERROR_STOPSERVER        LoginMark = 7
	LoginMark_LOGIN_ERROR_ONEKEYPHONE       LoginMark = 8
	LoginMark_LOGIN_ERROR_WECHATTOKEN       LoginMark = 9
	LoginMark_LOGIN_ERROR_AUTOTOKEN         LoginMark = 10
	LoginMark_REGISTER_ERROR_CREATEACCOUNT  LoginMark = 11
	LoginMark_LOGIN_ERROR_ACCOUNT_CANCELING LoginMark = 12
	LoginMark_LOGIN_ERROR_ACCOUNT_CANCELED  LoginMark = 13
	LoginMark_LOGIN_ERROR_BIND_PHONE        LoginMark = 14
	LoginMark_LOGIN_ERROR_BIND_PHONE_REPEAT LoginMark = 15
)

var LoginMark_name = map[int32]string{
	1:  "LOGIN_SUCCESS",
	2:  "LOGIN_ERROR_ACCOUNT",
	3:  "LOGIN_ERROR_PASSWORD",
	4:  "LOGIN_ERROR_MESSAGE",
	5:  "LOGIN_ERROR_FREEZEIP",
	6:  "LOGIN_ERROR_FREEZEACCOUT",
	7:  "LOGIN_ERROR_STOPSERVER",
	8:  "LOGIN_ERROR_ONEKEYPHONE",
	9:  "LOGIN_ERROR_WECHATTOKEN",
	10: "LOGIN_ERROR_AUTOTOKEN",
	11: "REGISTER_ERROR_CREATEACCOUNT",
	12: "LOGIN_ERROR_ACCOUNT_CANCELING",
	13: "LOGIN_ERROR_ACCOUNT_CANCELED",
	14: "LOGIN_ERROR_BIND_PHONE",
	15: "LOGIN_ERROR_BIND_PHONE_REPEAT",
}

var LoginMark_value = map[string]int32{
	"LOGIN_SUCCESS":                 1,
	"LOGIN_ERROR_ACCOUNT":           2,
	"LOGIN_ERROR_PASSWORD":          3,
	"LOGIN_ERROR_MESSAGE":           4,
	"LOGIN_ERROR_FREEZEIP":          5,
	"LOGIN_ERROR_FREEZEACCOUT":      6,
	"LOGIN_ERROR_STOPSERVER":        7,
	"LOGIN_ERROR_ONEKEYPHONE":       8,
	"LOGIN_ERROR_WECHATTOKEN":       9,
	"LOGIN_ERROR_AUTOTOKEN":         10,
	"REGISTER_ERROR_CREATEACCOUNT":  11,
	"LOGIN_ERROR_ACCOUNT_CANCELING": 12,
	"LOGIN_ERROR_ACCOUNT_CANCELED":  13,
	"LOGIN_ERROR_BIND_PHONE":        14,
	"LOGIN_ERROR_BIND_PHONE_REPEAT": 15,
}

func (x LoginMark) Enum() *LoginMark {
	p := new(LoginMark)
	*p = x
	return p
}

func (x LoginMark) String() string {
	return proto.EnumName(LoginMark_name, int32(x))
}

func (x *LoginMark) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LoginMark_value, data, "LoginMark")
	if err != nil {
		return err
	}
	*x = LoginMark(value)
	return nil
}

func (LoginMark) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67c21677aa7f4e4f, []int{0}
}

type LoginMsg struct {
	Account              *string  `protobuf:"bytes,1,req,name=Account" json:"Account,omitempty" bson:"Account,omitempty"`
	Password             *string  `protobuf:"bytes,2,opt,name=Password" json:"Password,omitempty" bson:"Password,omitempty"`
	PF                   *int32   `protobuf:"varint,3,opt,name=PF" json:"PF,omitempty" bson:"PF,omitempty"`
	LoginIp              *string  `protobuf:"bytes,5,opt,name=LoginIp" json:"LoginIp,omitempty" bson:"LoginIp,omitempty"`
	Type                 *int32   `protobuf:"varint,6,opt,name=Type" json:"Type,omitempty" bson:"Type,omitempty"`
	OneKeyToken          *string  `protobuf:"bytes,7,opt,name=OneKeyToken" json:"OneKeyToken,omitempty" bson:"OneKeyToken,omitempty"`
	WechatCode           *string  `protobuf:"bytes,9,opt,name=WechatCode" json:"WechatCode,omitempty" bson:"WechatCode,omitempty"`
	Mark                 *string  `protobuf:"bytes,10,opt,name=Mark" json:"Mark,omitempty" bson:"Mark,omitempty"`
	Token                *string  `protobuf:"bytes,11,opt,name=Token" json:"Token,omitempty" bson:"Token,omitempty"`
	LoginCode            *string  `protobuf:"bytes,12,opt,name=LoginCode" json:"LoginCode,omitempty" bson:"LoginCode,omitempty"`
	PlayerId             *int64   `protobuf:"varint,13,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	OpenId               *string  `protobuf:"bytes,14,opt,name=OpenId" json:"OpenId,omitempty" bson:"OpenId,omitempty"`
	Phone                *string  `protobuf:"bytes,15,opt,name=Phone" json:"Phone,omitempty" bson:"Phone,omitempty"`
	WeChatToken          *string  `protobuf:"bytes,16,opt,name=WeChatToken" json:"WeChatToken,omitempty" bson:"WeChatToken,omitempty"`
	AreaCode             *string  `protobuf:"bytes,17,opt,name=AreaCode" json:"AreaCode,omitempty" bson:"AreaCode,omitempty"`
	ApkCode              *int32   `protobuf:"varint,18,opt,name=ApkCode" json:"ApkCode,omitempty" bson:"ApkCode,omitempty"`
	UnionId              *string  `protobuf:"bytes,19,opt,name=UnionId" json:"UnionId,omitempty" bson:"UnionId,omitempty"`
	Idfa                 *string  `protobuf:"bytes,20,opt,name=Idfa" json:"Idfa,omitempty" bson:"Idfa,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *LoginMsg) Reset()         { *m = LoginMsg{} }
func (m *LoginMsg) String() string { return proto.CompactTextString(m) }
func (*LoginMsg) ProtoMessage()    {}
func (*LoginMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_67c21677aa7f4e4f, []int{0}
}
func (m *LoginMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginMsg.Merge(m, src)
}
func (m *LoginMsg) XXX_Size() int {
	return m.Size()
}
func (m *LoginMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginMsg.DiscardUnknown(m)
}

var xxx_messageInfo_LoginMsg proto.InternalMessageInfo

func (m *LoginMsg) GetAccount() string {
	if m != nil && m.Account != nil {
		return *m.Account
	}
	return ""
}

func (m *LoginMsg) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *LoginMsg) GetPF() int32 {
	if m != nil && m.PF != nil {
		return *m.PF
	}
	return 0
}

func (m *LoginMsg) GetLoginIp() string {
	if m != nil && m.LoginIp != nil {
		return *m.LoginIp
	}
	return ""
}

func (m *LoginMsg) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LoginMsg) GetOneKeyToken() string {
	if m != nil && m.OneKeyToken != nil {
		return *m.OneKeyToken
	}
	return ""
}

func (m *LoginMsg) GetWechatCode() string {
	if m != nil && m.WechatCode != nil {
		return *m.WechatCode
	}
	return ""
}

func (m *LoginMsg) GetMark() string {
	if m != nil && m.Mark != nil {
		return *m.Mark
	}
	return ""
}

func (m *LoginMsg) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

func (m *LoginMsg) GetLoginCode() string {
	if m != nil && m.LoginCode != nil {
		return *m.LoginCode
	}
	return ""
}

func (m *LoginMsg) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *LoginMsg) GetOpenId() string {
	if m != nil && m.OpenId != nil {
		return *m.OpenId
	}
	return ""
}

func (m *LoginMsg) GetPhone() string {
	if m != nil && m.Phone != nil {
		return *m.Phone
	}
	return ""
}

func (m *LoginMsg) GetWeChatToken() string {
	if m != nil && m.WeChatToken != nil {
		return *m.WeChatToken
	}
	return ""
}

func (m *LoginMsg) GetAreaCode() string {
	if m != nil && m.AreaCode != nil {
		return *m.AreaCode
	}
	return ""
}

func (m *LoginMsg) GetApkCode() int32 {
	if m != nil && m.ApkCode != nil {
		return *m.ApkCode
	}
	return 0
}

func (m *LoginMsg) GetUnionId() string {
	if m != nil && m.UnionId != nil {
		return *m.UnionId
	}
	return ""
}

func (m *LoginMsg) GetIdfa() string {
	if m != nil && m.Idfa != nil {
		return *m.Idfa
	}
	return ""
}

type RegisterMsg struct {
	Account              *string  `protobuf:"bytes,1,req,name=Account" json:"Account,omitempty" bson:"Account,omitempty"`
	Password             *string  `protobuf:"bytes,2,opt,name=Password" json:"Password,omitempty" bson:"Password,omitempty"`
	PasswordAgain        *string  `protobuf:"bytes,3,opt,name=PasswordAgain" json:"PasswordAgain,omitempty" bson:"PasswordAgain,omitempty"`
	NickName             *string  `protobuf:"bytes,4,opt,name=NickName" json:"NickName,omitempty" bson:"NickName,omitempty"`
	CheckCode            *string  `protobuf:"bytes,5,opt,name=CheckCode" json:"CheckCode,omitempty" bson:"CheckCode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *RegisterMsg) Reset()         { *m = RegisterMsg{} }
func (m *RegisterMsg) String() string { return proto.CompactTextString(m) }
func (*RegisterMsg) ProtoMessage()    {}
func (*RegisterMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_67c21677aa7f4e4f, []int{1}
}
func (m *RegisterMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterMsg.Merge(m, src)
}
func (m *RegisterMsg) XXX_Size() int {
	return m.Size()
}
func (m *RegisterMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterMsg.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterMsg proto.InternalMessageInfo

func (m *RegisterMsg) GetAccount() string {
	if m != nil && m.Account != nil {
		return *m.Account
	}
	return ""
}

func (m *RegisterMsg) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *RegisterMsg) GetPasswordAgain() string {
	if m != nil && m.PasswordAgain != nil {
		return *m.PasswordAgain
	}
	return ""
}

func (m *RegisterMsg) GetNickName() string {
	if m != nil && m.NickName != nil {
		return *m.NickName
	}
	return ""
}

func (m *RegisterMsg) GetCheckCode() string {
	if m != nil && m.CheckCode != nil {
		return *m.CheckCode
	}
	return ""
}

type LoginResult struct {
	Result               *LoginMark `protobuf:"varint,1,opt,name=Result,enum=client_login.LoginMark" json:"Result,omitempty" bson:"Result,omitempty"`
	Account              *string    `protobuf:"bytes,2,opt,name=Account" json:"Account,omitempty" bson:"Account,omitempty"`
	Address              *string    `protobuf:"bytes,3,opt,name=Address" json:"Address,omitempty" bson:"Address,omitempty"`
	Token                *string    `protobuf:"bytes,4,opt,name=Token" json:"Token,omitempty" bson:"Token,omitempty"`
	IsVisitor            *bool      `protobuf:"varint,5,opt,name=IsVisitor" json:"IsVisitor,omitempty" bson:"IsVisitor,omitempty"`
	LoginType            *int32     `protobuf:"varint,6,opt,name=LoginType" json:"LoginType,omitempty" bson:"LoginType,omitempty"`
	PlayerId             *int64     `protobuf:"varint,7,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	ErrMsg               *string    `protobuf:"bytes,8,opt,name=ErrMsg" json:"ErrMsg,omitempty" bson:"ErrMsg,omitempty"`
	IsAppAct             *bool      `protobuf:"varint,9,opt,name=IsAppAct" json:"IsAppAct,omitempty" bson:"IsAppAct,omitempty"`
	IsUserReg            *bool      `protobuf:"varint,10,opt,name=IsUserReg" json:"IsUserReg,omitempty" bson:"IsUserReg,omitempty"`
	IsLoginMan           *bool      `protobuf:"varint,11,opt,name=IsLoginMan" json:"IsLoginMan,omitempty" bson:"IsLoginMan,omitempty"`
	IsLoginFreq          *bool      `protobuf:"varint,12,opt,name=IsLoginFreq" json:"IsLoginFreq,omitempty" bson:"IsLoginFreq,omitempty"`
	OpenId               *string    `protobuf:"bytes,13,opt,name=OpenId" json:"OpenId,omitempty" bson:"OpenId,omitempty"`
	WeChatToken          *string    `protobuf:"bytes,14,opt,name=WeChatToken" json:"WeChatToken,omitempty" bson:"WeChatToken,omitempty"`
	UnionId              *string    `protobuf:"bytes,15,opt,name=UnionId" json:"UnionId,omitempty" bson:"UnionId,omitempty"`
	IsMarkChange         *bool      `protobuf:"varint,16,opt,name=IsMarkChange" json:"IsMarkChange,omitempty" bson:"IsMarkChange,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-" bson:"-"`
	XXX_unrecognized     []byte     `json:"-" bson:"-"`
	XXX_sizecache        int32      `json:"-" bson:"-"`
}

func (m *LoginResult) Reset()         { *m = LoginResult{} }
func (m *LoginResult) String() string { return proto.CompactTextString(m) }
func (*LoginResult) ProtoMessage()    {}
func (*LoginResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_67c21677aa7f4e4f, []int{2}
}
func (m *LoginResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginResult.Merge(m, src)
}
func (m *LoginResult) XXX_Size() int {
	return m.Size()
}
func (m *LoginResult) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginResult.DiscardUnknown(m)
}

var xxx_messageInfo_LoginResult proto.InternalMessageInfo

func (m *LoginResult) GetResult() LoginMark {
	if m != nil && m.Result != nil {
		return *m.Result
	}
	return LoginMark_LOGIN_SUCCESS
}

func (m *LoginResult) GetAccount() string {
	if m != nil && m.Account != nil {
		return *m.Account
	}
	return ""
}

func (m *LoginResult) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

func (m *LoginResult) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

func (m *LoginResult) GetIsVisitor() bool {
	if m != nil && m.IsVisitor != nil {
		return *m.IsVisitor
	}
	return false
}

func (m *LoginResult) GetLoginType() int32 {
	if m != nil && m.LoginType != nil {
		return *m.LoginType
	}
	return 0
}

func (m *LoginResult) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *LoginResult) GetErrMsg() string {
	if m != nil && m.ErrMsg != nil {
		return *m.ErrMsg
	}
	return ""
}

func (m *LoginResult) GetIsAppAct() bool {
	if m != nil && m.IsAppAct != nil {
		return *m.IsAppAct
	}
	return false
}

func (m *LoginResult) GetIsUserReg() bool {
	if m != nil && m.IsUserReg != nil {
		return *m.IsUserReg
	}
	return false
}

func (m *LoginResult) GetIsLoginMan() bool {
	if m != nil && m.IsLoginMan != nil {
		return *m.IsLoginMan
	}
	return false
}

func (m *LoginResult) GetIsLoginFreq() bool {
	if m != nil && m.IsLoginFreq != nil {
		return *m.IsLoginFreq
	}
	return false
}

func (m *LoginResult) GetOpenId() string {
	if m != nil && m.OpenId != nil {
		return *m.OpenId
	}
	return ""
}

func (m *LoginResult) GetWeChatToken() string {
	if m != nil && m.WeChatToken != nil {
		return *m.WeChatToken
	}
	return ""
}

func (m *LoginResult) GetUnionId() string {
	if m != nil && m.UnionId != nil {
		return *m.UnionId
	}
	return ""
}

func (m *LoginResult) GetIsMarkChange() bool {
	if m != nil && m.IsMarkChange != nil {
		return *m.IsMarkChange
	}
	return false
}

type AccountCancel struct {
	AccountType          *int32   `protobuf:"varint,1,opt,name=AccountType" json:"AccountType,omitempty" bson:"AccountType,omitempty"`
	Account              *string  `protobuf:"bytes,2,opt,name=Account" json:"Account,omitempty" bson:"Account,omitempty"`
	UnionId              *string  `protobuf:"bytes,3,opt,name=UnionId" json:"UnionId,omitempty" bson:"UnionId,omitempty"`
	ApkCode              *int32   `protobuf:"varint,4,opt,name=ApkCode" json:"ApkCode,omitempty" bson:"ApkCode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *AccountCancel) Reset()         { *m = AccountCancel{} }
func (m *AccountCancel) String() string { return proto.CompactTextString(m) }
func (*AccountCancel) ProtoMessage()    {}
func (*AccountCancel) Descriptor() ([]byte, []int) {
	return fileDescriptor_67c21677aa7f4e4f, []int{3}
}
func (m *AccountCancel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountCancel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountCancel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountCancel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountCancel.Merge(m, src)
}
func (m *AccountCancel) XXX_Size() int {
	return m.Size()
}
func (m *AccountCancel) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountCancel.DiscardUnknown(m)
}

var xxx_messageInfo_AccountCancel proto.InternalMessageInfo

func (m *AccountCancel) GetAccountType() int32 {
	if m != nil && m.AccountType != nil {
		return *m.AccountType
	}
	return 0
}

func (m *AccountCancel) GetAccount() string {
	if m != nil && m.Account != nil {
		return *m.Account
	}
	return ""
}

func (m *AccountCancel) GetUnionId() string {
	if m != nil && m.UnionId != nil {
		return *m.UnionId
	}
	return ""
}

func (m *AccountCancel) GetApkCode() int32 {
	if m != nil && m.ApkCode != nil {
		return *m.ApkCode
	}
	return 0
}

//注册登录埋点事件请求
type LoginEventRequst struct {
	PlayerId             *int64   `protobuf:"varint,1,opt,name=PlayerId" json:"PlayerId,omitempty" bson:"PlayerId,omitempty"`
	DeviceCode           *string  `protobuf:"bytes,2,opt,name=DeviceCode" json:"DeviceCode,omitempty" bson:"DeviceCode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *LoginEventRequst) Reset()         { *m = LoginEventRequst{} }
func (m *LoginEventRequst) String() string { return proto.CompactTextString(m) }
func (*LoginEventRequst) ProtoMessage()    {}
func (*LoginEventRequst) Descriptor() ([]byte, []int) {
	return fileDescriptor_67c21677aa7f4e4f, []int{4}
}
func (m *LoginEventRequst) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginEventRequst) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginEventRequst.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginEventRequst) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginEventRequst.Merge(m, src)
}
func (m *LoginEventRequst) XXX_Size() int {
	return m.Size()
}
func (m *LoginEventRequst) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginEventRequst.DiscardUnknown(m)
}

var xxx_messageInfo_LoginEventRequst proto.InternalMessageInfo

func (m *LoginEventRequst) GetPlayerId() int64 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *LoginEventRequst) GetDeviceCode() string {
	if m != nil && m.DeviceCode != nil {
		return *m.DeviceCode
	}
	return ""
}

//注册登录埋点事件返回
type LoginEventResult struct {
	IsAppAct             *bool    `protobuf:"varint,1,opt,name=IsAppAct" json:"IsAppAct,omitempty" bson:"IsAppAct,omitempty"`
	IsUserReg            *bool    `protobuf:"varint,2,opt,name=IsUserReg" json:"IsUserReg,omitempty" bson:"IsUserReg,omitempty"`
	IsLoginMan           *bool    `protobuf:"varint,3,opt,name=IsLoginMan" json:"IsLoginMan,omitempty" bson:"IsLoginMan,omitempty"`
	IsLoginFreq          *bool    `protobuf:"varint,4,opt,name=IsLoginFreq" json:"IsLoginFreq,omitempty" bson:"IsLoginFreq,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *LoginEventResult) Reset()         { *m = LoginEventResult{} }
func (m *LoginEventResult) String() string { return proto.CompactTextString(m) }
func (*LoginEventResult) ProtoMessage()    {}
func (*LoginEventResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_67c21677aa7f4e4f, []int{5}
}
func (m *LoginEventResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginEventResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginEventResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginEventResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginEventResult.Merge(m, src)
}
func (m *LoginEventResult) XXX_Size() int {
	return m.Size()
}
func (m *LoginEventResult) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginEventResult.DiscardUnknown(m)
}

var xxx_messageInfo_LoginEventResult proto.InternalMessageInfo

func (m *LoginEventResult) GetIsAppAct() bool {
	if m != nil && m.IsAppAct != nil {
		return *m.IsAppAct
	}
	return false
}

func (m *LoginEventResult) GetIsUserReg() bool {
	if m != nil && m.IsUserReg != nil {
		return *m.IsUserReg
	}
	return false
}

func (m *LoginEventResult) GetIsLoginMan() bool {
	if m != nil && m.IsLoginMan != nil {
		return *m.IsLoginMan
	}
	return false
}

func (m *LoginEventResult) GetIsLoginFreq() bool {
	if m != nil && m.IsLoginFreq != nil {
		return *m.IsLoginFreq
	}
	return false
}

func init() {
	proto.RegisterEnum("client_login.LoginMark", LoginMark_name, LoginMark_value)
	proto.RegisterType((*LoginMsg)(nil), "client_login.LoginMsg")
	proto.RegisterType((*RegisterMsg)(nil), "client_login.RegisterMsg")
	proto.RegisterType((*LoginResult)(nil), "client_login.LoginResult")
	proto.RegisterType((*AccountCancel)(nil), "client_login.AccountCancel")
	proto.RegisterType((*LoginEventRequst)(nil), "client_login.LoginEventRequst")
	proto.RegisterType((*LoginEventResult)(nil), "client_login.LoginEventResult")
}

func init() { proto.RegisterFile("login.proto", fileDescriptor_67c21677aa7f4e4f) }

var fileDescriptor_67c21677aa7f4e4f = []byte{
	// 922 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xc1, 0x72, 0xe2, 0x46,
	0x10, 0x2d, 0xc1, 0x62, 0x8b, 0x46, 0x60, 0x79, 0xf0, 0xda, 0x5a, 0xbc, 0xeb, 0x22, 0x5c, 0x42,
	0xe5, 0xc0, 0x81, 0x53, 0x2e, 0x49, 0x4a, 0x2b, 0x8f, 0xb1, 0x62, 0x5b, 0xa2, 0x24, 0x61, 0x2a,
	0xb9, 0x10, 0x45, 0xcc, 0x82, 0x0a, 0x2c, 0x69, 0x35, 0xb2, 0x53, 0xfe, 0xa6, 0x7c, 0xc1, 0xfe,
	0x41, 0x72, 0xcb, 0x27, 0xa4, 0xfc, 0x25, 0x29, 0xb5, 0x24, 0x47, 0x60, 0x9c, 0xca, 0x8d, 0xe9,
	0xd7, 0xfd, 0xba, 0xfb, 0xbd, 0xd1, 0x00, 0x8d, 0x75, 0xb8, 0xf0, 0x83, 0x41, 0x14, 0x87, 0x49,
	0x48, 0x24, 0x6f, 0xed, 0xb3, 0x20, 0x99, 0x61, 0xac, 0x03, 0xbf, 0xba, 0x9c, 0x65, 0x48, 0x47,
	0xf2, 0xc2, 0xbb, 0xbb, 0x30, 0xcf, 0xeb, 0x7d, 0xa9, 0x80, 0x78, 0x9d, 0xe6, 0xdc, 0xf0, 0x05,
	0x39, 0x80, 0x7d, 0xd5, 0xf3, 0xc2, 0xfb, 0x20, 0x51, 0x84, 0x6e, 0xa5, 0x5f, 0x27, 0x32, 0x88,
	0x63, 0x97, 0xf3, 0xdf, 0xc2, 0x78, 0xae, 0x54, 0xba, 0x42, 0xbf, 0x4e, 0x00, 0x2a, 0xe3, 0x0b,
	0xa5, 0xda, 0x15, 0xfa, 0xb5, 0x34, 0x1d, 0x4b, 0xf5, 0x48, 0xa9, 0x21, 0x28, 0xc1, 0x1b, 0xe7,
	0x31, 0x62, 0xca, 0x1e, 0xc2, 0x6d, 0x68, 0x98, 0x01, 0xbb, 0x62, 0x8f, 0x4e, 0xb8, 0x62, 0x81,
	0xb2, 0x8f, 0x29, 0x04, 0x60, 0xca, 0xbc, 0xa5, 0x9b, 0x68, 0xe1, 0x9c, 0x29, 0xf5, 0xa2, 0xec,
	0xc6, 0x8d, 0x57, 0x0a, 0xe0, 0xa9, 0x09, 0xb5, 0xac, 0xa0, 0x81, 0xc7, 0x43, 0xa8, 0x63, 0x13,
	0xcc, 0x97, 0x30, 0x94, 0x4e, 0xb5, 0x76, 0x1f, 0x59, 0xac, 0xcf, 0x95, 0x66, 0x57, 0xe8, 0x57,
	0x49, 0x0b, 0xf6, 0xcc, 0x88, 0x05, 0xfa, 0x5c, 0x69, 0x15, 0x1c, 0xe3, 0x65, 0x18, 0x30, 0xe5,
	0x00, 0x8f, 0x6d, 0x68, 0x4c, 0x99, 0xb6, 0x74, 0x93, 0x8c, 0x58, 0x2e, 0x58, 0xd4, 0x98, 0xb9,
	0xc8, 0x7b, 0x88, 0x91, 0x74, 0xfd, 0x68, 0x85, 0x01, 0x52, 0x2c, 0x38, 0x09, 0xfc, 0x30, 0xe5,
	0x6d, 0x17, 0x93, 0xea, 0xf3, 0x4f, 0xae, 0x72, 0x94, 0x9e, 0x7a, 0x6b, 0x68, 0x58, 0x6c, 0xe1,
	0xf3, 0x84, 0xc5, 0xff, 0x53, 0xbd, 0xb7, 0xd0, 0x2c, 0x22, 0xea, 0xc2, 0xf5, 0x03, 0x14, 0x12,
	0x13, 0x0d, 0xdf, 0x5b, 0x19, 0xee, 0x1d, 0x53, 0xde, 0x14, 0x5b, 0x6b, 0x4b, 0xe6, 0x65, 0xc3,
	0xa0, 0xb8, 0xbd, 0x3f, 0x2b, 0xd0, 0x40, 0x25, 0x2c, 0xc6, 0xef, 0xd7, 0x09, 0xf9, 0x1a, 0xf6,
	0xb2, 0x5f, 0x8a, 0xd0, 0x15, 0xfa, 0xad, 0xe1, 0xc9, 0xa0, 0x6c, 0xf9, 0x20, 0x33, 0xd5, 0x8d,
	0x57, 0xe5, 0xb9, 0x2a, 0xcf, 0x7b, 0xce, 0xe7, 0x31, 0xe3, 0x3c, 0xef, 0xff, 0x2c, 0xf9, 0x73,
	0x73, 0x9d, 0xdf, 0xfa, 0xdc, 0x4f, 0xc2, 0x18, 0x9b, 0x8b, 0xcf, 0x2e, 0x94, 0xec, 0x2d, 0xbb,
	0xb0, 0x5f, 0xb8, 0x40, 0xe3, 0x54, 0x0a, 0x45, 0x2c, 0xd6, 0xd2, 0xb9, 0x1a, 0x45, 0xaa, 0x97,
	0xa0, 0xd3, 0x62, 0xc6, 0x3c, 0xe1, 0x2c, 0xb6, 0xd8, 0x02, 0xed, 0x16, 0xd3, 0x0b, 0xa1, 0xf3,
	0x7c, 0xd8, 0xcc, 0x73, 0x31, 0xf5, 0x2b, 0x8f, 0x5d, 0xc4, 0xec, 0x33, 0xba, 0x2e, 0x96, 0x3c,
	0x6e, 0xee, 0x32, 0xb5, 0x55, 0xac, 0x56, 0x38, 0x96, 0x59, 0x7f, 0x04, 0x92, 0xce, 0x53, 0x19,
	0xb4, 0xa5, 0x1b, 0x2c, 0x18, 0x7a, 0x2f, 0xf6, 0xa6, 0xd0, 0xcc, 0x25, 0xd1, 0xdc, 0xc0, 0x63,
	0xeb, 0x94, 0x2c, 0x0f, 0xe0, 0x86, 0x42, 0x61, 0xff, 0x0b, 0xe1, 0x0a, 0xf6, 0xea, 0xf6, 0x8d,
	0x49, 0xa5, 0xab, 0xf5, 0xbe, 0x05, 0x19, 0xe7, 0xa6, 0x0f, 0x2c, 0x48, 0x2c, 0xf6, 0xf9, 0x9e,
	0x27, 0x1b, 0x42, 0x09, 0x28, 0x14, 0x01, 0x38, 0x67, 0x0f, 0xbe, 0xc7, 0xb0, 0x12, 0xb9, 0x7b,
	0xbf, 0x6c, 0x56, 0xa2, 0xc5, 0x65, 0x01, 0x85, 0x97, 0x02, 0x56, 0x76, 0x08, 0x58, 0xdd, 0x25,
	0x60, 0x3a, 0x9b, 0xf8, 0xcd, 0x97, 0x6a, 0x6e, 0x22, 0xde, 0x8a, 0x43, 0x68, 0x5e, 0x9b, 0x23,
	0xdd, 0x98, 0xd9, 0x13, 0x4d, 0xa3, 0xb6, 0x2d, 0x0b, 0xe4, 0x04, 0xda, 0x59, 0x88, 0x5a, 0x96,
	0x69, 0xcd, 0x54, 0x4d, 0x33, 0x27, 0x86, 0x23, 0x57, 0x88, 0x02, 0x47, 0x65, 0x60, 0xac, 0xda,
	0xf6, 0xd4, 0xb4, 0xce, 0xe5, 0xea, 0x76, 0xc9, 0x0d, 0xb5, 0x6d, 0x75, 0x44, 0xe5, 0x37, 0xdb,
	0x25, 0x17, 0x16, 0xa5, 0x3f, 0x53, 0x7d, 0x2c, 0xd7, 0xc8, 0x7b, 0x50, 0x5e, 0x22, 0xd8, 0xcb,
	0x91, 0xf7, 0x48, 0x07, 0x8e, 0xcb, 0xa8, 0xed, 0x98, 0x63, 0x9b, 0x5a, 0xb7, 0xd4, 0x92, 0xf7,
	0xc9, 0x29, 0x9c, 0x94, 0x31, 0xd3, 0xa0, 0x57, 0xf4, 0xa7, 0xf1, 0xa5, 0x69, 0x50, 0x59, 0xdc,
	0x06, 0xa7, 0x54, 0xbb, 0x54, 0x1d, 0xc7, 0xbc, 0xa2, 0x86, 0x5c, 0x27, 0xef, 0xe0, 0xed, 0xc6,
	0x66, 0x13, 0xc7, 0xcc, 0x20, 0x20, 0x5d, 0x78, 0x6f, 0xd1, 0x91, 0x6e, 0x3b, 0xd4, 0xca, 0x51,
	0xcd, 0xa2, 0xaa, 0x43, 0x8b, 0xed, 0x1b, 0xe4, 0x2b, 0xf8, 0xb0, 0x43, 0x96, 0x99, 0xa6, 0x1a,
	0x1a, 0xbd, 0xd6, 0x8d, 0x91, 0x2c, 0xa5, 0x24, 0xaf, 0xa7, 0xd0, 0x73, 0xb9, 0xb9, 0xbd, 0xd7,
	0x47, 0xdd, 0x38, 0x9f, 0x65, 0xa3, 0xb7, 0xb6, 0x1b, 0xfc, 0x8b, 0xcd, 0x2c, 0x3a, 0xa6, 0xaa,
	0x23, 0x1f, 0x0c, 0x7f, 0xaf, 0x82, 0xa4, 0xe1, 0xe7, 0x3d, 0x44, 0x0b, 0x89, 0x0a, 0x92, 0x15,
	0x79, 0xf8, 0xfb, 0xd2, 0x5d, 0xaf, 0xc9, 0xf1, 0xae, 0xaf, 0x9f, 0x2f, 0x3a, 0xef, 0x76, 0xc4,
	0xf3, 0xdb, 0xf5, 0x3d, 0xc8, 0x56, 0xe4, 0x65, 0xac, 0x23, 0x86, 0x0f, 0x32, 0xf9, 0x50, 0xa4,
	0x73, 0x16, 0x3f, 0xb0, 0x78, 0x90, 0xc7, 0xd3, 0x9b, 0xcc, 0x78, 0xd2, 0x69, 0x0c, 0xf0, 0x8f,
	0x84, 0xde, 0x45, 0xc9, 0x23, 0xf9, 0x01, 0xda, 0x69, 0x7d, 0xfa, 0x4c, 0xdd, 0x30, 0xce, 0xdd,
	0x05, 0x5e, 0x67, 0x72, 0xba, 0x45, 0x91, 0xd5, 0xf3, 0x28, 0x0c, 0x38, 0xdb, 0x24, 0xf8, 0x0e,
	0x8e, 0xad, 0xc8, 0xbb, 0x08, 0xe3, 0x05, 0x4b, 0x70, 0xb0, 0xe2, 0x6d, 0x7c, 0x75, 0x9b, 0x8d,
	0xf2, 0x1f, 0xe1, 0xa8, 0xe8, 0x9f, 0x7f, 0xa6, 0xb7, 0xae, 0xbf, 0x9e, 0x13, 0x65, 0x7b, 0x80,
	0x34, 0x43, 0x0f, 0x3e, 0x85, 0x9d, 0x57, 0x11, 0x72, 0x8d, 0x5a, 0x6c, 0xbe, 0x09, 0xa7, 0x9b,
	0x43, 0x6c, 0x80, 0x9d, 0xff, 0x02, 0x87, 0x2d, 0x90, 0x70, 0xe4, 0x61, 0x26, 0xee, 0x47, 0xe9,
	0x8f, 0xa7, 0x33, 0xe1, 0xaf, 0xa7, 0x33, 0xe1, 0xef, 0xa7, 0x33, 0xe1, 0x9f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x34, 0x5a, 0xae, 0x43, 0xa8, 0x07, 0x00, 0x00,
}

func (m *LoginMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account == nil {
		return 0, github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("Account")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.Account)))
		i += copy(dAtA[i:], *m.Account)
	}
	if m.Password != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.Password)))
		i += copy(dAtA[i:], *m.Password)
	}
	if m.PF != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLogin(dAtA, i, uint64(*m.PF))
	}
	if m.LoginIp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.LoginIp)))
		i += copy(dAtA[i:], *m.LoginIp)
	}
	if m.Type != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintLogin(dAtA, i, uint64(*m.Type))
	}
	if m.OneKeyToken != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.OneKeyToken)))
		i += copy(dAtA[i:], *m.OneKeyToken)
	}
	if m.WechatCode != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.WechatCode)))
		i += copy(dAtA[i:], *m.WechatCode)
	}
	if m.Mark != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.Mark)))
		i += copy(dAtA[i:], *m.Mark)
	}
	if m.Token != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.Token)))
		i += copy(dAtA[i:], *m.Token)
	}
	if m.LoginCode != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.LoginCode)))
		i += copy(dAtA[i:], *m.LoginCode)
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintLogin(dAtA, i, uint64(*m.PlayerId))
	}
	if m.OpenId != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.OpenId)))
		i += copy(dAtA[i:], *m.OpenId)
	}
	if m.Phone != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.Phone)))
		i += copy(dAtA[i:], *m.Phone)
	}
	if m.WeChatToken != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.WeChatToken)))
		i += copy(dAtA[i:], *m.WeChatToken)
	}
	if m.AreaCode != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.AreaCode)))
		i += copy(dAtA[i:], *m.AreaCode)
	}
	if m.ApkCode != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLogin(dAtA, i, uint64(*m.ApkCode))
	}
	if m.UnionId != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.UnionId)))
		i += copy(dAtA[i:], *m.UnionId)
	}
	if m.Idfa != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.Idfa)))
		i += copy(dAtA[i:], *m.Idfa)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RegisterMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account == nil {
		return 0, github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("Account")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.Account)))
		i += copy(dAtA[i:], *m.Account)
	}
	if m.Password != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.Password)))
		i += copy(dAtA[i:], *m.Password)
	}
	if m.PasswordAgain != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.PasswordAgain)))
		i += copy(dAtA[i:], *m.PasswordAgain)
	}
	if m.NickName != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.NickName)))
		i += copy(dAtA[i:], *m.NickName)
	}
	if m.CheckCode != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.CheckCode)))
		i += copy(dAtA[i:], *m.CheckCode)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoginResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(*m.Result))
	}
	if m.Account != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.Account)))
		i += copy(dAtA[i:], *m.Account)
	}
	if m.Address != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.Address)))
		i += copy(dAtA[i:], *m.Address)
	}
	if m.Token != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.Token)))
		i += copy(dAtA[i:], *m.Token)
	}
	if m.IsVisitor != nil {
		dAtA[i] = 0x28
		i++
		if *m.IsVisitor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LoginType != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintLogin(dAtA, i, uint64(*m.LoginType))
	}
	if m.PlayerId != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintLogin(dAtA, i, uint64(*m.PlayerId))
	}
	if m.ErrMsg != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.ErrMsg)))
		i += copy(dAtA[i:], *m.ErrMsg)
	}
	if m.IsAppAct != nil {
		dAtA[i] = 0x48
		i++
		if *m.IsAppAct {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsUserReg != nil {
		dAtA[i] = 0x50
		i++
		if *m.IsUserReg {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsLoginMan != nil {
		dAtA[i] = 0x58
		i++
		if *m.IsLoginMan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsLoginFreq != nil {
		dAtA[i] = 0x60
		i++
		if *m.IsLoginFreq {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OpenId != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.OpenId)))
		i += copy(dAtA[i:], *m.OpenId)
	}
	if m.WeChatToken != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.WeChatToken)))
		i += copy(dAtA[i:], *m.WeChatToken)
	}
	if m.UnionId != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.UnionId)))
		i += copy(dAtA[i:], *m.UnionId)
	}
	if m.IsMarkChange != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if *m.IsMarkChange {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AccountCancel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountCancel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AccountType != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(*m.AccountType))
	}
	if m.Account != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.Account)))
		i += copy(dAtA[i:], *m.Account)
	}
	if m.UnionId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.UnionId)))
		i += copy(dAtA[i:], *m.UnionId)
	}
	if m.ApkCode != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLogin(dAtA, i, uint64(*m.ApkCode))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoginEventRequst) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginEventRequst) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(*m.PlayerId))
	}
	if m.DeviceCode != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(*m.DeviceCode)))
		i += copy(dAtA[i:], *m.DeviceCode)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoginEventResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginEventResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsAppAct != nil {
		dAtA[i] = 0x8
		i++
		if *m.IsAppAct {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsUserReg != nil {
		dAtA[i] = 0x10
		i++
		if *m.IsUserReg {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsLoginMan != nil {
		dAtA[i] = 0x18
		i++
		if *m.IsLoginMan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsLoginFreq != nil {
		dAtA[i] = 0x20
		i++
		if *m.IsLoginFreq {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintLogin(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LoginMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Account != nil {
		l = len(*m.Account)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.Password != nil {
		l = len(*m.Password)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.PF != nil {
		n += 1 + sovLogin(uint64(*m.PF))
	}
	if m.LoginIp != nil {
		l = len(*m.LoginIp)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovLogin(uint64(*m.Type))
	}
	if m.OneKeyToken != nil {
		l = len(*m.OneKeyToken)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.WechatCode != nil {
		l = len(*m.WechatCode)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.Mark != nil {
		l = len(*m.Mark)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.Token != nil {
		l = len(*m.Token)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.LoginCode != nil {
		l = len(*m.LoginCode)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.PlayerId != nil {
		n += 1 + sovLogin(uint64(*m.PlayerId))
	}
	if m.OpenId != nil {
		l = len(*m.OpenId)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.Phone != nil {
		l = len(*m.Phone)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.WeChatToken != nil {
		l = len(*m.WeChatToken)
		n += 2 + l + sovLogin(uint64(l))
	}
	if m.AreaCode != nil {
		l = len(*m.AreaCode)
		n += 2 + l + sovLogin(uint64(l))
	}
	if m.ApkCode != nil {
		n += 2 + sovLogin(uint64(*m.ApkCode))
	}
	if m.UnionId != nil {
		l = len(*m.UnionId)
		n += 2 + l + sovLogin(uint64(l))
	}
	if m.Idfa != nil {
		l = len(*m.Idfa)
		n += 2 + l + sovLogin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegisterMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Account != nil {
		l = len(*m.Account)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.Password != nil {
		l = len(*m.Password)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.PasswordAgain != nil {
		l = len(*m.PasswordAgain)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.NickName != nil {
		l = len(*m.NickName)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.CheckCode != nil {
		l = len(*m.CheckCode)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoginResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		n += 1 + sovLogin(uint64(*m.Result))
	}
	if m.Account != nil {
		l = len(*m.Account)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.Address != nil {
		l = len(*m.Address)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.Token != nil {
		l = len(*m.Token)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.IsVisitor != nil {
		n += 2
	}
	if m.LoginType != nil {
		n += 1 + sovLogin(uint64(*m.LoginType))
	}
	if m.PlayerId != nil {
		n += 1 + sovLogin(uint64(*m.PlayerId))
	}
	if m.ErrMsg != nil {
		l = len(*m.ErrMsg)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.IsAppAct != nil {
		n += 2
	}
	if m.IsUserReg != nil {
		n += 2
	}
	if m.IsLoginMan != nil {
		n += 2
	}
	if m.IsLoginFreq != nil {
		n += 2
	}
	if m.OpenId != nil {
		l = len(*m.OpenId)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.WeChatToken != nil {
		l = len(*m.WeChatToken)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.UnionId != nil {
		l = len(*m.UnionId)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.IsMarkChange != nil {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccountCancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountType != nil {
		n += 1 + sovLogin(uint64(*m.AccountType))
	}
	if m.Account != nil {
		l = len(*m.Account)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.UnionId != nil {
		l = len(*m.UnionId)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.ApkCode != nil {
		n += 1 + sovLogin(uint64(*m.ApkCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoginEventRequst) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovLogin(uint64(*m.PlayerId))
	}
	if m.DeviceCode != nil {
		l = len(*m.DeviceCode)
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoginEventResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsAppAct != nil {
		n += 2
	}
	if m.IsUserReg != nil {
		n += 2
	}
	if m.IsLoginMan != nil {
		n += 2
	}
	if m.IsLoginFreq != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLogin(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLogin(x uint64) (n int) {
	return sovLogin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LoginMsg) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Account = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Password = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PF", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PF = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LoginIp = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneKeyToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OneKeyToken = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WechatCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WechatCode = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Mark = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Token = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LoginCode = &s
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OpenId = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Phone = &s
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeChatToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WeChatToken = &s
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AreaCode = &s
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApkCode", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ApkCode = &v
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UnionId = &s
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idfa", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Idfa = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("Account")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterMsg) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Account = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Password = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordAgain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PasswordAgain = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NickName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CheckCode = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_akqp2019_protobuf_proto.NewRequiredNotSetError("Account")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v LoginMark
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= LoginMark(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Account = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Address = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Token = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVisitor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsVisitor = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoginType = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ErrMsg = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAppAct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsAppAct = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUserReg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsUserReg = &b
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLoginMan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsLoginMan = &b
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLoginFreq", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsLoginFreq = &b
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OpenId = &s
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeChatToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WeChatToken = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UnionId = &s
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMarkChange", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsMarkChange = &b
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountCancel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountCancel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountCancel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AccountType = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Account = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UnionId = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApkCode", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ApkCode = &v
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginEventRequst) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginEventRequst: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginEventRequst: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DeviceCode = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginEventResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginEventResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginEventResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAppAct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsAppAct = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUserReg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsUserReg = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLoginMan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsLoginMan = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLoginFreq", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsLoginFreq = &b
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLogin(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLogin
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthLogin
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLogin
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLogin(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthLogin
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLogin = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLogin   = fmt.Errorf("proto: integer overflow")
)
